## K210 – FPGA – Arduino 通信机制说明（实测版）

### 1. 系统结构

```
K210 (UART)
   ↓
FPGA（帧同步 + SRAM 缓冲）
   ↓
Arduino / STM32（ExtSRAMInterface）
```

FPGA 在该系统中**不是透明转发器**，而是：

- 负责 UART 帧同步
- 对合法帧进行接收
- 将有效载荷写入 SRAM 供 MCU 读取

------

### 2. K210 → FPGA 发送规则（严格）

FPGA 仅接受 **固定 8 字节** 的完整数据帧：

```
Byte0  : 0x55   （帧头 MSB）
Byte1  : 0x02   （帧头 LSB）
Byte2  : data1
Byte3  : data2
Byte4  : data3
Byte5  : data4
Byte6  : data5
Byte7  : chk    （data1~data5 累加取低 8 位）
Byte8  : 0xBB   （帧尾）
```

> ⚠ 若缺失帧头、校验或帧尾，FPGA 将直接丢弃数据。

------

### 3. FPGA → Arduino 接收规则（0x6038）

接收端基地址：

```
K210_RX_BASE_ADDR = 0x6038
```

Arduino 通过：

```c
ExtSRAMInterface.ExMem_Read_Bytes(0x6038, buf, len);
```

进行读取。

#### 特点：

- 支持变长数据（len > 8）
- 数据为 UART 接收后写入 SRAM 的连续字节
- FPGA 不对变长数据内容做解析

------

### 4. 帧头吞噬行为（重点）

- `0x55` 仅用于 FPGA 内部帧同步
- 在首次读取时可能可见
- 后续读取中会被刷新为 `0x00`
- 其余字段保持稳定

#### 结论：

> **接收端禁止依赖 `0x55` 判断帧起始**

推荐解析起点：

- `0x02`（帧头 LSB）
- CMD / LEN 字段

------

### 5. 缓冲区管理要求

SRAM 缓冲区不会自动清空。

#### 必须：

- 每次处理完数据后主动清空
- 或通过状态标志避免重复解析

------

### 6. 变长数据缓冲区范围（部分推测）

| 地址范围        | 状态             |
| --------------- | ---------------- |
| 0x6038          | 已确认起始       |
| 0x6080          | 已知有其他功能   |
| 0x6038 ~ 0x607F | 推测为安全变长区 |

------

## 7. 总结

- **发送端**：必须 8 字节固定帧
- **接收端**：支持变长数据
- **0x55**：同步字节，不是稳定数据
- **SRAM**：需手动管理生命周期