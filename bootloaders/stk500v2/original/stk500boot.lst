   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB13:
  14               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   6:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   7:stk500boot.c  **** License:   GNU General Public License
   8:stk500boot.c  **** 
   9:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  10:stk500boot.c  **** Date:      17 October 2007
  11:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  12:stk500boot.c  **** Compiler:  WINAVR20060421
  13:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  14:stk500boot.c  **** 
  15:stk500boot.c  **** DESCRIPTION:
  16:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  17:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  18:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  19:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  20:stk500boot.c  ****     "reset" vector in Application area.
  21:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  22:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  23:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  24:stk500boot.c  **** 
  25:stk500boot.c  **** USAGE:
  26:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  27:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  28:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  29:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  30:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  31:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  32:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  33:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  34:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  35:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  36:stk500boot.c  ****     - AVRISP will detect the bootloader
  37:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  38:stk500boot.c  **** 
  39:stk500boot.c  **** Note:
  40:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  41:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  42:stk500boot.c  ****     Flash is always erased before programming.
  43:stk500boot.c  **** 
  44:stk500boot.c  **** 	AVRdude:
  45:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  46:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  47:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  48:stk500boot.c  **** 
  49:stk500boot.c  **** NOTES:
  50:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  51:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  52:stk500boot.c  **** 
  53:stk500boot.c  **** LICENSE:
  54:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  55:stk500boot.c  **** 
  56:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  57:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  58:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  59:stk500boot.c  ****     any later version.
  60:stk500boot.c  **** 
  61:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  62:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  63:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  64:stk500boot.c  ****     GNU General Public License for more details.
  65:stk500boot.c  **** 
  66:stk500boot.c  **** *****************************************************************************/
  67:stk500boot.c  **** 
  68:stk500boot.c  **** //************************************************************************
  69:stk500boot.c  **** //*	Edit History
  70:stk500boot.c  **** //************************************************************************
  71:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  74:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  76:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  78:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  79:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  80:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  81:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  82:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  83:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  84:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  86:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  89:stk500boot.c  **** //************************************************************************
  90:stk500boot.c  **** 
  91:stk500boot.c  **** //************************************************************************
  92:stk500boot.c  **** //*	these are used to test issues
  93:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  94:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  95:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  96:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
  97:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  98:stk500boot.c  **** #define	_FIX_ISSUE_505_
  99:stk500boot.c  **** //************************************************************************
 100:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 101:stk500boot.c  **** #define	_FIX_ISSUE_181_
 102:stk500boot.c  **** 
 103:stk500boot.c  **** #include	<inttypes.h>
 104:stk500boot.c  **** #include	<avr/io.h>
 105:stk500boot.c  **** #include	<avr/interrupt.h>
 106:stk500boot.c  **** #include	<avr/boot.h>
 107:stk500boot.c  **** #include	<avr/pgmspace.h>
 108:stk500boot.c  **** #include	<util/delay.h>
 109:stk500boot.c  **** #include	<avr/eeprom.h>
 110:stk500boot.c  **** #include	<avr/common.h>
 111:stk500boot.c  **** #include	<stdlib.h>
 112:stk500boot.c  **** #include	"command.h"
 113:stk500boot.c  **** 
 114:stk500boot.c  **** 
 115:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 116:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 117:stk500boot.c  **** 	#undef		ENABLE_MONITOR
 118:stk500boot.c  **** 	#define		ENABLE_MONITOR
 119:stk500boot.c  **** 	static void	RunMonitor(void);
 120:stk500boot.c  **** #endif
 121:stk500boot.c  **** 
 122:stk500boot.c  **** #ifndef EEWE
 123:stk500boot.c  **** 	#define EEWE    1
 124:stk500boot.c  **** #endif
 125:stk500boot.c  **** #ifndef EEMWE
 126:stk500boot.c  **** 	#define EEMWE   2
 127:stk500boot.c  **** #endif
 128:stk500boot.c  **** 
 129:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 130:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 131:stk500boot.c  **** 
 132:stk500boot.c  **** 
 133:stk500boot.c  **** /*
 134:stk500boot.c  ****  * Uncomment the following lines to save code space
 135:stk500boot.c  ****  */
 136:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 137:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 138:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 139:stk500boot.c  **** //
 140:stk500boot.c  **** 
 141:stk500boot.c  **** 
 142:stk500boot.c  **** 
 143:stk500boot.c  **** //************************************************************************
 144:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 145:stk500boot.c  **** //*	indicates that bootloader is active
 146:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 147:stk500boot.c  **** //************************************************************************
 148:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 149:stk500boot.c  **** 
 150:stk500boot.c  **** #ifdef _MEGA_BOARD_
 151:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 152:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 153:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 154:stk500boot.c  **** #elif defined( _BOARD_AMBER128_ )
 155:stk500boot.c  **** 	//*	this is for the amber 128 http://www.soc-robotics.com/
 156:stk500boot.c  **** 	//*	onbarod led is PORTE4
 157:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 158:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 159:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 160:stk500boot.c  **** #elif defined( _CEREBOTPLUS_BOARD_ ) || defined(_CEREBOT_II_BOARD_)
 161:stk500boot.c  **** 	//*	this is for the Cerebot 2560 board and the Cerebot-ii
 162:stk500boot.c  **** 	//*	onbarod leds are on PORTE4-7
 163:stk500boot.c  **** 	#define PROGLED_PORT	PORTE
 164:stk500boot.c  **** 	#define PROGLED_DDR		DDRE
 165:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 166:stk500boot.c  **** #elif defined( _PENGUINO_ )
 167:stk500boot.c  **** 	//*	this is for the Penguino
 168:stk500boot.c  **** 	//*	onbarod led is PORTE4
 169:stk500boot.c  **** 	#define PROGLED_PORT	PORTC
 170:stk500boot.c  **** 	#define PROGLED_DDR		DDRC
 171:stk500boot.c  **** 	#define PROGLED_PIN		PINC6
 172:stk500boot.c  **** #elif defined( _ANDROID_2561_ ) || defined( __AVR_ATmega2561__ )
 173:stk500boot.c  **** 	//*	this is for the Boston Android 2561
 174:stk500boot.c  **** 	//*	onbarod led is PORTE4
 175:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 176:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 177:stk500boot.c  **** 	#define PROGLED_PIN		PINA3
 178:stk500boot.c  **** #elif defined( _BOARD_MEGA16 )
 179:stk500boot.c  **** 	//*	onbarod led is PORTA7
 180:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 181:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 182:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 183:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 184:stk500boot.c  **** 
 185:stk500boot.c  **** #elif defined( _BOARD_BAHBOT_ )
 186:stk500boot.c  **** 	//*	dosent have an onboard LED but this is what will probably be added to this port
 187:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 188:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 189:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 190:stk500boot.c  **** 
 191:stk500boot.c  **** #elif defined( _BOARD_ROBOTX_ )
 192:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 193:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 194:stk500boot.c  **** 	#define PROGLED_PIN		PINB6
 195:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_BLINK_B0_ )
 196:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 197:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 198:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 199:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_ )
 200:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 201:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 202:stk500boot.c  **** 	#define PROGLED_PIN		PIND5
 203:stk500boot.c  **** #elif defined( _AVRLIP_ )
 204:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 205:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 206:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 207:stk500boot.c  **** #elif defined( _BOARD_STK500_ )
 208:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 209:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 210:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 211:stk500boot.c  **** #elif defined( _BOARD_STK502_ )
 212:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 213:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 214:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 215:stk500boot.c  **** #elif defined( _BOARD_STK525_ )
 216:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 217:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 218:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 219:stk500boot.c  **** #else
 220:stk500boot.c  **** 	#define PROGLED_PORT	PORTG
 221:stk500boot.c  **** 	#define PROGLED_DDR		DDRG
 222:stk500boot.c  **** 	#define PROGLED_PIN		PING2
 223:stk500boot.c  **** #endif
 224:stk500boot.c  **** 
 225:stk500boot.c  **** 
 226:stk500boot.c  **** 
 227:stk500boot.c  **** /*
 228:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 229:stk500boot.c  ****  */
 230:stk500boot.c  **** #ifndef F_CPU
 231:stk500boot.c  **** 	#define F_CPU 16000000UL
 232:stk500boot.c  **** #endif
 233:stk500boot.c  **** 
 234:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 235:stk500boot.c  **** /*
 236:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 237:stk500boot.c  ****  */
 238:stk500boot.c  **** 
 239:stk500boot.c  **** #ifndef BAUDRATE
 240:stk500boot.c  **** 	#define BAUDRATE 115200
 241:stk500boot.c  **** #endif
 242:stk500boot.c  **** 
 243:stk500boot.c  **** /*
 244:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 245:stk500boot.c  ****  */
 246:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 247:stk500boot.c  **** 	#if defined (__AVR_ATmega32__)
 248:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 249:stk500boot.c  **** 	#else
 250:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 251:stk500boot.c  **** 	#endif
 252:stk500boot.c  **** #endif
 253:stk500boot.c  **** 
 254:stk500boot.c  **** /*
 255:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 256:stk500boot.c  ****  */
 257:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 258:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 259:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 260:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 261:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 262:stk500boot.c  **** 
 263:stk500boot.c  **** /*
 264:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 265:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 266:stk500boot.c  ****  */
 267:stk500boot.c  **** //#define BOOTSIZE 1024
 268:stk500boot.c  **** #if FLASHEND > 0x0F000
 269:stk500boot.c  **** 	#define BOOTSIZE 8192
 270:stk500boot.c  **** #else
 271:stk500boot.c  **** 	#define BOOTSIZE 2048
 272:stk500boot.c  **** #endif
 273:stk500boot.c  **** 
 274:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 275:stk500boot.c  **** 
 276:stk500boot.c  **** /*
 277:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 278:stk500boot.c  ****  */
 279:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 280:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9307
 281:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 282:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9403
 283:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 284:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9502
 285:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 286:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9306
 287:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 288:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9308
 289:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 290:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9404
 291:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 292:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9702
 293:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 294:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9703
 295:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 296:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9801
 297:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 298:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9802
 299:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 300:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9705
 301:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 302:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9608
 303:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 304:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1E9602
 305:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 306:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9405
 307:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 308:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9782
 309:stk500boot.c  **** #else
 310:stk500boot.c  **** 	#error "no signature definition for MCU available"
 311:stk500boot.c  **** #endif
 312:stk500boot.c  **** 
 313:stk500boot.c  **** 
 314:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 315:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 316:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 317:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 318:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 319:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 320:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 321:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 322:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 323:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 324:stk500boot.c  **** 
 325:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 326:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 327:stk500boot.c  **** 	/* ATMega8 with one USART */
 328:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 329:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 330:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 331:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 332:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 333:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 334:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 335:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 336:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 337:stk500boot.c  **** 
 338:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 339:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 340:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 341:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 342:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 343:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 344:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 345:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 346:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 347:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 348:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 349:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 350:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 351:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 352:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 353:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 354:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 355:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 356:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 357:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 358:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 359:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 360:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 361:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 362:stk500boot.c  **** 	//* catch all
 363:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 364:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 365:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 366:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 367:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 368:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 369:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 370:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 371:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 372:stk500boot.c  **** #else
 373:stk500boot.c  **** 	#error "no UART definition for MCU available"
 374:stk500boot.c  **** #endif
 375:stk500boot.c  **** 
 376:stk500boot.c  **** 
 377:stk500boot.c  **** 
 378:stk500boot.c  **** /*
 379:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 380:stk500boot.c  ****  */
 381:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 382:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 383:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 384:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 385:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 386:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 387:stk500boot.c  **** #else
 388:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 389:stk500boot.c  **** #endif
 390:stk500boot.c  **** 
 391:stk500boot.c  **** 
 392:stk500boot.c  **** /*
 393:stk500boot.c  ****  * States used in the receive state machine
 394:stk500boot.c  ****  */
 395:stk500boot.c  **** #define	ST_START		0
 396:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 397:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 398:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 399:stk500boot.c  **** #define ST_GET_TOKEN	4
 400:stk500boot.c  **** #define ST_GET_DATA		5
 401:stk500boot.c  **** #define	ST_GET_CHECK	6
 402:stk500boot.c  **** #define	ST_PROCESS		7
 403:stk500boot.c  **** 
 404:stk500boot.c  **** /*
 405:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 406:stk500boot.c  ****  */
 407:stk500boot.c  **** #if defined(RAMPZ)
 408:stk500boot.c  **** 	typedef uint32_t address_t;
 409:stk500boot.c  **** #else
 410:stk500boot.c  **** 	typedef uint16_t address_t;
 411:stk500boot.c  **** #endif
 412:stk500boot.c  **** 
 413:stk500boot.c  **** /*
 414:stk500boot.c  ****  * function prototypes
 415:stk500boot.c  ****  */
 416:stk500boot.c  **** static void sendchar(char c);
 417:stk500boot.c  **** static unsigned char recchar(void);
 418:stk500boot.c  **** 
 419:stk500boot.c  **** /*
 420:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 421:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 422:stk500boot.c  ****  */
 423:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 424:stk500boot.c  **** #include <avr/sfr_defs.h>
 425:stk500boot.c  **** 
 426:stk500boot.c  **** //#define	SPH_REG	0x3E
 427:stk500boot.c  **** //#define	SPL_REG	0x3D
 428:stk500boot.c  **** 
 429:stk500boot.c  **** //*****************************************************************************
 430:stk500boot.c  **** void __jumpMain(void)
 431:stk500boot.c  **** {
 432:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 433:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 434:stk500boot.c  **** 
 435:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 436:stk500boot.c  **** 
 437:stk500boot.c  **** //*	set stack pointer to top of RAM
 438:stk500boot.c  **** 
 439:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 440:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 441:stk500boot.c  **** 
 442:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 443:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 444:stk500boot.c  **** 
 445:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 446:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 447:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 448:stk500boot.c  **** }
 449:stk500boot.c  **** 
 450:stk500boot.c  **** 
 451:stk500boot.c  **** //*****************************************************************************
 452:stk500boot.c  **** void delay_ms(unsigned int timedelay)
 453:stk500boot.c  **** {
 454:stk500boot.c  **** 	unsigned int i;
 455:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 456:stk500boot.c  **** 	{
 457:stk500boot.c  **** 		_delay_ms(0.5);
 458:stk500boot.c  **** 	}
 459:stk500boot.c  **** }
 460:stk500boot.c  **** 
 461:stk500boot.c  **** 
 462:stk500boot.c  **** //*****************************************************************************
 463:stk500boot.c  **** /*
 464:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 465:stk500boot.c  ****  */
 466:stk500boot.c  **** static void sendchar(char c)
 467:stk500boot.c  **** {
  15               		.loc 1 467 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 468:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
  22               		.loc 1 468 0
  23 0000 8093 C600 		sts 198,r24
  24               	.LVL1:
  25               	.L2:
 469:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  26               		.loc 1 469 0 discriminator 1
  27 0004 8091 C000 		lds r24,192
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L2
 470:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  30               		.loc 1 470 0
  31 000c 8091 C000 		lds r24,192
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C000 		sts 192,r24
  34               	.LVL2:
  35               	/* epilogue start */
 471:stk500boot.c  **** }
  36               		.loc 1 471 0
  37 0016 0895      		ret
  38               		.cfi_endproc
  39               	.LFE13:
  41               		.section	.text.unlikely,"ax",@progbits
  43               	recchar:
  44               	.LFB15:
 472:stk500boot.c  **** 
 473:stk500boot.c  **** 
 474:stk500boot.c  **** //************************************************************************
 475:stk500boot.c  **** static int	Serial_Available(void)
 476:stk500boot.c  **** {
 477:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 478:stk500boot.c  **** }
 479:stk500boot.c  **** 
 480:stk500boot.c  **** 
 481:stk500boot.c  **** //*****************************************************************************
 482:stk500boot.c  **** /*
 483:stk500boot.c  ****  * Read single byte from USART, block if no data available
 484:stk500boot.c  ****  */
 485:stk500boot.c  **** static unsigned char recchar(void)
 486:stk500boot.c  **** {
  45               		.loc 1 486 0
  46               		.cfi_startproc
  47               	/* prologue: function */
  48               	/* frame size = 0 */
  49               	/* stack size = 0 */
  50               	.L__stack_usage = 0
  51               	.L6:
 487:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
  52               		.loc 1 487 0 discriminator 1
  53 0000 8091 C000 		lds r24,192
  54 0004 87FF      		sbrs r24,7
  55 0006 00C0      		rjmp .L6
 488:stk500boot.c  **** 	{
 489:stk500boot.c  **** 		// wait for data
 490:stk500boot.c  **** 	}
 491:stk500boot.c  **** 	return UART_DATA_REG;
  56               		.loc 1 491 0
  57 0008 8091 C600 		lds r24,198
  58               	/* epilogue start */
 492:stk500boot.c  **** }
  59               		.loc 1 492 0
  60 000c 0895      		ret
  61               		.cfi_endproc
  62               	.LFE15:
  64               		.section	.init9,"ax",@progbits
  65               	.global	__jumpMain
  67               	__jumpMain:
  68               	.LFB11:
 431:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
  69               		.loc 1 431 0
  70               		.cfi_startproc
  71               	/* prologue: naked */
  72               	/* frame size = 0 */
  73               	/* stack size = 0 */
  74               	.L__stack_usage = 0
 435:stk500boot.c  **** 
  75               		.loc 1 435 0
  76               	/* #APP */
  77               	 ;  435 "stk500boot.c" 1
  78               		.set __stack, 8703
  79               	 ;  0 "" 2
 439:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  80               		.loc 1 439 0
  81               	 ;  439 "stk500boot.c" 1
  82 0000 01E2      		ldi	16, 33
  83               	 ;  0 "" 2
 440:stk500boot.c  **** 
  84               		.loc 1 440 0
  85               	 ;  440 "stk500boot.c" 1
  86 0002 0EBF      		out 62,16
  87               	 ;  0 "" 2
 442:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  88               		.loc 1 442 0
  89               	 ;  442 "stk500boot.c" 1
  90 0004 0FEF      		ldi	16, 255
  91               	 ;  0 "" 2
 443:stk500boot.c  **** 
  92               		.loc 1 443 0
  93               	 ;  443 "stk500boot.c" 1
  94 0006 0DBF      		out 61,16
  95               	 ;  0 "" 2
 445:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
  96               		.loc 1 445 0
  97               	 ;  445 "stk500boot.c" 1
  98 0008 1124      		clr __zero_reg__
  99               	 ;  0 "" 2
 446:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 100               		.loc 1 446 0
 101               	 ;  446 "stk500boot.c" 1
 102 000a 1FBE      		out 63, __zero_reg__
 103               	 ;  0 "" 2
 447:stk500boot.c  **** }
 104               		.loc 1 447 0
 105               	 ;  447 "stk500boot.c" 1
 106 000c 0C94 0000 		jmp main
 107               	 ;  0 "" 2
 108               	/* epilogue start */
 448:stk500boot.c  **** 
 109               		.loc 1 448 0
 110               	/* #NOAPP */
 111               		.cfi_endproc
 112               	.LFE11:
 114               		.text
 115               	.global	delay_ms
 117               	delay_ms:
 118               	.LFB12:
 453:stk500boot.c  **** 	unsigned int i;
 119               		.loc 1 453 0
 120               		.cfi_startproc
 121               	.LVL3:
 122               	/* prologue: function */
 123               	/* frame size = 0 */
 124               	/* stack size = 0 */
 125               	.L__stack_usage = 0
 455:stk500boot.c  **** 	{
 126               		.loc 1 455 0
 127 0018 30E0      		ldi r19,0
 128 001a 20E0      		ldi r18,0
 129               	.LVL4:
 130               	.L10:
 455:stk500boot.c  **** 	{
 131               		.loc 1 455 0 is_stmt 0 discriminator 1
 132 001c 2817      		cp r18,r24
 133 001e 3907      		cpc r19,r25
 134 0020 01F4      		brne .L11
 135               	/* epilogue start */
 459:stk500boot.c  **** 
 136               		.loc 1 459 0 is_stmt 1
 137 0022 0895      		ret
 138               	.L11:
 139               	.LVL5:
 140               	.LBB77:
 141               	.LBB78:
 142               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 143               		.loc 2 187 0
 144 0024 EFEC      		ldi r30,lo8(1999)
 145 0026 F7E0      		ldi r31,hi8(1999)
 146 0028 3197      	1:	sbiw r30,1
 147 002a 01F4      		brne 1b
 148 002c 00C0      		rjmp .
 149 002e 0000      		nop
 150               	.LVL6:
 151               	.LBE78:
 152               	.LBE77:
 455:stk500boot.c  **** 	{
 153               		.loc 1 455 0
 154 0030 2F5F      		subi r18,-1
 155 0032 3F4F      		sbci r19,-1
 156               	.LVL7:
 157 0034 00C0      		rjmp .L10
 158               		.cfi_endproc
 159               	.LFE12:
 161               	.global	PrintFromPROGMEM
 163               	PrintFromPROGMEM:
 164               	.LFB24:
 493:stk500boot.c  **** 
 494:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 495:stk500boot.c  **** //*****************************************************************************
 496:stk500boot.c  **** static unsigned char recchar_timeout(void)
 497:stk500boot.c  **** {
 498:stk500boot.c  **** uint32_t count = 0;
 499:stk500boot.c  **** 
 500:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 501:stk500boot.c  **** 	{
 502:stk500boot.c  **** 		// wait for data
 503:stk500boot.c  **** 		count++;
 504:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 505:stk500boot.c  **** 		{
 506:stk500boot.c  **** 		unsigned int	data;
 507:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
 508:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 509:stk500boot.c  **** 		#else
 510:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 511:stk500boot.c  **** 		#endif
 512:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 513:stk500boot.c  **** 			{
 514:stk500boot.c  **** 				asm volatile(
 515:stk500boot.c  **** 						"clr	r30		\n\t"
 516:stk500boot.c  **** 						"clr	r31		\n\t"
 517:stk500boot.c  **** 						"ijmp	\n\t"
 518:stk500boot.c  **** 						);
 519:stk500boot.c  **** 			}
 520:stk500boot.c  **** 			count	=	0;
 521:stk500boot.c  **** 		}
 522:stk500boot.c  **** 	}
 523:stk500boot.c  **** 	return UART_DATA_REG;
 524:stk500boot.c  **** }
 525:stk500boot.c  **** 
 526:stk500boot.c  **** //*	for watch dog timer startup
 527:stk500boot.c  **** void (*app_start)(void) = 0x0000;
 528:stk500boot.c  **** 
 529:stk500boot.c  **** 
 530:stk500boot.c  **** #define COREBEEP_DDR   DDRB
 531:stk500boot.c  **** #define COREBEEP_PORT PORTB
 532:stk500boot.c  **** #define COREBEEP_BIT  4      // PB4 = Arduino D10
 533:stk500boot.c  **** 
 534:stk500boot.c  **** // ====== BEEP on Arduino D9 (Mega2560: PH6) ======
 535:stk500boot.c  **** #define BEEP_DDR   DDRH
 536:stk500boot.c  **** #define BEEP_PORT  PORTH
 537:stk500boot.c  **** #define BEEP_PINR  PINH
 538:stk500boot.c  **** #define BEEP_BIT   6      // PH6 = D9
 539:stk500boot.c  **** 
 540:stk500boot.c  **** // 
 541:stk500boot.c  **** #define BEEP_ON()   (BEEP_PORT |=  (1 << BEEP_BIT))
 542:stk500boot.c  **** #define BEEP_OFF()  (BEEP_PORT &= ~(1 << BEEP_BIT))
 543:stk500boot.c  **** 
 544:stk500boot.c  **** 
 545:stk500boot.c  **** #define TURNON  1
 546:stk500boot.c  **** #define TURNOFF 0
 547:stk500boot.c  **** 
 548:stk500boot.c  **** static inline void corebeep_init(void)
 549:stk500boot.c  **** {
 550:stk500boot.c  ****     COREBEEP_DDR |= (1 << COREBEEP_BIT);      // output
 551:stk500boot.c  ****     COREBEEP_PORT &= ~(1 << COREBEEP_BIT);    // default OFF
 552:stk500boot.c  **** }
 553:stk500boot.c  **** 
 554:stk500boot.c  **** static inline void corebeep_on(void)
 555:stk500boot.c  **** {
 556:stk500boot.c  ****     COREBEEP_PORT |= (1 << COREBEEP_BIT);
 557:stk500boot.c  **** }
 558:stk500boot.c  **** 
 559:stk500boot.c  **** static inline void corebeep_off(void)
 560:stk500boot.c  **** {
 561:stk500boot.c  ****     COREBEEP_PORT &= ~(1 << COREBEEP_BIT);
 562:stk500boot.c  **** }
 563:stk500boot.c  **** 
 564:stk500boot.c  **** static inline void beep_init(void)
 565:stk500boot.c  **** {
 566:stk500boot.c  ****     BEEP_DDR  |=  (1 << BEEP_BIT);   // 
 567:stk500boot.c  ****     BEEP_OFF();                      // 
 568:stk500boot.c  **** }
 569:stk500boot.c  **** 
 570:stk500boot.c  **** static inline void beep_on(void)
 571:stk500boot.c  **** {
 572:stk500boot.c  ****     BEEP_ON();
 573:stk500boot.c  **** }
 574:stk500boot.c  **** 
 575:stk500boot.c  **** static inline void beep_off(void)
 576:stk500boot.c  **** {
 577:stk500boot.c  ****     BEEP_OFF();
 578:stk500boot.c  **** }
 579:stk500boot.c  **** 
 580:stk500boot.c  **** 
 581:stk500boot.c  **** //*****************************************************************************
 582:stk500boot.c  **** int main(void)
 583:stk500boot.c  **** {
 584:stk500boot.c  **** 	address_t		address			=	0;
 585:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 586:stk500boot.c  **** 	unsigned char	msgParseState;
 587:stk500boot.c  **** 	unsigned int	ii				=	0;
 588:stk500boot.c  **** 	unsigned char	checksum		=	0;
 589:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 590:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 591:stk500boot.c  **** 	unsigned char	msgBuffer[285];
 592:stk500boot.c  **** 	unsigned char	c, *p;
 593:stk500boot.c  **** 	unsigned char   isLeave = 0;
 594:stk500boot.c  **** 
 595:stk500boot.c  **** 	unsigned long	boot_timeout;
 596:stk500boot.c  **** 	unsigned long	boot_timer;
 597:stk500boot.c  **** 	unsigned int	boot_state;
 598:stk500boot.c  **** #ifdef ENABLE_MONITOR
 599:stk500boot.c  **** 	unsigned int	exPointCntr		=	0;
 600:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 601:stk500boot.c  **** #endif
 602:stk500boot.c  **** 
 603:stk500boot.c  **** 	//*	some chips dont set the stack properly
 604:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 605:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 606:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 607:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 608:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 609:stk500boot.c  **** 
 610:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 611:stk500boot.c  **** 	//************************************************************************
 612:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 613:stk500boot.c  **** 	//*	handle the watch dog timer
 614:stk500boot.c  **** 	uint8_t	mcuStatusReg;
 615:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 616:stk500boot.c  **** 
 617:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 618:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 619:stk500boot.c  **** 	MCUSR	=	0;
 620:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 621:stk500boot.c  **** 	WDTCSR	=	0;
 622:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 623:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 624:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 625:stk500boot.c  **** 	{
 626:stk500boot.c  **** 		app_start();
 627:stk500boot.c  **** 	}
 628:stk500boot.c  **** 	//************************************************************************
 629:stk500boot.c  **** #endif
 630:stk500boot.c  **** 
 631:stk500boot.c  **** 
 632:stk500boot.c  **** 	boot_timer	=	0;
 633:stk500boot.c  **** 	boot_state	=	0;
 634:stk500boot.c  **** 
 635:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 636:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 637:stk500boot.c  **** //	boot_timeout	=	170000;
 638:stk500boot.c  **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 639:stk500boot.c  **** #else
 640:stk500boot.c  **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 641:stk500boot.c  **** #endif
 642:stk500boot.c  **** 	/*
 643:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 644:stk500boot.c  **** 	 */
 645:stk500boot.c  **** 
 646:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 647:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 648:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 649:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 650:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 651:stk500boot.c  **** 
 652:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 653:stk500boot.c  **** 	for (ii=0; ii<3; ii++)
 654:stk500boot.c  **** 	{
 655:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 656:stk500boot.c  **** 		delay_ms(100);
 657:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 658:stk500boot.c  **** 		delay_ms(100);
 659:stk500boot.c  **** 	}
 660:stk500boot.c  **** #endif
 661:stk500boot.c  **** 
 662:stk500boot.c  **** #endif
 663:stk500boot.c  **** 	/*
 664:stk500boot.c  **** 	 * Init UART
 665:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 666:stk500boot.c  **** 	 */
 667:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 668:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 669:stk500boot.c  **** #endif
 670:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 671:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 672:stk500boot.c  **** 
 673:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 674:stk500boot.c  **** 	corebeep_init();
 675:stk500boot.c  **** 	corebeep_off();
 676:stk500boot.c  **** 	beep_init();
 677:stk500boot.c  **** 	beep_off();
 678:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
 679:stk500boot.c  **** //	delay_ms(500);
 680:stk500boot.c  **** 
 681:stk500boot.c  **** 	sendchar('s');
 682:stk500boot.c  **** 	sendchar('t');
 683:stk500boot.c  **** 	sendchar('k');
 684:stk500boot.c  **** //	sendchar('5');
 685:stk500boot.c  **** //	sendchar('0');
 686:stk500boot.c  **** //	sendchar('0');
 687:stk500boot.c  **** 	sendchar('v');
 688:stk500boot.c  **** 	sendchar('2');
 689:stk500boot.c  **** 	sendchar(0x0d);
 690:stk500boot.c  **** 	sendchar(0x0a);
 691:stk500boot.c  **** 
 692:stk500boot.c  **** 	delay_ms(100);
 693:stk500boot.c  **** #endif
 694:stk500boot.c  **** 
 695:stk500boot.c  **** 	while (boot_state==0)
 696:stk500boot.c  **** 	{
 697:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 698:stk500boot.c  **** 		{
 699:stk500boot.c  **** 			_delay_ms(0.001);
 700:stk500boot.c  **** 			boot_timer++;
 701:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 702:stk500boot.c  **** 			{
 703:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 704:stk500boot.c  **** 			}
 705:stk500boot.c  **** 		#ifdef BLINK_LED_WHILE_WAITING
 706:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 707:stk500boot.c  **** 			{
 708:stk500boot.c  **** 				//*	toggle the LED
 709:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 710:stk500boot.c  **** 			}
 711:stk500boot.c  **** 		#endif
 712:stk500boot.c  **** 		}
 713:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 714:stk500boot.c  **** 	}
 715:stk500boot.c  **** 
 716:stk500boot.c  **** 
 717:stk500boot.c  **** 	if (boot_state==1)
 718:stk500boot.c  **** 	{
 719:stk500boot.c  **** 		//*	main loop
 720:stk500boot.c  **** 		while (!isLeave)
 721:stk500boot.c  **** 		{
 722:stk500boot.c  **** 			/*
 723:stk500boot.c  **** 			 * Collect received bytes to a complete message
 724:stk500boot.c  **** 			 */
 725:stk500boot.c  **** 			msgParseState	=	ST_START;
 726:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 727:stk500boot.c  **** 			{
 728:stk500boot.c  **** 				if (boot_state==1)
 729:stk500boot.c  **** 				{
 730:stk500boot.c  **** 					boot_state	=	0;
 731:stk500boot.c  **** 					c			=	UART_DATA_REG;
 732:stk500boot.c  **** 				}
 733:stk500boot.c  **** 				else
 734:stk500boot.c  **** 				{
 735:stk500boot.c  **** 				//	c	=	recchar();
 736:stk500boot.c  **** 					c	=	recchar_timeout();
 737:stk500boot.c  **** 					
 738:stk500boot.c  **** 				}
 739:stk500boot.c  **** 
 740:stk500boot.c  **** 			#ifdef ENABLE_MONITOR
 741:stk500boot.c  **** 				rcvdCharCntr++;
 742:stk500boot.c  **** 
 743:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 744:stk500boot.c  **** 				{
 745:stk500boot.c  **** 					exPointCntr++;
 746:stk500boot.c  **** 					if (exPointCntr == 3)
 747:stk500boot.c  **** 					{
 748:stk500boot.c  **** 						RunMonitor();
 749:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 750:stk500boot.c  **** 						isLeave			=	1;
 751:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 752:stk500boot.c  **** 						break;
 753:stk500boot.c  **** 					}
 754:stk500boot.c  **** 				}
 755:stk500boot.c  **** 				else
 756:stk500boot.c  **** 				{
 757:stk500boot.c  **** 					exPointCntr	=	0;
 758:stk500boot.c  **** 				}
 759:stk500boot.c  **** 			#endif
 760:stk500boot.c  **** 
 761:stk500boot.c  **** 				switch (msgParseState)
 762:stk500boot.c  **** 				{
 763:stk500boot.c  **** 					case ST_START:
 764:stk500boot.c  **** 						if ( c == MESSAGE_START )
 765:stk500boot.c  **** 						{
 766:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 767:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 768:stk500boot.c  **** 						}
 769:stk500boot.c  **** 						break;
 770:stk500boot.c  **** 
 771:stk500boot.c  **** 					case ST_GET_SEQ_NUM:
 772:stk500boot.c  **** 					#ifdef _FIX_ISSUE_505_
 773:stk500boot.c  **** 						seqNum			=	c;
 774:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 775:stk500boot.c  **** 						checksum		^=	c;
 776:stk500boot.c  **** 					#else
 777:stk500boot.c  **** 						if ( (c == 1) || (c == seqNum) )
 778:stk500boot.c  **** 						{
 779:stk500boot.c  **** 							seqNum			=	c;
 780:stk500boot.c  **** 							msgParseState	=	ST_MSG_SIZE_1;
 781:stk500boot.c  **** 							checksum		^=	c;
 782:stk500boot.c  **** 						}
 783:stk500boot.c  **** 						else
 784:stk500boot.c  **** 						{
 785:stk500boot.c  **** 							msgParseState	=	ST_START;
 786:stk500boot.c  **** 						}
 787:stk500boot.c  **** 					#endif
 788:stk500boot.c  **** 						break;
 789:stk500boot.c  **** 
 790:stk500boot.c  **** 					case ST_MSG_SIZE_1:
 791:stk500boot.c  **** 						msgLength		=	c<<8;
 792:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 793:stk500boot.c  **** 						checksum		^=	c;
 794:stk500boot.c  **** 						break;
 795:stk500boot.c  **** 
 796:stk500boot.c  **** 					case ST_MSG_SIZE_2:
 797:stk500boot.c  **** 						msgLength		|=	c;
 798:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 799:stk500boot.c  **** 						checksum		^=	c;
 800:stk500boot.c  **** 						break;
 801:stk500boot.c  **** 
 802:stk500boot.c  **** 					case ST_GET_TOKEN:
 803:stk500boot.c  **** 						if ( c == TOKEN )
 804:stk500boot.c  **** 						{
 805:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 806:stk500boot.c  **** 							checksum		^=	c;
 807:stk500boot.c  **** 							ii				=	0;
 808:stk500boot.c  **** 						}
 809:stk500boot.c  **** 						else
 810:stk500boot.c  **** 						{
 811:stk500boot.c  **** 							msgParseState	=	ST_START;
 812:stk500boot.c  **** 						}
 813:stk500boot.c  **** 						break;
 814:stk500boot.c  **** 
 815:stk500boot.c  **** 					case ST_GET_DATA:
 816:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 817:stk500boot.c  **** 						checksum		^=	c;
 818:stk500boot.c  **** 						if (ii == msgLength )
 819:stk500boot.c  **** 						{
 820:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 821:stk500boot.c  **** 						}
 822:stk500boot.c  **** 						break;
 823:stk500boot.c  **** 
 824:stk500boot.c  **** 					case ST_GET_CHECK:
 825:stk500boot.c  **** 						if ( c == checksum )
 826:stk500boot.c  **** 						{
 827:stk500boot.c  **** 							msgParseState	=	ST_PROCESS;
 828:stk500boot.c  **** 						}
 829:stk500boot.c  **** 						else
 830:stk500boot.c  **** 						{
 831:stk500boot.c  **** 							msgParseState	=	ST_START;
 832:stk500boot.c  **** 						}
 833:stk500boot.c  **** 						break;
 834:stk500boot.c  **** 				}	//	switch
 835:stk500boot.c  **** 			}	//	while(msgParseState)
 836:stk500boot.c  **** 
 837:stk500boot.c  **** 			/*
 838:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 839:stk500boot.c  **** 			 */
 840:stk500boot.c  **** 
 841:stk500boot.c  **** 			switch (msgBuffer[0])
 842:stk500boot.c  **** 			{
 843:stk500boot.c  **** 	#ifndef REMOVE_CMD_SPI_MULTI
 844:stk500boot.c  **** 				case CMD_SPI_MULTI:
 845:stk500boot.c  **** 					{
 846:stk500boot.c  **** 						unsigned char answerByte;
 847:stk500boot.c  **** 						unsigned char flag=0;
 848:stk500boot.c  **** 
 849:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 850:stk500boot.c  **** 						{
 851:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
 852:stk500boot.c  **** 
 853:stk500boot.c  **** 							if ( signatureIndex == 0 )
 854:stk500boot.c  **** 							{
 855:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 856:stk500boot.c  **** 							}
 857:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 858:stk500boot.c  **** 							{
 859:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 860:stk500boot.c  **** 							}
 861:stk500boot.c  **** 							else
 862:stk500boot.c  **** 							{
 863:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 864:stk500boot.c  **** 							}
 865:stk500boot.c  **** 						}
 866:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 867:stk500boot.c  **** 						{
 868:stk500boot.c  **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 869:stk500boot.c  **** 						//*	I cant find the docs that say what these are supposed to be but this was figured out by t
 870:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 871:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 872:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 873:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 874:stk500boot.c  **** 							{
 875:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 876:stk500boot.c  **** 							}
 877:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 878:stk500boot.c  **** 							{
 879:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 880:stk500boot.c  **** 							}
 881:stk500boot.c  **** 							else
 882:stk500boot.c  **** 							{
 883:stk500boot.c  **** 								answerByte	=	0;
 884:stk500boot.c  **** 							}
 885:stk500boot.c  **** 						}
 886:stk500boot.c  **** 						else
 887:stk500boot.c  **** 						{
 888:stk500boot.c  **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
 889:stk500boot.c  **** 						}
 890:stk500boot.c  **** 						if ( !flag )
 891:stk500boot.c  **** 						{
 892:stk500boot.c  **** 							msgLength		=	7;
 893:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 894:stk500boot.c  **** 							msgBuffer[2]	=	0;
 895:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 896:stk500boot.c  **** 							msgBuffer[4]	=	0;
 897:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 898:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 899:stk500boot.c  **** 						}
 900:stk500boot.c  **** 					}
 901:stk500boot.c  **** 					break;
 902:stk500boot.c  **** 	#endif
 903:stk500boot.c  **** 				case CMD_SIGN_ON:
 904:stk500boot.c  **** 					msgLength		=	11;
 905:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 906:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 907:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 908:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 909:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 910:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 911:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 912:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 913:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 914:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 915:stk500boot.c  **** 					break;
 916:stk500boot.c  **** 
 917:stk500boot.c  **** 				case CMD_GET_PARAMETER:
 918:stk500boot.c  **** 					{
 919:stk500boot.c  **** 						unsigned char value;
 920:stk500boot.c  **** 
 921:stk500boot.c  **** 						switch(msgBuffer[1])
 922:stk500boot.c  **** 						{
 923:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_LOW:
 924:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 925:stk500boot.c  **** 							break;
 926:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_HIGH:
 927:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 928:stk500boot.c  **** 							break;
 929:stk500boot.c  **** 						case PARAM_HW_VER:
 930:stk500boot.c  **** 							value	=	CONFIG_PARAM_HW_VER;
 931:stk500boot.c  **** 							break;
 932:stk500boot.c  **** 						case PARAM_SW_MAJOR:
 933:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MAJOR;
 934:stk500boot.c  **** 							break;
 935:stk500boot.c  **** 						case PARAM_SW_MINOR:
 936:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MINOR;
 937:stk500boot.c  **** 							break;
 938:stk500boot.c  **** 						default:
 939:stk500boot.c  **** 							value	=	0;
 940:stk500boot.c  **** 							break;
 941:stk500boot.c  **** 						}
 942:stk500boot.c  **** 						msgLength		=	3;
 943:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 944:stk500boot.c  **** 						msgBuffer[2]	=	value;
 945:stk500boot.c  **** 					}
 946:stk500boot.c  **** 					break;
 947:stk500boot.c  **** 
 948:stk500boot.c  **** 				case CMD_LEAVE_PROGMODE_ISP:
 949:stk500boot.c  **** 					isLeave	=	1;
 950:stk500boot.c  **** 					//*	fall thru
 951:stk500boot.c  **** 
 952:stk500boot.c  **** 				case CMD_SET_PARAMETER:
 953:stk500boot.c  **** 				case CMD_ENTER_PROGMODE_ISP:
 954:stk500boot.c  **** 					msgLength		=	2;
 955:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 956:stk500boot.c  **** 					break;
 957:stk500boot.c  **** 
 958:stk500boot.c  **** 				case CMD_READ_SIGNATURE_ISP:
 959:stk500boot.c  **** 					{
 960:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
 961:stk500boot.c  **** 						unsigned char signature;
 962:stk500boot.c  **** 
 963:stk500boot.c  **** 						if ( signatureIndex == 0 )
 964:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 965:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 966:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 967:stk500boot.c  **** 						else
 968:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 969:stk500boot.c  **** 
 970:stk500boot.c  **** 						msgLength		=	4;
 971:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 972:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 973:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 974:stk500boot.c  **** 					}
 975:stk500boot.c  **** 					break;
 976:stk500boot.c  **** 
 977:stk500boot.c  **** 				case CMD_READ_LOCK_ISP:
 978:stk500boot.c  **** 					msgLength		=	4;
 979:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 980:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 981:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 982:stk500boot.c  **** 					break;
 983:stk500boot.c  **** 
 984:stk500boot.c  **** 				case CMD_READ_FUSE_ISP:
 985:stk500boot.c  **** 					{
 986:stk500boot.c  **** 						unsigned char fuseBits;
 987:stk500boot.c  **** 
 988:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
 989:stk500boot.c  **** 						{
 990:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
 991:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 992:stk500boot.c  **** 							else
 993:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 994:stk500boot.c  **** 						}
 995:stk500boot.c  **** 						else
 996:stk500boot.c  **** 						{
 997:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 998:stk500boot.c  **** 						}
 999:stk500boot.c  **** 						msgLength		=	4;
1000:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1001:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
1002:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
1003:stk500boot.c  **** 					}
1004:stk500boot.c  **** 					break;
1005:stk500boot.c  **** 
1006:stk500boot.c  **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
1007:stk500boot.c  **** 				case CMD_PROGRAM_LOCK_ISP:
1008:stk500boot.c  **** 					{
1009:stk500boot.c  **** 						unsigned char lockBits	=	msgBuffer[4];
1010:stk500boot.c  **** 
1011:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
1012:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
1013:stk500boot.c  **** 						boot_spm_busy_wait();
1014:stk500boot.c  **** 
1015:stk500boot.c  **** 						msgLength		=	3;
1016:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1017:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
1018:stk500boot.c  **** 					}
1019:stk500boot.c  **** 					break;
1020:stk500boot.c  **** 	#endif
1021:stk500boot.c  **** 				case CMD_CHIP_ERASE_ISP:
1022:stk500boot.c  **** 					eraseAddress	=	0;
1023:stk500boot.c  **** 					msgLength		=	2;
1024:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
1025:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
1026:stk500boot.c  **** 					break;
1027:stk500boot.c  **** 
1028:stk500boot.c  **** 				case CMD_LOAD_ADDRESS:
1029:stk500boot.c  **** 	#if defined(RAMPZ)
1030:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
1031:stk500boot.c  **** 	#else
1032:stk500boot.c  **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
1033:stk500boot.c  **** 	#endif
1034:stk500boot.c  **** 					msgLength		=	2;
1035:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
1036:stk500boot.c  **** 					break;
1037:stk500boot.c  **** 
1038:stk500boot.c  **** 				case CMD_PROGRAM_FLASH_ISP:
1039:stk500boot.c  **** 				case CMD_PROGRAM_EEPROM_ISP:
1040:stk500boot.c  **** 					{
1041:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1042:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
1043:stk500boot.c  **** 						unsigned int	data;
1044:stk500boot.c  **** 						unsigned char	highByte, lowByte;
1045:stk500boot.c  **** 						address_t		tempaddress	=	address;
1046:stk500boot.c  **** 
1047:stk500boot.c  **** 
1048:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
1049:stk500boot.c  **** 						{
1050:stk500boot.c  **** 							// erase only main section (bootloader protection)
1051:stk500boot.c  **** 							if (eraseAddress < APP_END )
1052:stk500boot.c  **** 							{
1053:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
1054:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
1055:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
1056:stk500boot.c  **** 							}
1057:stk500boot.c  **** 
1058:stk500boot.c  **** 							/* Write FLASH */
1059:stk500boot.c  **** 							do {
1060:stk500boot.c  **** 								lowByte		=	*p++;
1061:stk500boot.c  **** 								highByte 	=	*p++;
1062:stk500boot.c  **** 
1063:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
1064:stk500boot.c  **** 								boot_page_fill(address,data);
1065:stk500boot.c  **** 
1066:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
1067:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
1068:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1069:stk500boot.c  **** 
1070:stk500boot.c  **** 							boot_page_write(tempaddress);
1071:stk500boot.c  **** 							boot_spm_busy_wait();
1072:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
1073:stk500boot.c  **** 						}
1074:stk500boot.c  **** 						else
1075:stk500boot.c  **** 						{
1076:stk500boot.c  **** 							//*	issue 543, this should work, It has not been tested.
1077:stk500boot.c  **** 							uint16_t ii = address >> 1;
1078:stk500boot.c  **** 							/* write EEPROM */
1079:stk500boot.c  **** 							while (size) {
1080:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
1081:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
1082:stk500boot.c  **** 								ii++;
1083:stk500boot.c  **** 								size--;
1084:stk500boot.c  **** 							}
1085:stk500boot.c  **** 						}
1086:stk500boot.c  **** 						msgLength		=	2;
1087:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1088:stk500boot.c  **** 					}
1089:stk500boot.c  **** 					break;
1090:stk500boot.c  **** 
1091:stk500boot.c  **** 				case CMD_READ_FLASH_ISP:
1092:stk500boot.c  **** 				case CMD_READ_EEPROM_ISP:
1093:stk500boot.c  **** 					{
1094:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1095:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
1096:stk500boot.c  **** 						msgLength				=	size+3;
1097:stk500boot.c  **** 
1098:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1099:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
1100:stk500boot.c  **** 						{
1101:stk500boot.c  **** 							unsigned int data;
1102:stk500boot.c  **** 
1103:stk500boot.c  **** 							// Read FLASH
1104:stk500boot.c  **** 							do {
1105:stk500boot.c  **** 						//#if defined(RAMPZ)
1106:stk500boot.c  **** 						#if (FLASHEND > 0x10000)
1107:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
1108:stk500boot.c  **** 						#else
1109:stk500boot.c  **** 								data	=	pgm_read_word_near(address);
1110:stk500boot.c  **** 						#endif
1111:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
1112:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
1113:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
1114:stk500boot.c  **** 								size	-=	2;
1115:stk500boot.c  **** 							}while (size);
1116:stk500boot.c  **** 						}
1117:stk500boot.c  **** 						else
1118:stk500boot.c  **** 						{
1119:stk500boot.c  **** 							/* Read EEPROM */
1120:stk500boot.c  **** 							do {
1121:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1122:stk500boot.c  **** 								EEARH	=	((address >> 8));
1123:stk500boot.c  **** 								address++;					// Select next EEPROM byte
1124:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
1125:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
1126:stk500boot.c  **** 								size--;
1127:stk500boot.c  **** 							} while (size);
1128:stk500boot.c  **** 						}
1129:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1130:stk500boot.c  **** 					}
1131:stk500boot.c  **** 					break;
1132:stk500boot.c  **** 
1133:stk500boot.c  **** 				default:
1134:stk500boot.c  **** 					msgLength		=	2;
1135:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
1136:stk500boot.c  **** 					break;
1137:stk500boot.c  **** 			}
1138:stk500boot.c  **** 
1139:stk500boot.c  **** 			/*
1140:stk500boot.c  **** 			 * Now send answer message back
1141:stk500boot.c  **** 			 */
1142:stk500boot.c  **** 			sendchar(MESSAGE_START);
1143:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1144:stk500boot.c  **** 
1145:stk500boot.c  **** 			sendchar(seqNum);
1146:stk500boot.c  **** 			checksum	^=	seqNum;
1147:stk500boot.c  **** 
1148:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
1149:stk500boot.c  **** 			sendchar(c);
1150:stk500boot.c  **** 			checksum	^=	c;
1151:stk500boot.c  **** 
1152:stk500boot.c  **** 			c			=	msgLength&0x00FF;
1153:stk500boot.c  **** 			sendchar(c);
1154:stk500boot.c  **** 			checksum ^= c;
1155:stk500boot.c  **** 
1156:stk500boot.c  **** 			sendchar(TOKEN);
1157:stk500boot.c  **** 			checksum ^= TOKEN;
1158:stk500boot.c  **** 
1159:stk500boot.c  **** 			p	=	msgBuffer;
1160:stk500boot.c  **** 			while ( msgLength )
1161:stk500boot.c  **** 			{
1162:stk500boot.c  **** 				c	=	*p++;
1163:stk500boot.c  **** 				sendchar(c);
1164:stk500boot.c  **** 				checksum ^=c;
1165:stk500boot.c  **** 				msgLength--;
1166:stk500boot.c  **** 			}
1167:stk500boot.c  **** 			sendchar(checksum);
1168:stk500boot.c  **** 			seqNum++;
1169:stk500boot.c  **** 	
1170:stk500boot.c  **** 		#ifndef REMOVE_BOOTLOADER_LED
1171:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1172:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
1173:stk500boot.c  **** 		#endif
1174:stk500boot.c  **** 
1175:stk500boot.c  **** 		}
1176:stk500boot.c  **** 	}
1177:stk500boot.c  **** 
1178:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
1179:stk500boot.c  **** 	//*	this is for debugging it can be removed
1180:stk500boot.c  **** 	for (ii=0; ii<10; ii++)
1181:stk500boot.c  **** 	{
1182:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1183:stk500boot.c  **** 		delay_ms(200);
1184:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1185:stk500boot.c  **** 		delay_ms(200);
1186:stk500boot.c  **** 	}
1187:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1188:stk500boot.c  **** #endif
1189:stk500boot.c  **** 
1190:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
1191:stk500boot.c  **** 	sendchar('j');
1192:stk500boot.c  **** //	sendchar('u');
1193:stk500boot.c  **** //	sendchar('m');
1194:stk500boot.c  **** //	sendchar('p');
1195:stk500boot.c  **** //	sendchar(' ');
1196:stk500boot.c  **** //	sendchar('u');
1197:stk500boot.c  **** //	sendchar('s');
1198:stk500boot.c  **** //	sendchar('r');
1199:stk500boot.c  **** 	sendchar(0x0d);
1200:stk500boot.c  **** 	sendchar(0x0a);
1201:stk500boot.c  **** 
1202:stk500boot.c  **** 	delay_ms(100);
1203:stk500boot.c  **** #endif
1204:stk500boot.c  **** 
1205:stk500boot.c  **** 
1206:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1207:stk500boot.c  **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
1208:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
1209:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
1210:stk500boot.c  **** 	delay_ms(100);							// delay after exit
1211:stk500boot.c  **** #endif
1212:stk500boot.c  **** 
1213:stk500boot.c  **** 
1214:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
1215:stk500boot.c  **** 
1216:stk500boot.c  **** 	/*
1217:stk500boot.c  **** 	 * Now leave bootloader
1218:stk500boot.c  **** 	 */
1219:stk500boot.c  **** 
1220:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
1221:stk500boot.c  **** 	boot_rww_enable();				// enable application section
1222:stk500boot.c  **** 
1223:stk500boot.c  **** 
1224:stk500boot.c  **** 	asm volatile(
1225:stk500boot.c  **** 			"clr	r30		\n\t"
1226:stk500boot.c  **** 			"clr	r31		\n\t"
1227:stk500boot.c  **** 			"ijmp	\n\t"
1228:stk500boot.c  **** 			);
1229:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1230:stk500boot.c  **** //					"push r1" "\n\t"
1231:stk500boot.c  **** //					"ret"	 "\n\t"
1232:stk500boot.c  **** //					::);
1233:stk500boot.c  **** 
1234:stk500boot.c  **** 	 /*
1235:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1236:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1237:stk500boot.c  **** 	 * understand this
1238:stk500boot.c  **** 	 */
1239:stk500boot.c  **** 	for(;;);
1240:stk500boot.c  **** }
1241:stk500boot.c  **** 
1242:stk500boot.c  **** /*
1243:stk500boot.c  **** base address = f800
1244:stk500boot.c  **** 
1245:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1246:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1247:stk500boot.c  **** avrdude: safemode: hfuse reads as DA
1248:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1249:stk500boot.c  **** avrdude>
1250:stk500boot.c  **** 
1251:stk500boot.c  **** 
1252:stk500boot.c  **** base address = f000
1253:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1254:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1255:stk500boot.c  **** avrdude: safemode: hfuse reads as D8
1256:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1257:stk500boot.c  **** avrdude>
1258:stk500boot.c  **** */
1259:stk500boot.c  **** 
1260:stk500boot.c  **** //************************************************************************
1261:stk500boot.c  **** #ifdef ENABLE_MONITOR
1262:stk500boot.c  **** #include	<math.h>
1263:stk500boot.c  **** 
1264:stk500boot.c  **** unsigned long	gRamIndex;
1265:stk500boot.c  **** unsigned long	gFlashIndex;
1266:stk500boot.c  **** unsigned long	gEepromIndex;
1267:stk500boot.c  **** 
1268:stk500boot.c  **** 
1269:stk500boot.c  **** #define	true	1
1270:stk500boot.c  **** #define	false	0
1271:stk500boot.c  **** 
1272:stk500boot.c  **** #include	"avr_cpunames.h"
1273:stk500boot.c  **** 
1274:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1275:stk500boot.c  **** 	#error cpu name not defined
1276:stk500boot.c  **** #endif
1277:stk500boot.c  **** 
1278:stk500boot.c  **** #ifdef _VECTORS_SIZE
1279:stk500boot.c  **** 	#define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1280:stk500boot.c  **** #else
1281:stk500boot.c  **** 	#define	kInterruptVectorCount 23
1282:stk500boot.c  **** #endif
1283:stk500boot.c  **** 
1284:stk500boot.c  **** 
1285:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt);
1286:stk500boot.c  **** 
1287:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1288:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	_AVR_CPU_NAME_;
1289:stk500boot.c  **** #else
1290:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	"UNKNOWN";
1291:stk500boot.c  **** #endif
1292:stk500boot.c  **** 
1293:stk500boot.c  **** 	const char	gTextMsg_Explorer[]			PROGMEM	=	"Arduino explorer stk500V2 by MLS";
1294:stk500boot.c  **** 	const char	gTextMsg_Prompt[]			PROGMEM	=	"Bootloader>";
1295:stk500boot.c  **** 	const char	gTextMsg_HUH[]				PROGMEM	=	"Huh?";
1296:stk500boot.c  **** 	const char	gTextMsg_COMPILED_ON[]		PROGMEM	=	"Compiled on = ";
1297:stk500boot.c  **** 	const char	gTextMsg_CPU_Type[]			PROGMEM	=	"CPU Type    = ";
1298:stk500boot.c  **** 	const char	gTextMsg_AVR_ARCH[]			PROGMEM	=	"__AVR_ARCH__= ";
1299:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC[]			PROGMEM	=	"AVR LibC Ver= ";
1300:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION[]		PROGMEM	=	"GCC Version = ";
1301:stk500boot.c  **** 	const char	gTextMsg_CPU_SIGNATURE[]	PROGMEM	=	"CPU ID      = ";
1302:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOW[]	PROGMEM	=	"Low fuse    = ";
1303:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_HIGH[]	PROGMEM	=	"High fuse   = ";
1304:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_EXT[]	PROGMEM	=	"Ext fuse    = ";
1305:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOCK[]	PROGMEM	=	"Lock fuse   = ";
1306:stk500boot.c  **** 	const char	gTextMsg_GCC_DATE_STR[]		PROGMEM	=	__DATE__;
1307:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC_VER_STR[]	PROGMEM	=	__AVR_LIBC_VERSION_STRING__;
1308:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION_STR[]	PROGMEM	=	__VERSION__;
1309:stk500boot.c  **** 	const char	gTextMsg_VECTOR_HEADER[]	PROGMEM	=	"V#   ADDR   op code     instruction addr   Interrup
1310:stk500boot.c  **** 	const char	gTextMsg_noVector[]			PROGMEM	=	"no vector";
1311:stk500boot.c  **** 	const char	gTextMsg_rjmp[]				PROGMEM	=	"rjmp  ";
1312:stk500boot.c  **** 	const char	gTextMsg_jmp[]				PROGMEM	=	"jmp ";
1313:stk500boot.c  **** 	const char	gTextMsg_WHAT_PORT[]		PROGMEM	=	"What port:";
1314:stk500boot.c  **** 	const char	gTextMsg_PortNotSupported[]	PROGMEM	=	"Port not supported";
1315:stk500boot.c  **** 	const char	gTextMsg_MustBeLetter[]		PROGMEM	=	"Must be a letter";
1316:stk500boot.c  **** 	const char	gTextMsg_SPACE[]			PROGMEM	=	" ";
1317:stk500boot.c  **** 	const char	gTextMsg_WriteToEEprom[]	PROGMEM	=	"Writting EE";
1318:stk500boot.c  **** 	const char	gTextMsg_ReadingEEprom[]	PROGMEM	=	"Reading EE";
1319:stk500boot.c  **** 	const char	gTextMsg_EEPROMerrorCnt[]	PROGMEM	=	"EE err cnt=";
1320:stk500boot.c  **** 	const char	gTextMsg_PORT[]				PROGMEM	=	"PORT";
1321:stk500boot.c  **** 
1322:stk500boot.c  **** 
1323:stk500boot.c  **** //************************************************************************
1324:stk500boot.c  **** //*	Help messages
1325:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_0[]		PROGMEM	=	"0=Zero addr";
1326:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_QM[]		PROGMEM	=	"?=CPU stats";
1327:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_AT[]		PROGMEM	=	"@=EEPROM test";
1328:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_B[]		PROGMEM	=	"B=Blink LED";
1329:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_E[]		PROGMEM	=	"E=Dump EEPROM";
1330:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_F[]		PROGMEM	=	"F=Dump FLASH";
1331:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_H[]		PROGMEM	=	"H=Help";
1332:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_L[]		PROGMEM	=	"L=List I/O Ports";
1333:stk500boot.c  **** //	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit & jump to user pgm";
1334:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit";
1335:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_R[]		PROGMEM	=	"R=Dump RAM";
1336:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_V[]		PROGMEM	=	"V=show interrupt Vectors";
1337:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Y[]		PROGMEM	=	"Y=Port blink";
1338:stk500boot.c  **** 
1339:stk500boot.c  **** 	const char	gTextMsg_END[]				PROGMEM	=	"*";
1340:stk500boot.c  **** 
1341:stk500boot.c  **** 
1342:stk500boot.c  **** //************************************************************************
1343:stk500boot.c  **** void	PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1344:stk500boot.c  **** {
 165               		.loc 1 1344 0
 166               		.cfi_startproc
 167               	.LVL8:
 168 0036 CF93      		push r28
 169               	.LCFI0:
 170               		.cfi_def_cfa_offset 4
 171               		.cfi_offset 28, -3
 172 0038 DF93      		push r29
 173               	.LCFI1:
 174               		.cfi_def_cfa_offset 5
 175               		.cfi_offset 29, -4
 176               	/* prologue: function */
 177               	/* frame size = 0 */
 178               	/* stack size = 2 */
 179               	.L__stack_usage = 2
1345:stk500boot.c  **** char	theChar;
1346:stk500boot.c  **** 
1347:stk500boot.c  **** 	dataPtr		+=	offset;
 180               		.loc 1 1347 0
 181 003a EC01      		movw r28,r24
 182 003c C60F      		add r28,r22
 183 003e D11D      		adc r29,__zero_reg__
 184               	.LVL9:
 185               	.L14:
 186               	.LBB79:
1348:stk500boot.c  **** 
1349:stk500boot.c  **** 	do {
1350:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1351:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint16_t)dataPtr++);
 187               		.loc 1 1351 0
 188 0040 CE01      		movw r24,r28
 189 0042 B0E0      		ldi r27,0
 190 0044 A0E0      		ldi r26,0
 191               	/* #APP */
 192               	 ;  1351 "stk500boot.c" 1
 193 0046 ABBF      		out 59, r26
 194 0048 FC01      		movw r30, r24
 195 004a 8791      		elpm r24, Z+
 196               		
 197               	 ;  0 "" 2
 198               	.LVL10:
 199               	/* #NOAPP */
 200               	.LBE79:
1352:stk500boot.c  **** 	#else
1353:stk500boot.c  **** 		theChar	=	pgm_read_byte_near((uint16_t)dataPtr++);
1354:stk500boot.c  **** 	#endif
1355:stk500boot.c  **** 		if (theChar != 0)
 201               		.loc 1 1355 0
 202 004c 8823      		tst r24
 203 004e 01F0      		breq .L12
 204               	.LBB80:
1351:stk500boot.c  **** 	#else
 205               		.loc 1 1351 0
 206 0050 2196      		adiw r28,1
 207               	.LVL11:
 208               	.LBE80:
1356:stk500boot.c  **** 		{
1357:stk500boot.c  **** 			sendchar(theChar);
 209               		.loc 1 1357 0
 210 0052 0E94 0000 		call sendchar
 211               	.LVL12:
 212 0056 00C0      		rjmp .L14
 213               	.LVL13:
 214               	.L12:
 215               	/* epilogue start */
1358:stk500boot.c  **** 		}
1359:stk500boot.c  **** 	} while (theChar != 0);
1360:stk500boot.c  **** }
 216               		.loc 1 1360 0
 217 0058 DF91      		pop r29
 218 005a CF91      		pop r28
 219               	.LVL14:
 220 005c 0895      		ret
 221               		.cfi_endproc
 222               	.LFE24:
 224               	.global	PrintNewLine
 226               	PrintNewLine:
 227               	.LFB25:
1361:stk500boot.c  **** 
1362:stk500boot.c  **** //************************************************************************
1363:stk500boot.c  **** void	PrintNewLine(void)
1364:stk500boot.c  **** {
 228               		.loc 1 1364 0
 229               		.cfi_startproc
 230               	/* prologue: function */
 231               	/* frame size = 0 */
 232               	/* stack size = 0 */
 233               	.L__stack_usage = 0
1365:stk500boot.c  **** 	sendchar(0x0d);
 234               		.loc 1 1365 0
 235 005e 8DE0      		ldi r24,lo8(13)
 236 0060 0E94 0000 		call sendchar
 237               	.LVL15:
1366:stk500boot.c  **** 	sendchar(0x0a);
 238               		.loc 1 1366 0
 239 0064 8AE0      		ldi r24,lo8(10)
 240 0066 0C94 0000 		jmp sendchar
 241               	.LVL16:
 242               		.cfi_endproc
 243               	.LFE25:
 245               		.section	.text.unlikely
 247               	PrintAvailablePort:
 248               	.LFB35:
1367:stk500boot.c  **** }
1368:stk500boot.c  **** 
1369:stk500boot.c  **** 
1370:stk500boot.c  **** //************************************************************************
1371:stk500boot.c  **** void	PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1372:stk500boot.c  **** {
1373:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
1374:stk500boot.c  **** 
1375:stk500boot.c  **** 	PrintNewLine();
1376:stk500boot.c  **** }
1377:stk500boot.c  **** 
1378:stk500boot.c  **** 
1379:stk500boot.c  **** //************************************************************************
1380:stk500boot.c  **** void	PrintString(char *textString)
1381:stk500boot.c  **** {
1382:stk500boot.c  **** char	theChar;
1383:stk500boot.c  **** int		ii;
1384:stk500boot.c  **** 
1385:stk500boot.c  **** 	theChar		=	1;
1386:stk500boot.c  **** 	ii			=	0;
1387:stk500boot.c  **** 	while (theChar != 0)
1388:stk500boot.c  **** 	{
1389:stk500boot.c  **** 		theChar	=	textString[ii];
1390:stk500boot.c  **** 		if (theChar != 0)
1391:stk500boot.c  **** 		{
1392:stk500boot.c  **** 			sendchar(theChar);
1393:stk500boot.c  **** 		}
1394:stk500boot.c  **** 		ii++;
1395:stk500boot.c  **** 	}
1396:stk500boot.c  **** }
1397:stk500boot.c  **** 
1398:stk500boot.c  **** //************************************************************************
1399:stk500boot.c  **** void	PrintHexByte(unsigned char theByte)
1400:stk500boot.c  **** {
1401:stk500boot.c  **** char	theChar;
1402:stk500boot.c  **** 
1403:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
1404:stk500boot.c  **** 	if (theChar > 0x39)
1405:stk500boot.c  **** 	{
1406:stk500boot.c  **** 		theChar	+=	7;
1407:stk500boot.c  **** 	}
1408:stk500boot.c  **** 	sendchar(theChar );
1409:stk500boot.c  **** 
1410:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
1411:stk500boot.c  **** 	if (theChar > 0x39)
1412:stk500boot.c  **** 	{
1413:stk500boot.c  **** 		theChar	+=	7;
1414:stk500boot.c  **** 	}
1415:stk500boot.c  **** 	sendchar(theChar );
1416:stk500boot.c  **** }
1417:stk500boot.c  **** 
1418:stk500boot.c  **** //************************************************************************
1419:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt)
1420:stk500boot.c  **** {
1421:stk500boot.c  **** int	theChar;
1422:stk500boot.c  **** int	myNumber;
1423:stk500boot.c  **** 
1424:stk500boot.c  **** 	myNumber	=	theNumber;
1425:stk500boot.c  **** 
1426:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
1427:stk500boot.c  **** 	{
1428:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
1429:stk500boot.c  **** 		sendchar(theChar );
1430:stk500boot.c  **** 	}
1431:stk500boot.c  **** 
1432:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
1433:stk500boot.c  **** 	{
1434:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
1435:stk500boot.c  **** 		sendchar(theChar );
1436:stk500boot.c  **** 	}
1437:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
1438:stk500boot.c  **** 	sendchar(theChar );
1439:stk500boot.c  **** }
1440:stk500boot.c  **** 
1441:stk500boot.c  **** 
1442:stk500boot.c  **** 
1443:stk500boot.c  **** 
1444:stk500boot.c  **** //************************************************************************
1445:stk500boot.c  **** static void	PrintCPUstats(void)
1446:stk500boot.c  **** {
1447:stk500boot.c  **** unsigned char fuseByte;
1448:stk500boot.c  **** 
1449:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
1450:stk500boot.c  **** 
1451:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);
1452:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
1453:stk500boot.c  **** 
1454:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_Type, 0);
1455:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1456:stk500boot.c  **** 
1457:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);
1458:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
1459:stk500boot.c  **** 	PrintNewLine();
1460:stk500boot.c  **** 
1461:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);
1462:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
1463:stk500boot.c  **** 
1464:stk500boot.c  **** 	//*	these can be found in avr/version.h
1465:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);
1466:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
1467:stk500boot.c  **** 
1468:stk500boot.c  **** #if defined(SIGNATURE_0)
1469:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);
1470:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
1471:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
1472:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
1473:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
1474:stk500boot.c  **** 	PrintNewLine();
1475:stk500boot.c  **** #endif
1476:stk500boot.c  **** 
1477:stk500boot.c  **** 
1478:stk500boot.c  **** #if defined(GET_LOW_FUSE_BITS)
1479:stk500boot.c  **** 	//*	fuse settings
1480:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);
1481:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1482:stk500boot.c  **** 	PrintHexByte(fuseByte);
1483:stk500boot.c  **** 	PrintNewLine();
1484:stk500boot.c  **** 
1485:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);
1486:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1487:stk500boot.c  **** 	PrintHexByte(fuseByte);
1488:stk500boot.c  **** 	PrintNewLine();
1489:stk500boot.c  **** 
1490:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);
1491:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
1492:stk500boot.c  **** 	PrintHexByte(fuseByte);
1493:stk500boot.c  **** 	PrintNewLine();
1494:stk500boot.c  **** 
1495:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);
1496:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
1497:stk500boot.c  **** 	PrintHexByte(fuseByte);
1498:stk500boot.c  **** 	PrintNewLine();
1499:stk500boot.c  **** 
1500:stk500boot.c  **** #endif
1501:stk500boot.c  **** 
1502:stk500boot.c  **** }
1503:stk500boot.c  **** 
1504:stk500boot.c  **** 
1505:stk500boot.c  **** //************************************************************************
1506:stk500boot.c  **** static void BlinkLED(void)
1507:stk500boot.c  **** {
1508:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
1509:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
1510:stk500boot.c  **** 
1511:stk500boot.c  **** 	while (!Serial_Available())
1512:stk500boot.c  **** 	{
1513:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1514:stk500boot.c  **** 		delay_ms(100);
1515:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1516:stk500boot.c  **** 		delay_ms(100);
1517:stk500boot.c  **** 	}
1518:stk500boot.c  **** 	recchar();	//	get the char out of the buffer
1519:stk500boot.c  **** }
1520:stk500boot.c  **** 
1521:stk500boot.c  **** enum
1522:stk500boot.c  **** {
1523:stk500boot.c  **** 	kDUMP_FLASH	=	0,
1524:stk500boot.c  **** 	kDUMP_EEPROM,
1525:stk500boot.c  **** 	kDUMP_RAM
1526:stk500boot.c  **** };
1527:stk500boot.c  **** 
1528:stk500boot.c  **** //************************************************************************
1529:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
1530:stk500boot.c  **** {
1531:stk500boot.c  **** unsigned long	myAddressPointer;
1532:stk500boot.c  **** uint8_t			ii;
1533:stk500boot.c  **** unsigned char	theValue;
1534:stk500boot.c  **** char			asciiDump[18];
1535:stk500boot.c  **** unsigned char	*ramPtr;
1536:stk500boot.c  **** 
1537:stk500boot.c  **** 
1538:stk500boot.c  **** 	ramPtr				=	0;
1539:stk500boot.c  **** 	theValue			=	0;
1540:stk500boot.c  **** 	myAddressPointer	=	startAddress;
1541:stk500boot.c  **** 	while (numRows > 0)
1542:stk500boot.c  **** 	{
1543:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
1544:stk500boot.c  **** 		{
1545:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
1546:stk500boot.c  **** 		}
1547:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
1548:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
1549:stk500boot.c  **** 		sendchar(0x20);
1550:stk500boot.c  **** 		sendchar('-');
1551:stk500boot.c  **** 		sendchar(0x20);
1552:stk500boot.c  **** 
1553:stk500boot.c  **** 		asciiDump[0]		=	0;
1554:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
1555:stk500boot.c  **** 		{
1556:stk500boot.c  **** 			switch(dumpWhat)
1557:stk500boot.c  **** 			{
1558:stk500boot.c  **** 				case kDUMP_FLASH:
1559:stk500boot.c  **** 				#if (FLASHEND > 0x10000)
1560:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
1561:stk500boot.c  **** 				#else
1562:stk500boot.c  **** 					theValue	=	pgm_read_byte_near(myAddressPointer);
1563:stk500boot.c  **** 				#endif
1564:stk500boot.c  **** 					break;
1565:stk500boot.c  **** 
1566:stk500boot.c  **** 				case kDUMP_EEPROM:
1567:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
1568:stk500boot.c  **** 					break;
1569:stk500boot.c  **** 
1570:stk500boot.c  **** 				case kDUMP_RAM:
1571:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
1572:stk500boot.c  **** 					break;
1573:stk500boot.c  **** 
1574:stk500boot.c  **** 			}
1575:stk500boot.c  **** 			PrintHexByte(theValue);
1576:stk500boot.c  **** 			sendchar(0x20);
1577:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
1578:stk500boot.c  **** 			{
1579:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
1580:stk500boot.c  **** 			}
1581:stk500boot.c  **** 			else
1582:stk500boot.c  **** 			{
1583:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
1584:stk500boot.c  **** 			}
1585:stk500boot.c  **** 
1586:stk500boot.c  **** 			myAddressPointer++;
1587:stk500boot.c  **** 		}
1588:stk500boot.c  **** 		asciiDump[16]	=	0;
1589:stk500boot.c  **** 		PrintString(asciiDump);
1590:stk500boot.c  **** 		PrintNewLine();
1591:stk500boot.c  **** 
1592:stk500boot.c  **** 		numRows--;
1593:stk500boot.c  **** 	}
1594:stk500boot.c  **** }
1595:stk500boot.c  **** 
1596:stk500boot.c  **** 
1597:stk500boot.c  **** 
1598:stk500boot.c  **** //************************************************************************
1599:stk500boot.c  **** //*	returns amount of extended memory
1600:stk500boot.c  **** static void	EEPROMtest(void)
1601:stk500boot.c  **** {
1602:stk500boot.c  **** int		ii;
1603:stk500boot.c  **** char	theChar;
1604:stk500boot.c  **** char	theEEPROMchar;
1605:stk500boot.c  **** int		errorCount;
1606:stk500boot.c  **** 
1607:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);
1608:stk500boot.c  **** 	PrintNewLine();
1609:stk500boot.c  **** 	ii			=	0;
1610:stk500boot.c  **** #if (FLASHEND > 0x10000)
1611:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1612:stk500boot.c  **** #else
1613:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1614:stk500boot.c  **** #endif
1615:stk500boot.c  **** 	{
1616:stk500boot.c  **** 		eeprom_write_byte((uint8_t *)ii, theChar);
1617:stk500boot.c  **** 		if (theChar == 0)
1618:stk500boot.c  **** 		{
1619:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1620:stk500boot.c  **** 		}
1621:stk500boot.c  **** 		else
1622:stk500boot.c  **** 		{
1623:stk500boot.c  **** 			sendchar(theChar);
1624:stk500boot.c  **** 		}
1625:stk500boot.c  **** 		ii++;
1626:stk500boot.c  **** 	}
1627:stk500boot.c  **** 
1628:stk500boot.c  **** 	//*	no go back through and test
1629:stk500boot.c  **** 	PrintNewLine();
1630:stk500boot.c  **** 	PrintNewLine();
1631:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
1632:stk500boot.c  **** 	PrintNewLine();
1633:stk500boot.c  **** 	errorCount	=	0;
1634:stk500boot.c  **** 	ii			=	0;
1635:stk500boot.c  **** #if (FLASHEND > 0x10000)
1636:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1637:stk500boot.c  **** #else
1638:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1639:stk500boot.c  **** #endif
1640:stk500boot.c  **** 	{
1641:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((uint8_t *)ii);
1642:stk500boot.c  **** 		if (theEEPROMchar == 0)
1643:stk500boot.c  **** 		{
1644:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1645:stk500boot.c  **** 		}
1646:stk500boot.c  **** 		else
1647:stk500boot.c  **** 		{
1648:stk500boot.c  **** 			sendchar(theEEPROMchar);
1649:stk500boot.c  **** 		}
1650:stk500boot.c  **** 		if (theEEPROMchar != theChar)
1651:stk500boot.c  **** 		{
1652:stk500boot.c  **** 			errorCount++;
1653:stk500boot.c  **** 		}
1654:stk500boot.c  **** 		ii++;
1655:stk500boot.c  **** 	}
1656:stk500boot.c  **** 	PrintNewLine();
1657:stk500boot.c  **** 	PrintNewLine();
1658:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
1659:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
1660:stk500boot.c  **** 	PrintNewLine();
1661:stk500boot.c  **** 	PrintNewLine();
1662:stk500boot.c  **** 
1663:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
1664:stk500boot.c  **** 
1665:stk500boot.c  **** }
1666:stk500boot.c  **** 
1667:stk500boot.c  **** 
1668:stk500boot.c  **** 
1669:stk500boot.c  **** #if (FLASHEND > 0x08000)
1670:stk500boot.c  **** //*	this includes the interrupt names for the monitor portion. There is no longer enough 
1671:stk500boot.c  **** //*	memory to include this
1672:stk500boot.c  **** //	#include	"avrinterruptnames.h"
1673:stk500boot.c  **** //	#ifndef _INTERRUPT_NAMES_DEFINED_
1674:stk500boot.c  **** //		#warning Interrupt vectors not defined
1675:stk500boot.c  **** //	#endif
1676:stk500boot.c  **** #endif
1677:stk500boot.c  **** 
1678:stk500boot.c  **** //************************************************************************
1679:stk500boot.c  **** static void	VectorDisplay(void)
1680:stk500boot.c  **** {
1681:stk500boot.c  **** unsigned long	byte1;
1682:stk500boot.c  **** unsigned long	byte2;
1683:stk500boot.c  **** unsigned long	byte3;
1684:stk500boot.c  **** unsigned long	byte4;
1685:stk500boot.c  **** unsigned long	word1;
1686:stk500boot.c  **** unsigned long	word2;
1687:stk500boot.c  **** int				vectorIndex;
1688:stk500boot.c  **** unsigned long	myMemoryPtr;
1689:stk500boot.c  **** unsigned long	wordMemoryAddress;
1690:stk500boot.c  **** unsigned long	realitiveAddr;
1691:stk500boot.c  **** unsigned long	myFullAddress;
1692:stk500boot.c  **** unsigned long	absoluteAddr;
1693:stk500boot.c  **** #if defined(_INTERRUPT_NAMES_DEFINED_)
1694:stk500boot.c  **** 	long		stringPointer;
1695:stk500boot.c  **** #endif
1696:stk500boot.c  **** 
1697:stk500boot.c  **** 	myMemoryPtr		=	0;
1698:stk500boot.c  **** 	vectorIndex		=	0;
1699:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1700:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
1701:stk500boot.c  **** 	//					 V#   ADDR   op code
1702:stk500boot.c  **** 	//					  1 - 0000 = C3 BB 00 00 rjmp 03BB >000776 RESET
1703:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
1704:stk500boot.c  **** 	{
1705:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
1706:stk500boot.c  **** 		//					 01 - 0000 = 12 34
1707:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
1708:stk500boot.c  **** 		sendchar(0x20);
1709:stk500boot.c  **** 		sendchar('-');
1710:stk500boot.c  **** 		sendchar(0x20);
1711:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
1712:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
1713:stk500boot.c  **** 		sendchar(0x20);
1714:stk500boot.c  **** 		sendchar('=');
1715:stk500boot.c  **** 		sendchar(0x20);
1716:stk500boot.c  **** 
1717:stk500boot.c  **** 	
1718:stk500boot.c  **** 		//*	the AVR is LITTLE ENDIAN, swap the byte order
1719:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1720:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
1721:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
1722:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
1723:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
1724:stk500boot.c  **** 	#else
1725:stk500boot.c  **** 		byte1	=	pgm_read_byte_near(myMemoryPtr++);
1726:stk500boot.c  **** 		byte2	=	pgm_read_byte_near(myMemoryPtr++);
1727:stk500boot.c  **** 		byte3	=	pgm_read_byte_near(myMemoryPtr++);
1728:stk500boot.c  **** 		byte4	=	pgm_read_byte_near(myMemoryPtr++);
1729:stk500boot.c  **** 	#endif
1730:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
1731:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
1732:stk500boot.c  **** 
1733:stk500boot.c  **** 
1734:stk500boot.c  **** 		PrintHexByte(byte2);
1735:stk500boot.c  **** 		sendchar(0x20);
1736:stk500boot.c  **** 		PrintHexByte(byte1);
1737:stk500boot.c  **** 		sendchar(0x20);
1738:stk500boot.c  **** 		PrintHexByte(byte4);
1739:stk500boot.c  **** 		sendchar(0x20);
1740:stk500boot.c  **** 		PrintHexByte(byte3);
1741:stk500boot.c  **** 		sendchar(0x20);
1742:stk500boot.c  **** 	
1743:stk500boot.c  **** 		if (word1 == 0xffff)
1744:stk500boot.c  **** 		{
1745:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_noVector, 0);
1746:stk500boot.c  **** 		}
1747:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
1748:stk500boot.c  **** 		{
1749:stk500boot.c  **** 			//*	rjmp instruction
1750:stk500boot.c  **** 			realitiveAddr	=	word1 & 0x3FFF;
1751:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
1752:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
1753:stk500boot.c  **** 
1754:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_rjmp, 0);
1755:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
1756:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
1757:stk500boot.c  **** 			sendchar(0x20);
1758:stk500boot.c  **** 			sendchar('>');
1759:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1760:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1761:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1762:stk500boot.c  **** 	
1763:stk500boot.c  **** 		}
1764:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
1765:stk500boot.c  **** 		{
1766:stk500boot.c  **** 			//*	jmp instruction, this is REALLY complicated, refer to the instruction manual (JMP)
1767:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
1768:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
1769:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
1770:stk500boot.c  **** 								word2;
1771:stk500boot.c  **** 							
1772:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
1773:stk500boot.c  **** 							
1774:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_jmp, 0);
1775:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
1776:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
1777:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
1778:stk500boot.c  **** 			sendchar(0x20);
1779:stk500boot.c  **** 			sendchar('>');
1780:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1781:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1782:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1783:stk500boot.c  **** 		}
1784:stk500boot.c  **** 
1785:stk500boot.c  **** 	#if defined(_INTERRUPT_NAMES_DEFINED_)
1786:stk500boot.c  **** 		sendchar(0x20);
1787:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1788:stk500boot.c  **** 		stringPointer	=	pgm_read_word_far(&(gInterruptNameTable[vectorIndex]));
1789:stk500boot.c  **** 	#else
1790:stk500boot.c  **** 		stringPointer	=	pgm_read_word_near(&(gInterruptNameTable[vectorIndex]));
1791:stk500boot.c  **** 	#endif
1792:stk500boot.c  **** 		PrintFromPROGMEM((char *)stringPointer, 0);
1793:stk500boot.c  **** 	#endif
1794:stk500boot.c  **** 		PrintNewLine();
1795:stk500boot.c  **** 
1796:stk500boot.c  **** 		vectorIndex++;
1797:stk500boot.c  **** 	}
1798:stk500boot.c  **** }
1799:stk500boot.c  **** 
1800:stk500boot.c  **** //************************************************************************
1801:stk500boot.c  **** static void	PrintAvailablePort(char thePortLetter)
1802:stk500boot.c  **** {
 249               		.loc 1 1802 0
 250               		.cfi_startproc
 251               	.LVL17:
 252 000e CF93      		push r28
 253               	.LCFI2:
 254               		.cfi_def_cfa_offset 4
 255               		.cfi_offset 28, -3
 256               	/* prologue: function */
 257               	/* frame size = 0 */
 258               	/* stack size = 1 */
 259               	.L__stack_usage = 1
 260 0010 C82F      		mov r28,r24
1803:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_PORT, 0);
 261               		.loc 1 1803 0
 262 0012 60E0      		ldi r22,0
 263 0014 80E0      		ldi r24,lo8(gTextMsg_PORT)
 264 0016 90E0      		ldi r25,hi8(gTextMsg_PORT)
 265               	.LVL18:
 266 0018 0E94 0000 		call PrintFromPROGMEM
 267               	.LVL19:
1804:stk500boot.c  **** 	sendchar(thePortLetter);
 268               		.loc 1 1804 0
 269 001c 8C2F      		mov r24,r28
 270 001e 0E94 0000 		call sendchar
 271               	.LVL20:
 272               	/* epilogue start */
1805:stk500boot.c  **** 	PrintNewLine();
1806:stk500boot.c  **** }
 273               		.loc 1 1806 0
 274 0022 CF91      		pop r28
 275               	.LVL21:
1805:stk500boot.c  **** 	PrintNewLine();
 276               		.loc 1 1805 0
 277 0024 0C94 0000 		jmp PrintNewLine
 278               	.LVL22:
 279               		.cfi_endproc
 280               	.LFE35:
 282               		.text
 283               	.global	PrintFromPROGMEMln
 285               	PrintFromPROGMEMln:
 286               	.LFB26:
1372:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 287               		.loc 1 1372 0
 288               		.cfi_startproc
 289               	.LVL23:
 290               	/* prologue: function */
 291               	/* frame size = 0 */
 292               	/* stack size = 0 */
 293               	.L__stack_usage = 0
1373:stk500boot.c  **** 
 294               		.loc 1 1373 0
 295 006a 0E94 0000 		call PrintFromPROGMEM
 296               	.LVL24:
1375:stk500boot.c  **** }
 297               		.loc 1 1375 0
 298 006e 0C94 0000 		jmp PrintNewLine
 299               	.LVL25:
 300               		.cfi_endproc
 301               	.LFE26:
 303               	.global	PrintString
 305               	PrintString:
 306               	.LFB27:
1381:stk500boot.c  **** char	theChar;
 307               		.loc 1 1381 0
 308               		.cfi_startproc
 309               	.LVL26:
 310 0072 CF93      		push r28
 311               	.LCFI3:
 312               		.cfi_def_cfa_offset 4
 313               		.cfi_offset 28, -3
 314 0074 DF93      		push r29
 315               	.LCFI4:
 316               		.cfi_def_cfa_offset 5
 317               		.cfi_offset 29, -4
 318               	/* prologue: function */
 319               	/* frame size = 0 */
 320               	/* stack size = 2 */
 321               	.L__stack_usage = 2
 322 0076 EC01      		movw r28,r24
 323               	.LVL27:
 324               	.L20:
1389:stk500boot.c  **** 		if (theChar != 0)
 325               		.loc 1 1389 0
 326 0078 8991      		ld r24,Y+
 327               	.LVL28:
1390:stk500boot.c  **** 		{
 328               		.loc 1 1390 0
 329 007a 8823      		tst r24
 330 007c 01F0      		breq .L18
1392:stk500boot.c  **** 		}
 331               		.loc 1 1392 0
 332 007e 0E94 0000 		call sendchar
 333               	.LVL29:
 334 0082 00C0      		rjmp .L20
 335               	.LVL30:
 336               	.L18:
 337               	/* epilogue start */
1396:stk500boot.c  **** 
 338               		.loc 1 1396 0
 339 0084 DF91      		pop r29
 340 0086 CF91      		pop r28
 341               	.LVL31:
 342 0088 0895      		ret
 343               		.cfi_endproc
 344               	.LFE27:
 346               	.global	PrintHexByte
 348               	PrintHexByte:
 349               	.LFB28:
1400:stk500boot.c  **** char	theChar;
 350               		.loc 1 1400 0
 351               		.cfi_startproc
 352               	.LVL32:
 353 008a CF93      		push r28
 354               	.LCFI5:
 355               		.cfi_def_cfa_offset 4
 356               		.cfi_offset 28, -3
 357               	/* prologue: function */
 358               	/* frame size = 0 */
 359               	/* stack size = 1 */
 360               	.L__stack_usage = 1
 361 008c C82F      		mov r28,r24
1403:stk500boot.c  **** 	if (theChar > 0x39)
 362               		.loc 1 1403 0
 363 008e 982F      		mov r25,r24
 364 0090 9295      		swap r25
 365 0092 9F70      		andi r25,lo8(15)
 366 0094 80E3      		ldi r24,lo8(48)
 367               	.LVL33:
 368 0096 890F      		add r24,r25
 369               	.LVL34:
1404:stk500boot.c  **** 	{
 370               		.loc 1 1404 0
 371 0098 8A33      		cpi r24,lo8(58)
 372 009a 00F0      		brlo .L22
1406:stk500boot.c  **** 	}
 373               		.loc 1 1406 0
 374 009c 87E3      		ldi r24,lo8(55)
 375               	.LVL35:
 376 009e 890F      		add r24,r25
 377               	.LVL36:
 378               	.L22:
1408:stk500boot.c  **** 
 379               		.loc 1 1408 0
 380 00a0 0E94 0000 		call sendchar
 381               	.LVL37:
1410:stk500boot.c  **** 	if (theChar > 0x39)
 382               		.loc 1 1410 0
 383 00a4 CF70      		andi r28,lo8(15)
 384               	.LVL38:
 385 00a6 80E3      		ldi r24,lo8(48)
 386 00a8 8C0F      		add r24,r28
 387               	.LVL39:
1411:stk500boot.c  **** 	{
 388               		.loc 1 1411 0
 389 00aa 8A33      		cpi r24,lo8(58)
 390 00ac 00F0      		brlo .L23
1413:stk500boot.c  **** 	}
 391               		.loc 1 1413 0
 392 00ae 87E3      		ldi r24,lo8(55)
 393               	.LVL40:
 394 00b0 8C0F      		add r24,r28
 395               	.LVL41:
 396               	.L23:
 397               	/* epilogue start */
1416:stk500boot.c  **** 
 398               		.loc 1 1416 0
 399 00b2 CF91      		pop r28
1415:stk500boot.c  **** }
 400               		.loc 1 1415 0
 401 00b4 0C94 0000 		jmp sendchar
 402               	.LVL42:
 403               		.cfi_endproc
 404               	.LFE28:
 406               		.section	.text.unlikely
 408               	DumpHex.constprop.0:
 409               	.LFB40:
1529:stk500boot.c  **** {
 410               		.loc 1 1529 0
 411               		.cfi_startproc
 412               	.LVL43:
 413 0028 2F92      		push r2
 414               	.LCFI6:
 415               		.cfi_def_cfa_offset 4
 416               		.cfi_offset 2, -3
 417 002a 3F92      		push r3
 418               	.LCFI7:
 419               		.cfi_def_cfa_offset 5
 420               		.cfi_offset 3, -4
 421 002c 4F92      		push r4
 422               	.LCFI8:
 423               		.cfi_def_cfa_offset 6
 424               		.cfi_offset 4, -5
 425 002e 5F92      		push r5
 426               	.LCFI9:
 427               		.cfi_def_cfa_offset 7
 428               		.cfi_offset 5, -6
 429 0030 6F92      		push r6
 430               	.LCFI10:
 431               		.cfi_def_cfa_offset 8
 432               		.cfi_offset 6, -7
 433 0032 7F92      		push r7
 434               	.LCFI11:
 435               		.cfi_def_cfa_offset 9
 436               		.cfi_offset 7, -8
 437 0034 8F92      		push r8
 438               	.LCFI12:
 439               		.cfi_def_cfa_offset 10
 440               		.cfi_offset 8, -9
 441 0036 9F92      		push r9
 442               	.LCFI13:
 443               		.cfi_def_cfa_offset 11
 444               		.cfi_offset 9, -10
 445 0038 AF92      		push r10
 446               	.LCFI14:
 447               		.cfi_def_cfa_offset 12
 448               		.cfi_offset 10, -11
 449 003a BF92      		push r11
 450               	.LCFI15:
 451               		.cfi_def_cfa_offset 13
 452               		.cfi_offset 11, -12
 453 003c CF92      		push r12
 454               	.LCFI16:
 455               		.cfi_def_cfa_offset 14
 456               		.cfi_offset 12, -13
 457 003e DF92      		push r13
 458               	.LCFI17:
 459               		.cfi_def_cfa_offset 15
 460               		.cfi_offset 13, -14
 461 0040 EF92      		push r14
 462               	.LCFI18:
 463               		.cfi_def_cfa_offset 16
 464               		.cfi_offset 14, -15
 465 0042 FF92      		push r15
 466               	.LCFI19:
 467               		.cfi_def_cfa_offset 17
 468               		.cfi_offset 15, -16
 469 0044 0F93      		push r16
 470               	.LCFI20:
 471               		.cfi_def_cfa_offset 18
 472               		.cfi_offset 16, -17
 473 0046 1F93      		push r17
 474               	.LCFI21:
 475               		.cfi_def_cfa_offset 19
 476               		.cfi_offset 17, -18
 477 0048 CF93      		push r28
 478               	.LCFI22:
 479               		.cfi_def_cfa_offset 20
 480               		.cfi_offset 28, -19
 481 004a DF93      		push r29
 482               	.LCFI23:
 483               		.cfi_def_cfa_offset 21
 484               		.cfi_offset 29, -20
 485 004c CDB7      		in r28,__SP_L__
 486 004e DEB7      		in r29,__SP_H__
 487               	.LCFI24:
 488               		.cfi_def_cfa_register 28
 489 0050 6397      		sbiw r28,19
 490               	.LCFI25:
 491               		.cfi_def_cfa_offset 40
 492 0052 0FB6      		in __tmp_reg__,__SREG__
 493 0054 F894      		cli
 494 0056 DEBF      		out __SP_H__,r29
 495 0058 0FBE      		out __SREG__,__tmp_reg__
 496 005a CDBF      		out __SP_L__,r28
 497               	/* prologue: function */
 498               	/* frame size = 19 */
 499               	/* stack size = 37 */
 500               	.L__stack_usage = 37
 501 005c 8B8B      		std Y+19,r24
 502 005e 6A01      		movw r12,r20
 503 0060 7B01      		movw r14,r22
 504               	.LVL44:
1529:stk500boot.c  **** {
 505               		.loc 1 1529 0
 506 0062 80E1      		ldi r24,lo8(16)
 507 0064 A82E      		mov r10,r24
 508               	.LVL45:
 509 0066 4E01      		movw r8,r28
 510 0068 81E1      		ldi r24,17
 511 006a 880E      		add r8,r24
 512 006c 911C      		adc r9,__zero_reg__
 513               	.LVL46:
 514               	.L33:
1543:stk500boot.c  **** 		{
 515               		.loc 1 1543 0
 516 006e E1E0      		ldi r30,1
 517 0070 CE16      		cp r12,r30
 518 0072 D104      		cpc r13,__zero_reg__
 519 0074 EE06      		cpc r14,r30
 520 0076 F104      		cpc r15,__zero_reg__
 521 0078 00F0      		brlo .L25
1545:stk500boot.c  **** 		}
 522               		.loc 1 1545 0
 523 007a 8E2D      		mov r24,r14
 524 007c 0E94 0000 		call PrintHexByte
 525               	.LVL47:
 526               	.L25:
1547:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
 527               		.loc 1 1547 0
 528 0080 8D2D      		mov r24,r13
 529 0082 0E94 0000 		call PrintHexByte
 530               	.LVL48:
1548:stk500boot.c  **** 		sendchar(0x20);
 531               		.loc 1 1548 0
 532 0086 8C2D      		mov r24,r12
 533 0088 0E94 0000 		call PrintHexByte
 534               	.LVL49:
1549:stk500boot.c  **** 		sendchar('-');
 535               		.loc 1 1549 0
 536 008c 80E2      		ldi r24,lo8(32)
 537 008e 0E94 0000 		call sendchar
 538               	.LVL50:
1550:stk500boot.c  **** 		sendchar(0x20);
 539               		.loc 1 1550 0
 540 0092 8DE2      		ldi r24,lo8(45)
 541 0094 0E94 0000 		call sendchar
 542               	.LVL51:
1551:stk500boot.c  **** 
 543               		.loc 1 1551 0
 544 0098 80E2      		ldi r24,lo8(32)
 545 009a 0E94 0000 		call sendchar
 546               	.LVL52:
1553:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
 547               		.loc 1 1553 0
 548 009e 1982      		std Y+1,__zero_reg__
 549               	.LVL53:
 550 00a0 8E01      		movw r16,r28
 551 00a2 0F5F      		subi r16,-1
 552 00a4 1F4F      		sbci r17,-1
 553 00a6 2601      		movw r4,r12
 554 00a8 3701      		movw r6,r14
 555 00aa 1801      		movw r2,r16
 556               	.LVL54:
 557               	.L32:
1556:stk500boot.c  **** 			{
 558               		.loc 1 1556 0
 559 00ac FB89      		ldd r31,Y+19
 560 00ae F130      		cpi r31,lo8(1)
 561 00b0 01F4      		brne .+2
 562 00b2 00C0      		rjmp .L27
 563 00b4 F230      		cpi r31,lo8(2)
 564 00b6 01F4      		brne .+2
 565 00b8 00C0      		rjmp .L28
 566               	.LVL55:
 567               	.LBB81:
1560:stk500boot.c  **** 				#else
 568               		.loc 1 1560 0
 569               	/* #APP */
 570               	 ;  1560 "stk500boot.c" 1
 571 00ba 6BBE      		out 59, r6
 572 00bc F201      		movw r30, r4
 573 00be B790      		elpm r11, Z+
 574               		
 575               	 ;  0 "" 2
 576               	.LVL56:
 577               	/* #NOAPP */
 578               	.L29:
 579               	.LBE81:
1575:stk500boot.c  **** 			sendchar(0x20);
 580               		.loc 1 1575 0
 581 00c0 8B2D      		mov r24,r11
 582 00c2 0E94 0000 		call PrintHexByte
 583               	.LVL57:
1576:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
 584               		.loc 1 1576 0
 585 00c6 80E2      		ldi r24,lo8(32)
 586 00c8 0E94 0000 		call sendchar
 587               	.LVL58:
1577:stk500boot.c  **** 			{
 588               		.loc 1 1577 0
 589 00cc 80EE      		ldi r24,lo8(-32)
 590 00ce 8B0D      		add r24,r11
 591 00d0 8F35      		cpi r24,lo8(95)
 592 00d2 00F4      		brsh .L30
1579:stk500boot.c  **** 			}
 593               		.loc 1 1579 0
 594 00d4 F801      		movw r30,r16
 595 00d6 B082      		st Z,r11
 596               	.L31:
1586:stk500boot.c  **** 		}
 597               		.loc 1 1586 0
 598 00d8 EFEF      		ldi r30,-1
 599 00da 4E1A      		sub r4,r30
 600 00dc 5E0A      		sbc r5,r30
 601 00de 6E0A      		sbc r6,r30
 602 00e0 7E0A      		sbc r7,r30
 603               	.LVL59:
 604 00e2 0F5F      		subi r16,-1
 605 00e4 1F4F      		sbci r17,-1
1554:stk500boot.c  **** 		{
 606               		.loc 1 1554 0
 607 00e6 0815      		cp r16,r8
 608 00e8 1905      		cpc r17,r9
 609 00ea 01F4      		brne .L32
 610 00ec F0E1      		ldi r31,16
 611 00ee CF0E      		add r12,r31
 612 00f0 D11C      		adc r13,__zero_reg__
 613 00f2 E11C      		adc r14,__zero_reg__
 614 00f4 F11C      		adc r15,__zero_reg__
1588:stk500boot.c  **** 		PrintString(asciiDump);
 615               		.loc 1 1588 0
 616 00f6 198A      		std Y+17,__zero_reg__
1589:stk500boot.c  **** 		PrintNewLine();
 617               		.loc 1 1589 0
 618 00f8 C101      		movw r24,r2
 619 00fa 0E94 0000 		call PrintString
 620               	.LVL60:
1590:stk500boot.c  **** 
 621               		.loc 1 1590 0
 622 00fe 0E94 0000 		call PrintNewLine
 623               	.LVL61:
 624 0102 AA94      		dec r10
 625               	.LVL62:
1541:stk500boot.c  **** 	{
 626               		.loc 1 1541 0
 627 0104 A110      		cpse r10,__zero_reg__
 628 0106 00C0      		rjmp .L33
 629               	/* epilogue start */
1594:stk500boot.c  **** 
 630               		.loc 1 1594 0
 631 0108 6396      		adiw r28,19
 632               	.LVL63:
 633 010a 0FB6      		in __tmp_reg__,__SREG__
 634 010c F894      		cli
 635 010e DEBF      		out __SP_H__,r29
 636 0110 0FBE      		out __SREG__,__tmp_reg__
 637 0112 CDBF      		out __SP_L__,r28
 638 0114 DF91      		pop r29
 639 0116 CF91      		pop r28
 640               	.LVL64:
 641 0118 1F91      		pop r17
 642 011a 0F91      		pop r16
 643 011c FF90      		pop r15
 644 011e EF90      		pop r14
 645 0120 DF90      		pop r13
 646 0122 CF90      		pop r12
 647               	.LVL65:
 648 0124 BF90      		pop r11
 649 0126 AF90      		pop r10
 650               	.LVL66:
 651 0128 9F90      		pop r9
 652 012a 8F90      		pop r8
 653 012c 7F90      		pop r7
 654 012e 6F90      		pop r6
 655 0130 5F90      		pop r5
 656 0132 4F90      		pop r4
 657 0134 3F90      		pop r3
 658 0136 2F90      		pop r2
 659 0138 0895      		ret
 660               	.LVL67:
 661               	.L27:
1567:stk500boot.c  **** 					break;
 662               		.loc 1 1567 0
 663 013a C201      		movw r24,r4
 664 013c 0E94 0000 		call eeprom_read_byte
 665               	.LVL68:
 666 0140 B82E      		mov r11,r24
 667               	.LVL69:
 668 0142 00C0      		rjmp .L29
 669               	.LVL70:
 670               	.L28:
1571:stk500boot.c  **** 					break;
 671               		.loc 1 1571 0
 672 0144 F201      		movw r30,r4
 673 0146 B080      		ld r11,Z
 674               	.LVL71:
 675 0148 00C0      		rjmp .L29
 676               	.L30:
1583:stk500boot.c  **** 			}
 677               		.loc 1 1583 0
 678 014a 8EE2      		ldi r24,lo8(46)
 679 014c F801      		movw r30,r16
 680 014e 8083      		st Z,r24
 681 0150 00C0      		rjmp .L31
 682               		.cfi_endproc
 683               	.LFE40:
 685               		.text
 686               	.global	PrintDecInt
 688               	PrintDecInt:
 689               	.LFB29:
1420:stk500boot.c  **** int	theChar;
 690               		.loc 1 1420 0
 691               		.cfi_startproc
 692               	.LVL72:
 693 00b8 0F93      		push r16
 694               	.LCFI26:
 695               		.cfi_def_cfa_offset 4
 696               		.cfi_offset 16, -3
 697 00ba 1F93      		push r17
 698               	.LCFI27:
 699               		.cfi_def_cfa_offset 5
 700               		.cfi_offset 17, -4
 701 00bc CF93      		push r28
 702               	.LCFI28:
 703               		.cfi_def_cfa_offset 6
 704               		.cfi_offset 28, -5
 705 00be DF93      		push r29
 706               	.LCFI29:
 707               		.cfi_def_cfa_offset 7
 708               		.cfi_offset 29, -6
 709               	/* prologue: function */
 710               	/* frame size = 0 */
 711               	/* stack size = 4 */
 712               	.L__stack_usage = 4
 713 00c0 EC01      		movw r28,r24
 714 00c2 8B01      		movw r16,r22
 715               	.LVL73:
1426:stk500boot.c  **** 	{
 716               		.loc 1 1426 0
 717 00c4 8536      		cpi r24,101
 718 00c6 9105      		cpc r25,__zero_reg__
 719 00c8 04F4      		brge .L37
1426:stk500boot.c  **** 	{
 720               		.loc 1 1426 0 is_stmt 0 discriminator 1
 721 00ca 6330      		cpi r22,3
 722 00cc 7105      		cpc r23,__zero_reg__
 723 00ce 04F0      		brlt .L38
 724               	.L37:
 725               	.LVL74:
1428:stk500boot.c  **** 		sendchar(theChar );
 726               		.loc 1 1428 0 is_stmt 1
 727 00d0 CE01      		movw r24,r28
 728               	.LVL75:
 729 00d2 64E6      		ldi r22,lo8(100)
 730 00d4 70E0      		ldi r23,0
 731               	.LVL76:
 732 00d6 0E94 0000 		call __divmodhi4
 733               	.LVL77:
1429:stk500boot.c  **** 	}
 734               		.loc 1 1429 0
 735 00da 80E3      		ldi r24,lo8(48)
 736 00dc 860F      		add r24,r22
 737 00de 0E94 0000 		call sendchar
 738               	.LVL78:
 739               	.L38:
1432:stk500boot.c  **** 	{
 740               		.loc 1 1432 0
 741 00e2 CB30      		cpi r28,11
 742 00e4 D105      		cpc r29,__zero_reg__
 743 00e6 04F4      		brge .L39
1432:stk500boot.c  **** 	{
 744               		.loc 1 1432 0 is_stmt 0 discriminator 1
 745 00e8 0230      		cpi r16,2
 746 00ea 1105      		cpc r17,__zero_reg__
 747 00ec 04F0      		brlt .L40
 748               	.L39:
 749               	.LVL79:
1434:stk500boot.c  **** 		sendchar(theChar );
 750               		.loc 1 1434 0 is_stmt 1
 751 00ee CE01      		movw r24,r28
 752 00f0 64E6      		ldi r22,lo8(100)
 753 00f2 70E0      		ldi r23,0
 754 00f4 0E94 0000 		call __divmodhi4
 755 00f8 6AE0      		ldi r22,lo8(10)
 756 00fa 70E0      		ldi r23,0
 757 00fc 0E94 0000 		call __divmodhi4
1435:stk500boot.c  **** 	}
 758               		.loc 1 1435 0
 759 0100 80E3      		ldi r24,lo8(48)
 760 0102 860F      		add r24,r22
 761 0104 0E94 0000 		call sendchar
 762               	.LVL80:
 763               	.L40:
1437:stk500boot.c  **** 	sendchar(theChar );
 764               		.loc 1 1437 0
 765 0108 CE01      		movw r24,r28
 766 010a 6AE0      		ldi r22,lo8(10)
 767 010c 70E0      		ldi r23,0
 768 010e 0E94 0000 		call __divmodhi4
1438:stk500boot.c  **** }
 769               		.loc 1 1438 0
 770 0112 805D      		subi r24,lo8(-(48))
 771               	/* epilogue start */
1439:stk500boot.c  **** 
 772               		.loc 1 1439 0
 773 0114 DF91      		pop r29
 774 0116 CF91      		pop r28
 775               	.LVL81:
 776 0118 1F91      		pop r17
 777 011a 0F91      		pop r16
 778               	.LVL82:
1438:stk500boot.c  **** }
 779               		.loc 1 1438 0
 780 011c 0C94 0000 		jmp sendchar
 781               	.LVL83:
 782               		.cfi_endproc
 783               	.LFE29:
 785               		.section	.text.startup,"ax",@progbits
 786               	.global	main
 788               	main:
 789               	.LFB23:
 583:stk500boot.c  **** 	address_t		address			=	0;
 790               		.loc 1 583 0
 791               		.cfi_startproc
 792 0000 CF93      		push r28
 793               	.LCFI30:
 794               		.cfi_def_cfa_offset 4
 795               		.cfi_offset 28, -3
 796 0002 DF93      		push r29
 797               	.LCFI31:
 798               		.cfi_def_cfa_offset 5
 799               		.cfi_offset 29, -4
 800 0004 CDB7      		in r28,__SP_L__
 801 0006 DEB7      		in r29,__SP_H__
 802               	.LCFI32:
 803               		.cfi_def_cfa_register 28
 804 0008 C653      		subi r28,54
 805 000a D140      		sbci r29,1
 806               	.LCFI33:
 807               		.cfi_def_cfa_offset 315
 808 000c 0FB6      		in __tmp_reg__,__SREG__
 809 000e F894      		cli
 810 0010 DEBF      		out __SP_H__,r29
 811 0012 0FBE      		out __SREG__,__tmp_reg__
 812 0014 CDBF      		out __SP_L__,r28
 813               	/* prologue: function */
 814               	/* frame size = 310 */
 815               	/* stack size = 312 */
 816               	.L__stack_usage = 312
 817               	.LVL84:
 604:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 818               		.loc 1 604 0
 819               	/* #APP */
 820               	 ;  604 "stk500boot.c" 1
 821               		.set __stack, 8703
 822               	 ;  0 "" 2
 605:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 823               		.loc 1 605 0
 824               	 ;  605 "stk500boot.c" 1
 825 0016 01E2      		ldi	16, 33
 826               	 ;  0 "" 2
 606:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 827               		.loc 1 606 0
 828               	 ;  606 "stk500boot.c" 1
 829 0018 0EBF      		out 62,16
 830               	 ;  0 "" 2
 607:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 831               		.loc 1 607 0
 832               	 ;  607 "stk500boot.c" 1
 833 001a 0FEF      		ldi	16, 255
 834               	 ;  0 "" 2
 608:stk500boot.c  **** 
 835               		.loc 1 608 0
 836               	 ;  608 "stk500boot.c" 1
 837 001c 0DBF      		out 61,16
 838               	 ;  0 "" 2
 615:stk500boot.c  **** 
 839               		.loc 1 615 0
 840               	/* #NOAPP */
 841 001e 94B7      		in r25,0x34
 842               	.LVL85:
 617:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 843               		.loc 1 617 0
 844               	/* #APP */
 845               	 ;  617 "stk500boot.c" 1
 846 0020 F894      		cli
 847               	 ;  0 "" 2
 618:stk500boot.c  **** 	MCUSR	=	0;
 848               		.loc 1 618 0
 849               	 ;  618 "stk500boot.c" 1
 850 0022 A895      		wdr
 851               	 ;  0 "" 2
 619:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 852               		.loc 1 619 0
 853               	/* #NOAPP */
 854 0024 14BE      		out 0x34,__zero_reg__
 620:stk500boot.c  **** 	WDTCSR	=	0;
 855               		.loc 1 620 0
 856 0026 8091 6000 		lds r24,96
 857 002a 8861      		ori r24,lo8(24)
 858 002c 8093 6000 		sts 96,r24
 621:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 859               		.loc 1 621 0
 860 0030 1092 6000 		sts 96,__zero_reg__
 622:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 861               		.loc 1 622 0
 862               	/* #APP */
 863               	 ;  622 "stk500boot.c" 1
 864 0034 7894      		sei
 865               	 ;  0 "" 2
 624:stk500boot.c  **** 	{
 866               		.loc 1 624 0
 867               	/* #NOAPP */
 868 0036 93FF      		sbrs r25,3
 869 0038 00C0      		rjmp .L42
 626:stk500boot.c  **** 	}
 870               		.loc 1 626 0
 871 003a E091 0000 		lds r30,app_start
 872 003e F091 0000 		lds r31,app_start+1
 873 0042 1995      		eicall
 874               	.LVL86:
 875               	.L42:
 648:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 876               		.loc 1 648 0
 877 0044 279A      		sbi 0x4,7
 650:stk500boot.c  **** 
 878               		.loc 1 650 0
 879 0046 2F9A      		sbi 0x5,7
 668:stk500boot.c  **** #endif
 880               		.loc 1 668 0
 881 0048 8091 C000 		lds r24,192
 882 004c 8260      		ori r24,lo8(2)
 883 004e 8093 C000 		sts 192,r24
 670:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 884               		.loc 1 670 0
 885 0052 80E1      		ldi r24,lo8(16)
 886 0054 8093 C400 		sts 196,r24
 671:stk500boot.c  **** 
 887               		.loc 1 671 0
 888 0058 88E1      		ldi r24,lo8(24)
 889 005a 8093 C100 		sts 193,r24
 673:stk500boot.c  **** 	corebeep_init();
 890               		.loc 1 673 0
 891               	/* #APP */
 892               	 ;  673 "stk500boot.c" 1
 893 005e 0000      		nop
 894               	 ;  0 "" 2
 895               	/* #NOAPP */
 896               	.LBB168:
 897               	.LBB169:
 550:stk500boot.c  ****     COREBEEP_PORT &= ~(1 << COREBEEP_BIT);    // default OFF
 898               		.loc 1 550 0
 899 0060 249A      		sbi 0x4,4
 551:stk500boot.c  **** }
 900               		.loc 1 551 0
 901 0062 2C98      		cbi 0x5,4
 902               	.LBE169:
 903               	.LBE168:
 904               	.LBB170:
 905               	.LBB171:
 561:stk500boot.c  **** }
 906               		.loc 1 561 0
 907 0064 2C98      		cbi 0x5,4
 908               	.LBE171:
 909               	.LBE170:
 910               	.LBB172:
 911               	.LBB173:
 566:stk500boot.c  ****     BEEP_OFF();                      // 
 912               		.loc 1 566 0
 913 0066 8091 0101 		lds r24,257
 914 006a 8064      		ori r24,lo8(64)
 915 006c 8093 0101 		sts 257,r24
 567:stk500boot.c  **** }
 916               		.loc 1 567 0
 917 0070 8091 0201 		lds r24,258
 918 0074 8F7B      		andi r24,lo8(-65)
 919 0076 8093 0201 		sts 258,r24
 920               	.LBE173:
 921               	.LBE172:
 922               	.LBB174:
 923               	.LBB175:
 577:stk500boot.c  **** }
 924               		.loc 1 577 0
 925 007a 8091 0201 		lds r24,258
 926 007e 8F7B      		andi r24,lo8(-65)
 927 0080 8093 0201 		sts 258,r24
 928 0084 10E0      		ldi r17,0
 929 0086 00E0      		ldi r16,0
 930               	.LBE175:
 931               	.LBE174:
 632:stk500boot.c  **** 	boot_state	=	0;
 932               		.loc 1 632 0
 933 0088 C12C      		mov r12,__zero_reg__
 934 008a D12C      		mov r13,__zero_reg__
 935 008c 7601      		movw r14,r12
 706:stk500boot.c  **** 			{
 936               		.loc 1 706 0
 937 008e F7EC      		ldi r31,lo8(-57)
 938 0090 8F2E      		mov r8,r31
 939 0092 FBE1      		ldi r31,lo8(27)
 940 0094 9F2E      		mov r9,r31
 941 0096 A12C      		mov r10,__zero_reg__
 942 0098 B12C      		mov r11,__zero_reg__
 943               	.LVL87:
 944               	.L43:
 945               	.LBB176:
 946               	.LBB177:
 477:stk500boot.c  **** }
 947               		.loc 1 477 0
 948 009a 8091 C000 		lds r24,192
 949               	.LBE177:
 950               	.LBE176:
 697:stk500boot.c  **** 		{
 951               		.loc 1 697 0
 952 009e 87FD      		sbrc r24,7
 953 00a0 00C0      		rjmp .L46
 697:stk500boot.c  **** 		{
 954               		.loc 1 697 0 is_stmt 0 discriminator 1
 955 00a2 0115      		cp r16,__zero_reg__
 956 00a4 1105      		cpc r17,__zero_reg__
 957 00a6 01F0      		breq .L47
 958               	.L46:
 959               	.LVL88:
 717:stk500boot.c  **** 	{
 960               		.loc 1 717 0 is_stmt 1
 961 00a8 012B      		or r16,r17
 962 00aa 01F0      		breq .+2
 963 00ac 00C0      		rjmp .L49
 600:stk500boot.c  **** #endif
 964               		.loc 1 600 0
 965 00ae C55D      		subi r28,lo8(-299)
 966 00b0 DE4F      		sbci r29,hi8(-299)
 967 00b2 1982      		std Y+1,__zero_reg__
 968 00b4 1882      		st Y,__zero_reg__
 969 00b6 CB52      		subi r28,lo8(299)
 970 00b8 D140      		sbci r29,hi8(299)
 599:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 971               		.loc 1 599 0
 972 00ba F12C      		mov r15,__zero_reg__
 973 00bc E12C      		mov r14,__zero_reg__
 587:stk500boot.c  **** 	unsigned char	checksum		=	0;
 974               		.loc 1 587 0
 975 00be CE5D      		subi r28,lo8(-290)
 976 00c0 DE4F      		sbci r29,hi8(-290)
 977 00c2 1982      		std Y+1,__zero_reg__
 978 00c4 1882      		st Y,__zero_reg__
 979 00c6 C252      		subi r28,lo8(290)
 980 00c8 D140      		sbci r29,hi8(290)
 585:stk500boot.c  **** 	unsigned char	msgParseState;
 981               		.loc 1 585 0
 982 00ca CC5D      		subi r28,lo8(-292)
 983 00cc DE4F      		sbci r29,hi8(-292)
 984 00ce 1882      		st Y,__zero_reg__
 985 00d0 1982      		std Y+1,__zero_reg__
 986 00d2 1A82      		std Y+2,__zero_reg__
 987 00d4 1B82      		std Y+3,__zero_reg__
 988 00d6 C452      		subi r28,lo8(292)
 989 00d8 D140      		sbci r29,hi8(292)
 584:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 990               		.loc 1 584 0
 991 00da 212C      		mov r2,__zero_reg__
 992 00dc 312C      		mov r3,__zero_reg__
 993 00de 2101      		movw r4,r2
 994 00e0 41E0      		ldi r20,lo8(1)
 995 00e2 50E0      		ldi r21,0
 589:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 996               		.loc 1 589 0
 997 00e4 C85D      		subi r28,lo8(-296)
 998 00e6 DE4F      		sbci r29,hi8(-296)
 999 00e8 1882      		st Y,__zero_reg__
 1000 00ea C852      		subi r28,lo8(296)
 1001 00ec D140      		sbci r29,hi8(296)
 588:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 1002               		.loc 1 588 0
 1003 00ee B12C      		mov r11,__zero_reg__
 816:stk500boot.c  **** 						checksum		^=	c;
 1004               		.loc 1 816 0
 1005 00f0 9E01      		movw r18,r28
 1006 00f2 2F5F      		subi r18,-1
 1007 00f4 3F4F      		sbci r19,-1
 1008 00f6 3901      		movw r6,r18
 1009               	.LVL89:
 1010               	.L48:
 632:stk500boot.c  **** 	boot_state	=	0;
 1011               		.loc 1 632 0
 1012 00f8 30E0      		ldi r19,0
 1013 00fa 20E0      		ldi r18,0
 1014 00fc 80E0      		ldi r24,0
 1015 00fe 00C0      		rjmp .L193
 1016               	.LVL90:
 1017               	.L47:
 1018               	.LBB178:
 1019               	.LBB179:
 1020               		.loc 2 187 0
 1021 0100 25E0      		ldi r18,lo8(5)
 1022 0102 2A95      	1:	dec r18
 1023 0104 01F4      		brne 1b
 1024 0106 0000      		nop
 1025               	.LVL91:
 1026               	.LBE179:
 1027               	.LBE178:
 700:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 1028               		.loc 1 700 0
 1029 0108 3FEF      		ldi r19,-1
 1030 010a C31A      		sub r12,r19
 1031 010c D30A      		sbc r13,r19
 1032 010e E30A      		sbc r14,r19
 1033 0110 F30A      		sbc r15,r19
 1034               	.LVL92:
 701:stk500boot.c  **** 			{
 1035               		.loc 1 701 0
 1036 0112 91E0      		ldi r25,lo8(1)
 1037 0114 80E0      		ldi r24,0
 1038 0116 41E2      		ldi r20,33
 1039 0118 C416      		cp r12,r20
 1040 011a 4EE4      		ldi r20,78
 1041 011c D406      		cpc r13,r20
 1042 011e E104      		cpc r14,__zero_reg__
 1043 0120 F104      		cpc r15,__zero_reg__
 1044 0122 00F4      		brsh .L44
 1045 0124 90E0      		ldi r25,0
 1046               	.L44:
 703:stk500boot.c  **** 			}
 1047               		.loc 1 703 0
 1048 0126 092F      		mov r16,r25
 1049               	.LVL93:
 1050 0128 182F      		mov r17,r24
 706:stk500boot.c  **** 			{
 1051               		.loc 1 706 0
 1052 012a C701      		movw r24,r14
 1053 012c B601      		movw r22,r12
 1054 012e A501      		movw r20,r10
 1055 0130 9401      		movw r18,r8
 1056 0132 0E94 0000 		call __udivmodsi4
 1057 0136 672B      		or r22,r23
 1058 0138 682B      		or r22,r24
 1059 013a 692B      		or r22,r25
 1060 013c 01F0      		breq .+2
 1061 013e 00C0      		rjmp .L43
 709:stk500boot.c  **** 			}
 1062               		.loc 1 709 0
 1063 0140 85B1      		in r24,0x5
 1064 0142 8058      		subi r24,lo8(-(-128))
 1065 0144 85B9      		out 0x5,r24
 1066 0146 00C0      		rjmp .L43
 1067               	.LVL94:
 1068               	.L54:
 1069 0148 4150      		subi r20,1
 1070 014a 5109      		sbc r21,__zero_reg__
 1071 014c 6109      		sbc r22,__zero_reg__
 1072 014e 7109      		sbc r23,__zero_reg__
 1073               	.LVL95:
 1074               	.LBB180:
 1075               	.LBB181:
 504:stk500boot.c  **** 		{
 1076               		.loc 1 504 0
 1077 0150 01F4      		brne .L52
 1078               	.LVL96:
 1079               	.LBB182:
 1080               	.LBB183:
 508:stk500boot.c  **** 		#else
 1081               		.loc 1 508 0
 1082               	/* #APP */
 1083               	 ;  508 "stk500boot.c" 1
 1084 0152 6BBF      		out 59, r22
 1085 0154 FA01      		movw r30, r20
 1086 0156 4791      		elpm r20, Z+
 1087 0158 5691      		elpm r21, Z
 1088               		
 1089               	 ;  0 "" 2
 1090               	.LVL97:
 1091               	/* #NOAPP */
 1092               	.LBE183:
 512:stk500boot.c  **** 			{
 1093               		.loc 1 512 0
 1094 015a 4F3F      		cpi r20,-1
 1095 015c 5F4F      		sbci r21,-1
 1096 015e 01F0      		breq .L53
 514:stk500boot.c  **** 						"clr	r30		\n\t"
 1097               		.loc 1 514 0
 1098               	/* #APP */
 1099               	 ;  514 "stk500boot.c" 1
 1100 0160 EE27      		clr	r30		
 1101 0162 FF27      		clr	r31		
 1102 0164 0994      		ijmp	
 1103               		
 1104               	 ;  0 "" 2
 1105               	.LVL98:
 1106               	/* #NOAPP */
 1107               	.L53:
 1108               	.LBE182:
 1109               	.LBE181:
 1110               	.LBE180:
 632:stk500boot.c  **** 	boot_state	=	0;
 1111               		.loc 1 632 0
 1112 0166 41E0      		ldi r20,lo8(1)
 1113 0168 52E1      		ldi r21,lo8(18)
 1114 016a 6AE7      		ldi r22,lo8(122)
 1115 016c 70E0      		ldi r23,0
 1116               	.L52:
 1117               	.LVL99:
 1118               	.LBB186:
 1119               	.LBB184:
 500:stk500boot.c  **** 	{
 1120               		.loc 1 500 0
 1121 016e 9091 C000 		lds r25,192
 1122 0172 97FF      		sbrs r25,7
 1123 0174 00C0      		rjmp .L54
 1124 0176 00C0      		rjmp .L270
 1125               	.LVL100:
 1126               	.L65:
 1127               	.LBE184:
 1128               	.LBE186:
 1129               	.LBB187:
 1130               	.LBB188:
1807:stk500boot.c  **** 
1808:stk500boot.c  **** //************************************************************************
1809:stk500boot.c  **** static void	ListAvailablePorts(void)
1810:stk500boot.c  **** {
1811:stk500boot.c  **** 
1812:stk500boot.c  **** #ifdef DDRA
1813:stk500boot.c  **** 	PrintAvailablePort('A');
1814:stk500boot.c  **** #endif
1815:stk500boot.c  **** 
1816:stk500boot.c  **** #ifdef DDRB
1817:stk500boot.c  **** 	PrintAvailablePort('B');
1818:stk500boot.c  **** #endif
1819:stk500boot.c  **** 
1820:stk500boot.c  **** #ifdef DDRC
1821:stk500boot.c  **** 	PrintAvailablePort('C');
1822:stk500boot.c  **** #endif
1823:stk500boot.c  **** 
1824:stk500boot.c  **** #ifdef DDRD
1825:stk500boot.c  **** 	PrintAvailablePort('D');
1826:stk500boot.c  **** #endif
1827:stk500boot.c  **** 
1828:stk500boot.c  **** #ifdef DDRE
1829:stk500boot.c  **** 	PrintAvailablePort('E');
1830:stk500boot.c  **** #endif
1831:stk500boot.c  **** 
1832:stk500boot.c  **** #ifdef DDRF
1833:stk500boot.c  **** 	PrintAvailablePort('F');
1834:stk500boot.c  **** #endif
1835:stk500boot.c  **** 
1836:stk500boot.c  **** #ifdef DDRG
1837:stk500boot.c  **** 	PrintAvailablePort('G');
1838:stk500boot.c  **** #endif
1839:stk500boot.c  **** 
1840:stk500boot.c  **** #ifdef DDRH
1841:stk500boot.c  **** 	PrintAvailablePort('H');
1842:stk500boot.c  **** #endif
1843:stk500boot.c  **** 
1844:stk500boot.c  **** #ifdef DDRI
1845:stk500boot.c  **** 	PrintAvailablePort('I');
1846:stk500boot.c  **** #endif
1847:stk500boot.c  **** 
1848:stk500boot.c  **** #ifdef DDRJ
1849:stk500boot.c  **** 	PrintAvailablePort('J');
1850:stk500boot.c  **** #endif
1851:stk500boot.c  **** 
1852:stk500boot.c  **** #ifdef DDRK
1853:stk500boot.c  **** 	PrintAvailablePort('K');
1854:stk500boot.c  **** #endif
1855:stk500boot.c  **** 
1856:stk500boot.c  **** #ifdef DDRL
1857:stk500boot.c  **** 	PrintAvailablePort('L');
1858:stk500boot.c  **** #endif
1859:stk500boot.c  **** 
1860:stk500boot.c  **** }
1861:stk500boot.c  **** 
1862:stk500boot.c  **** //************************************************************************
1863:stk500boot.c  **** static void	AVR_PortOutput(void)
1864:stk500boot.c  **** {
1865:stk500boot.c  **** char	portLetter;
1866:stk500boot.c  **** char	getCharFlag;
1867:stk500boot.c  **** 
1868:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);
1869:stk500boot.c  **** 
1870:stk500boot.c  **** 	portLetter	=	recchar();
1871:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
1872:stk500boot.c  **** 	sendchar(portLetter);
1873:stk500boot.c  **** 	PrintNewLine();
1874:stk500boot.c  **** 
1875:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
1876:stk500boot.c  **** 	{
1877:stk500boot.c  **** 		getCharFlag	=	true;
1878:stk500boot.c  **** 		switch(portLetter)
1879:stk500boot.c  **** 		{
1880:stk500boot.c  **** 		#ifdef DDRA
1881:stk500boot.c  **** 			case 'A':
1882:stk500boot.c  **** 				DDRA	=	0xff;
1883:stk500boot.c  **** 				while (!Serial_Available())
1884:stk500boot.c  **** 				{
1885:stk500boot.c  **** 					PORTA	^=	0xff;
1886:stk500boot.c  **** 					delay_ms(200);
1887:stk500boot.c  **** 				}
1888:stk500boot.c  **** 				PORTA	=	0;
1889:stk500boot.c  **** 				break;
1890:stk500boot.c  **** 		#endif
1891:stk500boot.c  **** 
1892:stk500boot.c  **** 		#ifdef DDRB
1893:stk500boot.c  **** 			case 'B':
1894:stk500boot.c  **** 				DDRB	=	0xff;
1895:stk500boot.c  **** 				while (!Serial_Available())
1896:stk500boot.c  **** 				{
1897:stk500boot.c  **** 					PORTB	^=	0xff;
1898:stk500boot.c  **** 					delay_ms(200);
1899:stk500boot.c  **** 				}
1900:stk500boot.c  **** 				PORTB	=	0;
1901:stk500boot.c  **** 				break;
1902:stk500boot.c  **** 		#endif
1903:stk500boot.c  **** 
1904:stk500boot.c  **** 		#ifdef DDRC
1905:stk500boot.c  **** 			case 'C':
1906:stk500boot.c  **** 				DDRC	=	0xff;
1907:stk500boot.c  **** 				while (!Serial_Available())
1908:stk500boot.c  **** 				{
1909:stk500boot.c  **** 					PORTC	^=	0xff;
1910:stk500boot.c  **** 					delay_ms(200);
1911:stk500boot.c  **** 				}
1912:stk500boot.c  **** 				PORTC	=	0;
1913:stk500boot.c  **** 				break;
1914:stk500boot.c  **** 		#endif
1915:stk500boot.c  **** 
1916:stk500boot.c  **** 		#ifdef DDRD
1917:stk500boot.c  **** 			case 'D':
1918:stk500boot.c  **** 				DDRD	=	0xff;
1919:stk500boot.c  **** 				while (!Serial_Available())
1920:stk500boot.c  **** 				{
1921:stk500boot.c  **** 					PORTD	^=	0xff;
1922:stk500boot.c  **** 					delay_ms(200);
1923:stk500boot.c  **** 				}
1924:stk500boot.c  **** 				PORTD	=	0;
1925:stk500boot.c  **** 				break;
1926:stk500boot.c  **** 		#endif
1927:stk500boot.c  **** 
1928:stk500boot.c  **** 		#ifdef DDRE
1929:stk500boot.c  **** 			case 'E':
1930:stk500boot.c  **** 				DDRE	=	0xff;
1931:stk500boot.c  **** 				while (!Serial_Available())
1932:stk500boot.c  **** 				{
1933:stk500boot.c  **** 					PORTE	^=	0xff;
1934:stk500boot.c  **** 					delay_ms(200);
1935:stk500boot.c  **** 				}
1936:stk500boot.c  **** 				PORTE	=	0;
1937:stk500boot.c  **** 				break;
1938:stk500boot.c  **** 		#endif
1939:stk500boot.c  **** 
1940:stk500boot.c  **** 		#ifdef DDRF
1941:stk500boot.c  **** 			case 'F':
1942:stk500boot.c  **** 				DDRF	=	0xff;
1943:stk500boot.c  **** 				while (!Serial_Available())
1944:stk500boot.c  **** 				{
1945:stk500boot.c  **** 					PORTF	^=	0xff;
1946:stk500boot.c  **** 					delay_ms(200);
1947:stk500boot.c  **** 				}
1948:stk500boot.c  **** 				PORTF	=	0;
1949:stk500boot.c  **** 				break;
1950:stk500boot.c  **** 		#endif
1951:stk500boot.c  **** 
1952:stk500boot.c  **** 		#ifdef DDRG
1953:stk500boot.c  **** 			case 'G':
1954:stk500boot.c  **** 				DDRG	=	0xff;
1955:stk500boot.c  **** 				while (!Serial_Available())
1956:stk500boot.c  **** 				{
1957:stk500boot.c  **** 					PORTG	^=	0xff;
1958:stk500boot.c  **** 					delay_ms(200);
1959:stk500boot.c  **** 				}
1960:stk500boot.c  **** 				PORTG	=	0;
1961:stk500boot.c  **** 				break;
1962:stk500boot.c  **** 		#endif
1963:stk500boot.c  **** 
1964:stk500boot.c  **** 		#ifdef DDRH
1965:stk500boot.c  **** 			case 'H':
1966:stk500boot.c  **** 				DDRH	=	0xff;
1967:stk500boot.c  **** 				while (!Serial_Available())
1968:stk500boot.c  **** 				{
1969:stk500boot.c  **** 					PORTH	^=	0xff;
1970:stk500boot.c  **** 					delay_ms(200);
1971:stk500boot.c  **** 				}
1972:stk500boot.c  **** 				PORTH	=	0;
1973:stk500boot.c  **** 				break;
1974:stk500boot.c  **** 		#endif
1975:stk500boot.c  **** 
1976:stk500boot.c  **** 		#ifdef DDRI
1977:stk500boot.c  **** 			case 'I':
1978:stk500boot.c  **** 				DDRI	=	0xff;
1979:stk500boot.c  **** 				while (!Serial_Available())
1980:stk500boot.c  **** 				{
1981:stk500boot.c  **** 					PORTI	^=	0xff;
1982:stk500boot.c  **** 					delay_ms(200);
1983:stk500boot.c  **** 				}
1984:stk500boot.c  **** 				PORTI	=	0;
1985:stk500boot.c  **** 				break;
1986:stk500boot.c  **** 		#endif
1987:stk500boot.c  **** 
1988:stk500boot.c  **** 		#ifdef DDRJ
1989:stk500boot.c  **** 			case 'J':
1990:stk500boot.c  **** 				DDRJ	=	0xff;
1991:stk500boot.c  **** 				while (!Serial_Available())
1992:stk500boot.c  **** 				{
1993:stk500boot.c  **** 					PORTJ	^=	0xff;
1994:stk500boot.c  **** 					delay_ms(200);
1995:stk500boot.c  **** 				}
1996:stk500boot.c  **** 				PORTJ	=	0;
1997:stk500boot.c  **** 				break;
1998:stk500boot.c  **** 		#endif
1999:stk500boot.c  **** 
2000:stk500boot.c  **** 		#ifdef DDRK
2001:stk500boot.c  **** 			case 'K':
2002:stk500boot.c  **** 				DDRK	=	0xff;
2003:stk500boot.c  **** 				while (!Serial_Available())
2004:stk500boot.c  **** 				{
2005:stk500boot.c  **** 					PORTK	^=	0xff;
2006:stk500boot.c  **** 					delay_ms(200);
2007:stk500boot.c  **** 				}
2008:stk500boot.c  **** 				PORTK	=	0;
2009:stk500boot.c  **** 				break;
2010:stk500boot.c  **** 		#endif
2011:stk500boot.c  **** 
2012:stk500boot.c  **** 		#ifdef DDRL
2013:stk500boot.c  **** 			case 'L':
2014:stk500boot.c  **** 				DDRL	=	0xff;
2015:stk500boot.c  **** 				while (!Serial_Available())
2016:stk500boot.c  **** 				{
2017:stk500boot.c  **** 					PORTL	^=	0xff;
2018:stk500boot.c  **** 					delay_ms(200);
2019:stk500boot.c  **** 				}
2020:stk500boot.c  **** 				PORTL	=	0;
2021:stk500boot.c  **** 				break;
2022:stk500boot.c  **** 		#endif
2023:stk500boot.c  **** 
2024:stk500boot.c  **** 			default:
2025:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);
2026:stk500boot.c  **** 				getCharFlag	=	false;
2027:stk500boot.c  **** 				break;
2028:stk500boot.c  **** 		}
2029:stk500boot.c  **** 		if (getCharFlag)
2030:stk500boot.c  **** 		{
2031:stk500boot.c  **** 			recchar();
2032:stk500boot.c  **** 		}
2033:stk500boot.c  **** 	}
2034:stk500boot.c  **** 	else
2035:stk500boot.c  **** 	{
2036:stk500boot.c  **** 		PrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);
2037:stk500boot.c  **** 	}
2038:stk500boot.c  **** }
2039:stk500boot.c  **** 
2040:stk500boot.c  **** 
2041:stk500boot.c  **** //*******************************************************************
2042:stk500boot.c  **** static void PrintHelp(void)
2043:stk500boot.c  **** {
2044:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 0);
2045:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
2046:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
2047:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
2048:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
2049:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
2050:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
2051:stk500boot.c  **** 
2052:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 0);
2053:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
2054:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
2055:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
2056:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
2057:stk500boot.c  **** }
2058:stk500boot.c  **** 
2059:stk500boot.c  **** //************************************************************************
2060:stk500boot.c  **** static void	RunMonitor(void)
2061:stk500boot.c  **** {
2062:stk500boot.c  **** char			keepGoing;
2063:stk500boot.c  **** unsigned char	theChar;
2064:stk500boot.c  **** int				ii, jj;
2065:stk500boot.c  **** 
2066:stk500boot.c  **** 	for (ii=0; ii<5; ii++)
2067:stk500boot.c  **** 	{
2068:stk500boot.c  **** 		for (jj=0; jj<25; jj++)
2069:stk500boot.c  **** 		{
2070:stk500boot.c  **** 			sendchar('!');
2071:stk500boot.c  **** 		}
2072:stk500boot.c  **** 		PrintNewLine();
2073:stk500boot.c  **** 	}
2074:stk500boot.c  **** 
2075:stk500boot.c  **** 	gRamIndex			=	0;
2076:stk500boot.c  **** 	gFlashIndex			=	0;
2077:stk500boot.c  **** 	gEepromIndex		=	0;
2078:stk500boot.c  **** 
2079:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
2080:stk500boot.c  **** 
2081:stk500boot.c  **** 	keepGoing	=	1;
2082:stk500boot.c  **** 	while (keepGoing)
2083:stk500boot.c  **** 	{
2084:stk500boot.c  **** 		PrintFromPROGMEM(gTextMsg_Prompt, 0);
2085:stk500boot.c  **** 		theChar	=	recchar();
2086:stk500boot.c  **** 		if (theChar >= 0x60)
2087:stk500boot.c  **** 		{
2088:stk500boot.c  **** 			theChar	=	theChar & 0x5F;
2089:stk500boot.c  **** 		}
2090:stk500boot.c  **** 
2091:stk500boot.c  **** 		if (theChar >= 0x20)
2092:stk500boot.c  **** 		{
2093:stk500boot.c  **** 			sendchar(theChar);
2094:stk500boot.c  **** 			sendchar(0x20);
2095:stk500boot.c  **** 		}
2096:stk500boot.c  **** 
2097:stk500boot.c  **** 		switch(theChar)
 1131               		.loc 1 2097 0
 1132 0178 1234      		cpi r17,lo8(66)
 1133 017a 01F4      		brne .+2
 1134 017c 00C0      		rjmp .L68
 1135 017e 1534      		cpi r17,lo8(69)
 1136 0180 01F0      		breq .+2
 1137 0182 00C0      		rjmp .L61
2098:stk500boot.c  **** 		{
2099:stk500boot.c  **** 			case '0':
2100:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 2);
2101:stk500boot.c  **** 				gFlashIndex		=	0;
2102:stk500boot.c  **** 				gRamIndex		=	0;
2103:stk500boot.c  **** 				gEepromIndex	=	0;
2104:stk500boot.c  **** 				break;
2105:stk500boot.c  **** 
2106:stk500boot.c  **** 			case '?':
2107:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 2);
2108:stk500boot.c  **** 				PrintCPUstats();
2109:stk500boot.c  **** 				break;
2110:stk500boot.c  **** 
2111:stk500boot.c  **** 			case '@':
2112:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 2);
2113:stk500boot.c  **** 				EEPROMtest();
2114:stk500boot.c  **** 				break;
2115:stk500boot.c  **** 
2116:stk500boot.c  **** 			case 'B':
2117:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 2);
2118:stk500boot.c  **** 				BlinkLED();
2119:stk500boot.c  **** 				break;
2120:stk500boot.c  **** 
2121:stk500boot.c  **** 			case 'E':
2122:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 2);
 1138               		.loc 1 2122 0
 1139 0184 62E0      		ldi r22,lo8(2)
 1140 0186 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1141 0188 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1142 018a 0E94 0000 		call PrintFromPROGMEMln
 1143               	.LVL101:
2123:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
 1144               		.loc 1 2123 0
 1145 018e 4091 0000 		lds r20,gEepromIndex
 1146 0192 5091 0000 		lds r21,gEepromIndex+1
 1147 0196 6091 0000 		lds r22,gEepromIndex+2
 1148 019a 7091 0000 		lds r23,gEepromIndex+3
 1149 019e 81E0      		ldi r24,lo8(1)
 1150 01a0 0E94 0000 		call DumpHex.constprop.0
 1151               	.LVL102:
2124:stk500boot.c  **** 				gEepromIndex	+=	256;
 1152               		.loc 1 2124 0
 1153 01a4 8091 0000 		lds r24,gEepromIndex
 1154 01a8 9091 0000 		lds r25,gEepromIndex+1
 1155 01ac A091 0000 		lds r26,gEepromIndex+2
 1156 01b0 B091 0000 		lds r27,gEepromIndex+3
 1157 01b4 9F5F      		subi r25,-1
 1158 01b6 AF4F      		sbci r26,-1
 1159 01b8 BF4F      		sbci r27,-1
 1160 01ba 8093 0000 		sts gEepromIndex,r24
 1161 01be 9093 0000 		sts gEepromIndex+1,r25
 1162 01c2 A093 0000 		sts gEepromIndex+2,r26
 1163 01c6 B093 0000 		sts gEepromIndex+3,r27
2125:stk500boot.c  **** 				if (gEepromIndex > E2END)
 1164               		.loc 1 2125 0
 1165 01ca 8115      		cp r24,__zero_reg__
 1166 01cc 9041      		sbci r25,16
 1167 01ce A105      		cpc r26,__zero_reg__
 1168 01d0 B105      		cpc r27,__zero_reg__
 1169 01d2 00F4      		brsh .+2
 1170 01d4 00C0      		rjmp .L60
 1171 01d6 00C0      		rjmp .L273
 1172               	.L63:
2097:stk500boot.c  **** 		{
 1173               		.loc 1 2097 0
 1174 01d8 1135      		cpi r17,lo8(81)
 1175 01da 01F4      		brne .+2
 1176 01dc 00C0      		rjmp .L70
 1177 01de 00F4      		brsh .L71
 1178 01e0 1834      		cpi r17,lo8(72)
 1179 01e2 01F4      		brne .+2
 1180 01e4 00C0      		rjmp .L72
 1181 01e6 1C34      		cpi r17,lo8(76)
 1182 01e8 01F0      		breq .+2
 1183 01ea 00C0      		rjmp .L61
2126:stk500boot.c  **** 				{
2127:stk500boot.c  **** 					gEepromIndex	=	0;
2128:stk500boot.c  **** 				}
2129:stk500boot.c  **** 				break;
2130:stk500boot.c  **** 		
2131:stk500boot.c  **** 			case 'F':
2132:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 2);
2133:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
2134:stk500boot.c  **** 				gFlashIndex	+=	256;
2135:stk500boot.c  **** 				break;
2136:stk500boot.c  **** 
2137:stk500boot.c  **** 			case 'H':
2138:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 2);
2139:stk500boot.c  **** 				PrintHelp();
2140:stk500boot.c  **** 				break;
2141:stk500boot.c  **** 
2142:stk500boot.c  **** 			case 'L':
2143:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 2);
 1184               		.loc 1 2143 0
 1185 01ec 62E0      		ldi r22,lo8(2)
 1186 01ee 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1187 01f0 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1188 01f2 0E94 0000 		call PrintFromPROGMEMln
 1189               	.LVL103:
 1190               	.LBB189:
 1191               	.LBB190:
1813:stk500boot.c  **** #endif
 1192               		.loc 1 1813 0
 1193 01f6 81E4      		ldi r24,lo8(65)
 1194 01f8 0E94 0000 		call PrintAvailablePort
 1195               	.LVL104:
1817:stk500boot.c  **** #endif
 1196               		.loc 1 1817 0
 1197 01fc 82E4      		ldi r24,lo8(66)
 1198 01fe 0E94 0000 		call PrintAvailablePort
 1199               	.LVL105:
1821:stk500boot.c  **** #endif
 1200               		.loc 1 1821 0
 1201 0202 83E4      		ldi r24,lo8(67)
 1202 0204 0E94 0000 		call PrintAvailablePort
 1203               	.LVL106:
1825:stk500boot.c  **** #endif
 1204               		.loc 1 1825 0
 1205 0208 84E4      		ldi r24,lo8(68)
 1206 020a 0E94 0000 		call PrintAvailablePort
 1207               	.LVL107:
1829:stk500boot.c  **** #endif
 1208               		.loc 1 1829 0
 1209 020e 85E4      		ldi r24,lo8(69)
 1210 0210 0E94 0000 		call PrintAvailablePort
 1211               	.LVL108:
1833:stk500boot.c  **** #endif
 1212               		.loc 1 1833 0
 1213 0214 86E4      		ldi r24,lo8(70)
 1214 0216 0E94 0000 		call PrintAvailablePort
 1215               	.LVL109:
1837:stk500boot.c  **** #endif
 1216               		.loc 1 1837 0
 1217 021a 87E4      		ldi r24,lo8(71)
 1218 021c 0E94 0000 		call PrintAvailablePort
 1219               	.LVL110:
1841:stk500boot.c  **** #endif
 1220               		.loc 1 1841 0
 1221 0220 88E4      		ldi r24,lo8(72)
 1222 0222 0E94 0000 		call PrintAvailablePort
 1223               	.LVL111:
1849:stk500boot.c  **** #endif
 1224               		.loc 1 1849 0
 1225 0226 8AE4      		ldi r24,lo8(74)
 1226 0228 0E94 0000 		call PrintAvailablePort
 1227               	.LVL112:
1853:stk500boot.c  **** #endif
 1228               		.loc 1 1853 0
 1229 022c 8BE4      		ldi r24,lo8(75)
 1230 022e 0E94 0000 		call PrintAvailablePort
 1231               	.LVL113:
1857:stk500boot.c  **** #endif
 1232               		.loc 1 1857 0
 1233 0232 8CE4      		ldi r24,lo8(76)
 1234 0234 0E94 0000 		call PrintAvailablePort
 1235               	.LVL114:
 1236 0238 00C0      		rjmp .L60
 1237               	.L71:
 1238               	.LBE190:
 1239               	.LBE189:
2097:stk500boot.c  **** 		{
 1240               		.loc 1 2097 0
 1241 023a 1635      		cpi r17,lo8(86)
 1242 023c 01F4      		brne .+2
 1243 023e 00C0      		rjmp .L74
 1244 0240 1935      		cpi r17,lo8(89)
 1245 0242 01F4      		brne .+2
 1246 0244 00C0      		rjmp .L75
 1247 0246 1235      		cpi r17,lo8(82)
 1248 0248 01F0      		breq .+2
 1249 024a 00C0      		rjmp .L61
2144:stk500boot.c  **** 				ListAvailablePorts();
2145:stk500boot.c  **** 				break;
2146:stk500boot.c  **** 
2147:stk500boot.c  **** 			case 'Q':
2148:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 2);
2149:stk500boot.c  **** 				keepGoing	=	false;
2150:stk500boot.c  **** 				break;
2151:stk500boot.c  **** 
2152:stk500boot.c  **** 			case 'R':
2153:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 2);
 1250               		.loc 1 2153 0
 1251 024c 62E0      		ldi r22,lo8(2)
 1252 024e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1253 0250 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1254 0252 0E94 0000 		call PrintFromPROGMEMln
 1255               	.LVL115:
2154:stk500boot.c  **** 				DumpHex(kDUMP_RAM, gRamIndex, 16);
 1256               		.loc 1 2154 0
 1257 0256 4091 0000 		lds r20,gRamIndex
 1258 025a 5091 0000 		lds r21,gRamIndex+1
 1259 025e 6091 0000 		lds r22,gRamIndex+2
 1260 0262 7091 0000 		lds r23,gRamIndex+3
 1261 0266 82E0      		ldi r24,lo8(2)
 1262 0268 0E94 0000 		call DumpHex.constprop.0
 1263               	.LVL116:
2155:stk500boot.c  **** 				gRamIndex	+=	256;
 1264               		.loc 1 2155 0
 1265 026c 8091 0000 		lds r24,gRamIndex
 1266 0270 9091 0000 		lds r25,gRamIndex+1
 1267 0274 A091 0000 		lds r26,gRamIndex+2
 1268 0278 B091 0000 		lds r27,gRamIndex+3
 1269 027c 9F5F      		subi r25,-1
 1270 027e AF4F      		sbci r26,-1
 1271 0280 BF4F      		sbci r27,-1
 1272 0282 8093 0000 		sts gRamIndex,r24
 1273 0286 9093 0000 		sts gRamIndex+1,r25
 1274 028a A093 0000 		sts gRamIndex+2,r26
 1275 028e B093 0000 		sts gRamIndex+3,r27
 1276 0292 00C0      		rjmp .L60
 1277               	.L66:
2100:stk500boot.c  **** 				gFlashIndex		=	0;
 1278               		.loc 1 2100 0
 1279 0294 62E0      		ldi r22,lo8(2)
 1280 0296 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1281 0298 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1282 029a 0E94 0000 		call PrintFromPROGMEMln
 1283               	.LVL117:
2101:stk500boot.c  **** 				gRamIndex		=	0;
 1284               		.loc 1 2101 0
 1285 029e 1092 0000 		sts gFlashIndex,__zero_reg__
 1286 02a2 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1287 02a6 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1288 02aa 1092 0000 		sts gFlashIndex+3,__zero_reg__
2102:stk500boot.c  **** 				gEepromIndex	=	0;
 1289               		.loc 1 2102 0
 1290 02ae 1092 0000 		sts gRamIndex,__zero_reg__
 1291 02b2 1092 0000 		sts gRamIndex+1,__zero_reg__
 1292 02b6 1092 0000 		sts gRamIndex+2,__zero_reg__
 1293 02ba 1092 0000 		sts gRamIndex+3,__zero_reg__
 1294               	.LVL118:
 1295               	.L273:
 1296               	.LBB191:
 1297               	.LBB192:
1663:stk500boot.c  **** 
 1298               		.loc 1 1663 0
 1299 02be 1092 0000 		sts gEepromIndex,__zero_reg__
 1300 02c2 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1301 02c6 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1302 02ca 1092 0000 		sts gEepromIndex+3,__zero_reg__
 1303 02ce 00C0      		rjmp .L60
 1304               	.LVL119:
 1305               	.L67:
 1306               	.LBE192:
 1307               	.LBE191:
2107:stk500boot.c  **** 				PrintCPUstats();
 1308               		.loc 1 2107 0
 1309 02d0 62E0      		ldi r22,lo8(2)
 1310 02d2 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1311 02d4 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1312 02d6 0E94 0000 		call PrintFromPROGMEMln
 1313               	.LVL120:
 1314               	.LBB196:
 1315               	.LBB197:
1449:stk500boot.c  **** 
 1316               		.loc 1 1449 0
 1317 02da 60E0      		ldi r22,0
 1318 02dc 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1319 02de 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1320 02e0 0E94 0000 		call PrintFromPROGMEMln
 1321               	.LVL121:
1451:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
 1322               		.loc 1 1451 0
 1323 02e4 60E0      		ldi r22,0
 1324 02e6 80E0      		ldi r24,lo8(gTextMsg_COMPILED_ON)
 1325 02e8 90E0      		ldi r25,hi8(gTextMsg_COMPILED_ON)
 1326 02ea 0E94 0000 		call PrintFromPROGMEM
 1327               	.LVL122:
1452:stk500boot.c  **** 
 1328               		.loc 1 1452 0
 1329 02ee 60E0      		ldi r22,0
 1330 02f0 80E0      		ldi r24,lo8(gTextMsg_GCC_DATE_STR)
 1331 02f2 90E0      		ldi r25,hi8(gTextMsg_GCC_DATE_STR)
 1332 02f4 0E94 0000 		call PrintFromPROGMEMln
 1333               	.LVL123:
1454:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1334               		.loc 1 1454 0
 1335 02f8 60E0      		ldi r22,0
 1336 02fa 80E0      		ldi r24,lo8(gTextMsg_CPU_Type)
 1337 02fc 90E0      		ldi r25,hi8(gTextMsg_CPU_Type)
 1338 02fe 0E94 0000 		call PrintFromPROGMEM
 1339               	.LVL124:
1455:stk500boot.c  **** 
 1340               		.loc 1 1455 0
 1341 0302 60E0      		ldi r22,0
 1342 0304 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1343 0306 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1344 0308 0E94 0000 		call PrintFromPROGMEMln
 1345               	.LVL125:
1457:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
 1346               		.loc 1 1457 0
 1347 030c 60E0      		ldi r22,0
 1348 030e 80E0      		ldi r24,lo8(gTextMsg_AVR_ARCH)
 1349 0310 90E0      		ldi r25,hi8(gTextMsg_AVR_ARCH)
 1350 0312 0E94 0000 		call PrintFromPROGMEM
 1351               	.LVL126:
 1352               	.LBB198:
 1353               	.LBB199:
1438:stk500boot.c  **** }
 1354               		.loc 1 1438 0
 1355 0316 86E3      		ldi r24,lo8(54)
 1356 0318 0E94 0000 		call sendchar
 1357               	.LVL127:
 1358               	.LBE199:
 1359               	.LBE198:
1459:stk500boot.c  **** 
 1360               		.loc 1 1459 0
 1361 031c 0E94 0000 		call PrintNewLine
 1362               	.LVL128:
1461:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
 1363               		.loc 1 1461 0
 1364 0320 60E0      		ldi r22,0
 1365 0322 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION)
 1366 0324 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION)
 1367 0326 0E94 0000 		call PrintFromPROGMEM
 1368               	.LVL129:
1462:stk500boot.c  **** 
 1369               		.loc 1 1462 0
 1370 032a 60E0      		ldi r22,0
 1371 032c 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION_STR)
 1372 032e 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION_STR)
 1373 0330 0E94 0000 		call PrintFromPROGMEMln
 1374               	.LVL130:
1465:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
 1375               		.loc 1 1465 0
 1376 0334 60E0      		ldi r22,0
 1377 0336 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC)
 1378 0338 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC)
 1379 033a 0E94 0000 		call PrintFromPROGMEM
 1380               	.LVL131:
1466:stk500boot.c  **** 
 1381               		.loc 1 1466 0
 1382 033e 60E0      		ldi r22,0
 1383 0340 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC_VER_STR)
 1384 0342 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC_VER_STR)
 1385 0344 0E94 0000 		call PrintFromPROGMEMln
 1386               	.LVL132:
1469:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
 1387               		.loc 1 1469 0
 1388 0348 60E0      		ldi r22,0
 1389 034a 80E0      		ldi r24,lo8(gTextMsg_CPU_SIGNATURE)
 1390 034c 90E0      		ldi r25,hi8(gTextMsg_CPU_SIGNATURE)
 1391 034e 0E94 0000 		call PrintFromPROGMEM
 1392               	.LVL133:
1471:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
 1393               		.loc 1 1471 0
 1394 0352 8EE1      		ldi r24,lo8(30)
 1395 0354 0E94 0000 		call PrintHexByte
 1396               	.LVL134:
1472:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
 1397               		.loc 1 1472 0
 1398 0358 88E9      		ldi r24,lo8(-104)
 1399 035a 0E94 0000 		call PrintHexByte
 1400               	.LVL135:
1473:stk500boot.c  **** 	PrintNewLine();
 1401               		.loc 1 1473 0
 1402 035e 81E0      		ldi r24,lo8(1)
 1403 0360 0E94 0000 		call PrintHexByte
 1404               	.LVL136:
1474:stk500boot.c  **** #endif
 1405               		.loc 1 1474 0
 1406 0364 0E94 0000 		call PrintNewLine
 1407               	.LVL137:
1480:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1408               		.loc 1 1480 0
 1409 0368 60E0      		ldi r22,0
 1410 036a 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOW)
 1411 036c 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOW)
 1412 036e 0E94 0000 		call PrintFromPROGMEM
 1413               	.LVL138:
 1414               	.LBB200:
1481:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1415               		.loc 1 1481 0
 1416 0372 29E0      		ldi r18,lo8(9)
 1417 0374 F0E0      		ldi r31,0
 1418 0376 E0E0      		ldi r30,0
 1419               	/* #APP */
 1420               	 ;  1481 "stk500boot.c" 1
 1421 0378 2093 5700 		sts 87, r18
 1422 037c 8491      		lpm r24, Z
 1423               		
 1424               	 ;  0 "" 2
 1425               	.LVL139:
 1426               	/* #NOAPP */
 1427               	.LBE200:
1482:stk500boot.c  **** 	PrintNewLine();
 1428               		.loc 1 1482 0
 1429 037e 0E94 0000 		call PrintHexByte
 1430               	.LVL140:
1483:stk500boot.c  **** 
 1431               		.loc 1 1483 0
 1432 0382 0E94 0000 		call PrintNewLine
 1433               	.LVL141:
1485:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1434               		.loc 1 1485 0
 1435 0386 60E0      		ldi r22,0
 1436 0388 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_HIGH)
 1437 038a 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_HIGH)
 1438 038c 0E94 0000 		call PrintFromPROGMEM
 1439               	.LVL142:
 1440               	.LBB201:
1486:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1441               		.loc 1 1486 0
 1442 0390 29E0      		ldi r18,lo8(9)
 1443 0392 E3E0      		ldi r30,lo8(3)
 1444 0394 F0E0      		ldi r31,0
 1445               	/* #APP */
 1446               	 ;  1486 "stk500boot.c" 1
 1447 0396 2093 5700 		sts 87, r18
 1448 039a 8491      		lpm r24, Z
 1449               		
 1450               	 ;  0 "" 2
 1451               	.LVL143:
 1452               	/* #NOAPP */
 1453               	.LBE201:
1487:stk500boot.c  **** 	PrintNewLine();
 1454               		.loc 1 1487 0
 1455 039c 0E94 0000 		call PrintHexByte
 1456               	.LVL144:
1488:stk500boot.c  **** 
 1457               		.loc 1 1488 0
 1458 03a0 0E94 0000 		call PrintNewLine
 1459               	.LVL145:
1490:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 1460               		.loc 1 1490 0
 1461 03a4 60E0      		ldi r22,0
 1462 03a6 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_EXT)
 1463 03a8 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_EXT)
 1464 03aa 0E94 0000 		call PrintFromPROGMEM
 1465               	.LVL146:
 1466               	.LBB202:
1491:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1467               		.loc 1 1491 0
 1468 03ae E2E0      		ldi r30,lo8(2)
 1469 03b0 F0E0      		ldi r31,0
 1470 03b2 39E0      		ldi r19,lo8(9)
 1471               	/* #APP */
 1472               	 ;  1491 "stk500boot.c" 1
 1473 03b4 3093 5700 		sts 87, r19
 1474 03b8 8491      		lpm r24, Z
 1475               		
 1476               	 ;  0 "" 2
 1477               	.LVL147:
 1478               	/* #NOAPP */
 1479               	.LBE202:
1492:stk500boot.c  **** 	PrintNewLine();
 1480               		.loc 1 1492 0
 1481 03ba 0E94 0000 		call PrintHexByte
 1482               	.LVL148:
1493:stk500boot.c  **** 
 1483               		.loc 1 1493 0
 1484 03be 0E94 0000 		call PrintNewLine
 1485               	.LVL149:
1495:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
 1486               		.loc 1 1495 0
 1487 03c2 60E0      		ldi r22,0
 1488 03c4 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOCK)
 1489 03c6 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOCK)
 1490 03c8 0E94 0000 		call PrintFromPROGMEM
 1491               	.LVL150:
 1492               	.LBB203:
1496:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1493               		.loc 1 1496 0
 1494 03cc E1E0      		ldi r30,lo8(1)
 1495 03ce F0E0      		ldi r31,0
 1496 03d0 49E0      		ldi r20,lo8(9)
 1497               	/* #APP */
 1498               	 ;  1496 "stk500boot.c" 1
 1499 03d2 4093 5700 		sts 87, r20
 1500 03d6 8491      		lpm r24, Z
 1501               		
 1502               	 ;  0 "" 2
 1503               	.LVL151:
 1504               	/* #NOAPP */
 1505               	.LBE203:
1497:stk500boot.c  **** 	PrintNewLine();
 1506               		.loc 1 1497 0
 1507 03d8 0E94 0000 		call PrintHexByte
 1508               	.LVL152:
1498:stk500boot.c  **** 
 1509               		.loc 1 1498 0
 1510 03dc 0E94 0000 		call PrintNewLine
 1511               	.LVL153:
 1512 03e0 00C0      		rjmp .L60
 1513               	.LVL154:
 1514               	.L64:
 1515               	.LBE197:
 1516               	.LBE196:
2112:stk500boot.c  **** 				EEPROMtest();
 1517               		.loc 1 2112 0
 1518 03e2 62E0      		ldi r22,lo8(2)
 1519 03e4 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1520 03e6 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1521 03e8 0E94 0000 		call PrintFromPROGMEMln
 1522               	.LVL155:
 1523               	.LBB204:
 1524               	.LBB195:
1607:stk500boot.c  **** 	PrintNewLine();
 1525               		.loc 1 1607 0
 1526 03ec 60E0      		ldi r22,0
 1527 03ee 80E0      		ldi r24,lo8(gTextMsg_WriteToEEprom)
 1528 03f0 90E0      		ldi r25,hi8(gTextMsg_WriteToEEprom)
 1529 03f2 0E94 0000 		call PrintFromPROGMEMln
 1530               	.LVL156:
1608:stk500boot.c  **** 	ii			=	0;
 1531               		.loc 1 1608 0
 1532 03f6 0E94 0000 		call PrintNewLine
 1533               	.LVL157:
1609:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1534               		.loc 1 1609 0
 1535 03fa F12C      		mov r15,__zero_reg__
 1536 03fc E12C      		mov r14,__zero_reg__
 1537               	.LVL158:
 1538               	.L78:
 1539               	.LBB193:
1611:stk500boot.c  **** #else
 1540               		.loc 1 1611 0
 1541 03fe C701      		movw r24,r14
 1542 0400 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1543 0402 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1544 0404 B0E0      		ldi r27,0
 1545 0406 A0E0      		ldi r26,0
 1546               	/* #APP */
 1547               	 ;  1611 "stk500boot.c" 1
 1548 0408 ABBF      		out 59, r26
 1549 040a FC01      		movw r30, r24
 1550 040c 1791      		elpm r17, Z+
 1551               		
 1552               	 ;  0 "" 2
 1553               	.LVL159:
 1554               	/* #NOAPP */
 1555               	.LBE193:
 1556 040e 1A32      		cpi r17,lo8(42)
 1557 0410 01F0      		breq .L81
 1558 0412 E114      		cp r14,__zero_reg__
 1559 0414 82E0      		ldi r24,2
 1560 0416 F806      		cpc r15,r24
 1561 0418 01F4      		brne .L82
 1562               	.L81:
1629:stk500boot.c  **** 	PrintNewLine();
 1563               		.loc 1 1629 0
 1564 041a 0E94 0000 		call PrintNewLine
 1565               	.LVL160:
1630:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
 1566               		.loc 1 1630 0
 1567 041e 0E94 0000 		call PrintNewLine
 1568               	.LVL161:
1631:stk500boot.c  **** 	PrintNewLine();
 1569               		.loc 1 1631 0
 1570 0422 60E0      		ldi r22,0
 1571 0424 80E0      		ldi r24,lo8(gTextMsg_ReadingEEprom)
 1572 0426 90E0      		ldi r25,hi8(gTextMsg_ReadingEEprom)
 1573 0428 0E94 0000 		call PrintFromPROGMEMln
 1574               	.LVL162:
1632:stk500boot.c  **** 	errorCount	=	0;
 1575               		.loc 1 1632 0
 1576 042c 0E94 0000 		call PrintNewLine
 1577               	.LVL163:
1633:stk500boot.c  **** 	ii			=	0;
 1578               		.loc 1 1633 0
 1579 0430 D12C      		mov r13,__zero_reg__
 1580 0432 C12C      		mov r12,__zero_reg__
1634:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1581               		.loc 1 1634 0
 1582 0434 F12C      		mov r15,__zero_reg__
 1583 0436 E12C      		mov r14,__zero_reg__
 1584               	.LVL164:
 1585               	.L83:
 1586               	.LBB194:
1636:stk500boot.c  **** #else
 1587               		.loc 1 1636 0
 1588 0438 C701      		movw r24,r14
 1589 043a 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1590 043c 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1591 043e B0E0      		ldi r27,0
 1592 0440 A0E0      		ldi r26,0
 1593               	/* #APP */
 1594               	 ;  1636 "stk500boot.c" 1
 1595 0442 ABBF      		out 59, r26
 1596 0444 FC01      		movw r30, r24
 1597 0446 1791      		elpm r17, Z+
 1598               		
 1599               	 ;  0 "" 2
 1600               	.LVL165:
 1601               	/* #NOAPP */
 1602               	.LBE194:
 1603 0448 1A32      		cpi r17,lo8(42)
 1604 044a 01F0      		breq .L87
 1605 044c E114      		cp r14,__zero_reg__
 1606 044e B2E0      		ldi r27,2
 1607 0450 FB06      		cpc r15,r27
 1608 0452 01F4      		brne .L88
 1609               	.L87:
1656:stk500boot.c  **** 	PrintNewLine();
 1610               		.loc 1 1656 0
 1611 0454 0E94 0000 		call PrintNewLine
 1612               	.LVL166:
1657:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
 1613               		.loc 1 1657 0
 1614 0458 0E94 0000 		call PrintNewLine
 1615               	.LVL167:
1658:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
 1616               		.loc 1 1658 0
 1617 045c 60E0      		ldi r22,0
 1618 045e 80E0      		ldi r24,lo8(gTextMsg_EEPROMerrorCnt)
 1619 0460 90E0      		ldi r25,hi8(gTextMsg_EEPROMerrorCnt)
 1620 0462 0E94 0000 		call PrintFromPROGMEM
 1621               	.LVL168:
1659:stk500boot.c  **** 	PrintNewLine();
 1622               		.loc 1 1659 0
 1623 0466 61E0      		ldi r22,lo8(1)
 1624 0468 70E0      		ldi r23,0
 1625 046a C601      		movw r24,r12
 1626 046c 0E94 0000 		call PrintDecInt
 1627               	.LVL169:
1660:stk500boot.c  **** 	PrintNewLine();
 1628               		.loc 1 1660 0
 1629 0470 0E94 0000 		call PrintNewLine
 1630               	.LVL170:
1661:stk500boot.c  **** 
 1631               		.loc 1 1661 0
 1632 0474 0E94 0000 		call PrintNewLine
 1633               	.LVL171:
 1634 0478 00C0      		rjmp .L273
 1635               	.LVL172:
 1636               	.L82:
1616:stk500boot.c  **** 		if (theChar == 0)
 1637               		.loc 1 1616 0
 1638 047a 612F      		mov r22,r17
 1639 047c C701      		movw r24,r14
 1640 047e 0E94 0000 		call eeprom_write_byte
 1641               	.LVL173:
1617:stk500boot.c  **** 		{
 1642               		.loc 1 1617 0
 1643 0482 1111      		cpse r17,__zero_reg__
 1644 0484 00C0      		rjmp .L79
1619:stk500boot.c  **** 		}
 1645               		.loc 1 1619 0
 1646 0486 60E0      		ldi r22,0
 1647 0488 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1648 048a 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1649 048c 0E94 0000 		call PrintFromPROGMEM
 1650               	.LVL174:
 1651               	.L80:
1625:stk500boot.c  **** 	}
 1652               		.loc 1 1625 0
 1653 0490 5FEF      		ldi r21,-1
 1654 0492 E51A      		sub r14,r21
 1655 0494 F50A      		sbc r15,r21
 1656               	.LVL175:
 1657 0496 00C0      		rjmp .L78
 1658               	.LVL176:
 1659               	.L79:
1623:stk500boot.c  **** 		}
 1660               		.loc 1 1623 0
 1661 0498 812F      		mov r24,r17
 1662 049a 0E94 0000 		call sendchar
 1663               	.LVL177:
 1664 049e 00C0      		rjmp .L80
 1665               	.LVL178:
 1666               	.L88:
1641:stk500boot.c  **** 		if (theEEPROMchar == 0)
 1667               		.loc 1 1641 0
 1668 04a0 C701      		movw r24,r14
 1669 04a2 0E94 0000 		call eeprom_read_byte
 1670               	.LVL179:
 1671 04a6 B82E      		mov r11,r24
 1672               	.LVL180:
1642:stk500boot.c  **** 		{
 1673               		.loc 1 1642 0
 1674 04a8 8111      		cpse r24,__zero_reg__
 1675 04aa 00C0      		rjmp .L84
1644:stk500boot.c  **** 		}
 1676               		.loc 1 1644 0
 1677 04ac 60E0      		ldi r22,0
 1678 04ae 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1679 04b0 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1680 04b2 0E94 0000 		call PrintFromPROGMEM
 1681               	.LVL181:
 1682               	.L85:
1650:stk500boot.c  **** 		{
 1683               		.loc 1 1650 0
 1684 04b6 B116      		cp r11,r17
 1685 04b8 01F0      		breq .L86
1652:stk500boot.c  **** 		}
 1686               		.loc 1 1652 0
 1687 04ba 9FEF      		ldi r25,-1
 1688 04bc C91A      		sub r12,r25
 1689 04be D90A      		sbc r13,r25
 1690               	.LVL182:
 1691               	.L86:
1654:stk500boot.c  **** 	}
 1692               		.loc 1 1654 0
 1693 04c0 AFEF      		ldi r26,-1
 1694 04c2 EA1A      		sub r14,r26
 1695 04c4 FA0A      		sbc r15,r26
 1696               	.LVL183:
 1697 04c6 00C0      		rjmp .L83
 1698               	.LVL184:
 1699               	.L84:
1648:stk500boot.c  **** 		}
 1700               		.loc 1 1648 0
 1701 04c8 0E94 0000 		call sendchar
 1702               	.LVL185:
 1703 04cc 00C0      		rjmp .L85
 1704               	.LVL186:
 1705               	.L68:
 1706               	.LBE195:
 1707               	.LBE204:
2117:stk500boot.c  **** 				BlinkLED();
 1708               		.loc 1 2117 0
 1709 04ce 62E0      		ldi r22,lo8(2)
 1710 04d0 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1711 04d2 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1712 04d4 0E94 0000 		call PrintFromPROGMEMln
 1713               	.LVL187:
 1714               	.LBB205:
 1715               	.LBB206:
1508:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 1716               		.loc 1 1508 0
 1717 04d8 279A      		sbi 0x4,7
1509:stk500boot.c  **** 
 1718               		.loc 1 1509 0
 1719 04da 2F9A      		sbi 0x5,7
 1720               	.L89:
 1721               	.LBB207:
 1722               	.LBB208:
 477:stk500boot.c  **** }
 1723               		.loc 1 477 0
 1724 04dc 8091 C000 		lds r24,192
 1725               	.LBE208:
 1726               	.LBE207:
1511:stk500boot.c  **** 	{
 1727               		.loc 1 1511 0
 1728 04e0 87FF      		sbrs r24,7
 1729 04e2 00C0      		rjmp .L90
 1730               	.LVL188:
 1731               	.L116:
1518:stk500boot.c  **** }
 1732               		.loc 1 1518 0
 1733 04e4 0E94 0000 		call recchar
 1734               	.LVL189:
 1735 04e8 00C0      		rjmp .L60
 1736               	.LVL190:
 1737               	.L90:
1513:stk500boot.c  **** 		delay_ms(100);
 1738               		.loc 1 1513 0
 1739 04ea 2F98      		cbi 0x5,7
1514:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 1740               		.loc 1 1514 0
 1741 04ec 84E6      		ldi r24,lo8(100)
 1742 04ee 90E0      		ldi r25,0
 1743 04f0 0E94 0000 		call delay_ms
 1744               	.LVL191:
1515:stk500boot.c  **** 		delay_ms(100);
 1745               		.loc 1 1515 0
 1746 04f4 2F9A      		sbi 0x5,7
1516:stk500boot.c  **** 	}
 1747               		.loc 1 1516 0
 1748 04f6 84E6      		ldi r24,lo8(100)
 1749 04f8 90E0      		ldi r25,0
 1750 04fa 0E94 0000 		call delay_ms
 1751               	.LVL192:
 1752 04fe 00C0      		rjmp .L89
 1753               	.L62:
 1754               	.LBE206:
 1755               	.LBE205:
2132:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
 1756               		.loc 1 2132 0
 1757 0500 62E0      		ldi r22,lo8(2)
 1758 0502 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1759 0504 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1760 0506 0E94 0000 		call PrintFromPROGMEMln
 1761               	.LVL193:
2133:stk500boot.c  **** 				gFlashIndex	+=	256;
 1762               		.loc 1 2133 0
 1763 050a 4091 0000 		lds r20,gFlashIndex
 1764 050e 5091 0000 		lds r21,gFlashIndex+1
 1765 0512 6091 0000 		lds r22,gFlashIndex+2
 1766 0516 7091 0000 		lds r23,gFlashIndex+3
 1767 051a 80E0      		ldi r24,0
 1768 051c 0E94 0000 		call DumpHex.constprop.0
 1769               	.LVL194:
2134:stk500boot.c  **** 				break;
 1770               		.loc 1 2134 0
 1771 0520 8091 0000 		lds r24,gFlashIndex
 1772 0524 9091 0000 		lds r25,gFlashIndex+1
 1773 0528 A091 0000 		lds r26,gFlashIndex+2
 1774 052c B091 0000 		lds r27,gFlashIndex+3
 1775 0530 9F5F      		subi r25,-1
 1776 0532 AF4F      		sbci r26,-1
 1777 0534 BF4F      		sbci r27,-1
 1778 0536 8093 0000 		sts gFlashIndex,r24
 1779 053a 9093 0000 		sts gFlashIndex+1,r25
 1780 053e A093 0000 		sts gFlashIndex+2,r26
 1781 0542 B093 0000 		sts gFlashIndex+3,r27
 1782 0546 00C0      		rjmp .L60
 1783               	.L72:
2138:stk500boot.c  **** 				PrintHelp();
 1784               		.loc 1 2138 0
 1785 0548 62E0      		ldi r22,lo8(2)
 1786 054a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1787 054c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1788 054e 0E94 0000 		call PrintFromPROGMEMln
 1789               	.LVL195:
 1790               	.LBB209:
 1791               	.LBB210:
2044:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
 1792               		.loc 1 2044 0
 1793 0552 60E0      		ldi r22,0
 1794 0554 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1795 0556 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1796 0558 0E94 0000 		call PrintFromPROGMEMln
 1797               	.LVL196:
2045:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
 1798               		.loc 1 2045 0
 1799 055c 60E0      		ldi r22,0
 1800 055e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1801 0560 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1802 0562 0E94 0000 		call PrintFromPROGMEMln
 1803               	.LVL197:
2046:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
 1804               		.loc 1 2046 0
 1805 0566 60E0      		ldi r22,0
 1806 0568 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1807 056a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1808 056c 0E94 0000 		call PrintFromPROGMEMln
 1809               	.LVL198:
2047:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
 1810               		.loc 1 2047 0
 1811 0570 60E0      		ldi r22,0
 1812 0572 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1813 0574 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1814 0576 0E94 0000 		call PrintFromPROGMEMln
 1815               	.LVL199:
2048:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
 1816               		.loc 1 2048 0
 1817 057a 60E0      		ldi r22,0
 1818 057c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1819 057e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1820 0580 0E94 0000 		call PrintFromPROGMEMln
 1821               	.LVL200:
2049:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
 1822               		.loc 1 2049 0
 1823 0584 60E0      		ldi r22,0
 1824 0586 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1825 0588 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1826 058a 0E94 0000 		call PrintFromPROGMEMln
 1827               	.LVL201:
2050:stk500boot.c  **** 
 1828               		.loc 1 2050 0
 1829 058e 60E0      		ldi r22,0
 1830 0590 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1831 0592 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1832 0594 0E94 0000 		call PrintFromPROGMEMln
 1833               	.LVL202:
2052:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
 1834               		.loc 1 2052 0
 1835 0598 60E0      		ldi r22,0
 1836 059a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1837 059c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1838 059e 0E94 0000 		call PrintFromPROGMEMln
 1839               	.LVL203:
2053:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
 1840               		.loc 1 2053 0
 1841 05a2 60E0      		ldi r22,0
 1842 05a4 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1843 05a6 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1844 05a8 0E94 0000 		call PrintFromPROGMEMln
 1845               	.LVL204:
2054:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
 1846               		.loc 1 2054 0
 1847 05ac 60E0      		ldi r22,0
 1848 05ae 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1849 05b0 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1850 05b2 0E94 0000 		call PrintFromPROGMEMln
 1851               	.LVL205:
2055:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
 1852               		.loc 1 2055 0
 1853 05b6 60E0      		ldi r22,0
 1854 05b8 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1855 05ba 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1856 05bc 0E94 0000 		call PrintFromPROGMEMln
 1857               	.LVL206:
2056:stk500boot.c  **** }
 1858               		.loc 1 2056 0
 1859 05c0 60E0      		ldi r22,0
 1860 05c2 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 1861 05c4 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 1862               	.LVL207:
 1863               	.L272:
 1864               	.LBE210:
 1865               	.LBE209:
2156:stk500boot.c  **** 				break;
2157:stk500boot.c  **** 
2158:stk500boot.c  **** 			case 'V':
2159:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 2);
2160:stk500boot.c  **** 				VectorDisplay();
2161:stk500boot.c  **** 				break;
2162:stk500boot.c  **** 
2163:stk500boot.c  **** 			case 'Y':
2164:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 2);
2165:stk500boot.c  **** 				AVR_PortOutput();
2166:stk500boot.c  **** 				break;
2167:stk500boot.c  **** 			
2168:stk500boot.c  **** 			default:
2169:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HUH, 0);
 1866               		.loc 1 2169 0
 1867 05c6 0E94 0000 		call PrintFromPROGMEMln
 1868               	.LVL208:
 1869 05ca 00C0      		rjmp .L60
 1870               	.LVL209:
 1871               	.L70:
2148:stk500boot.c  **** 				keepGoing	=	false;
 1872               		.loc 1 2148 0
 1873 05cc 62E0      		ldi r22,lo8(2)
 1874 05ce 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1875 05d0 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1876 05d2 0E94 0000 		call PrintFromPROGMEMln
 1877               	.LVL210:
 1878               	.LBE188:
 1879               	.LBE187:
 749:stk500boot.c  **** 						isLeave			=	1;
 1880               		.loc 1 749 0
 1881 05d6 F12C      		mov r15,__zero_reg__
 1882 05d8 E12C      		mov r14,__zero_reg__
 750:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 1883               		.loc 1 750 0
 1884 05da F1E0      		ldi r31,lo8(1)
 1885 05dc C25E      		subi r28,lo8(-286)
 1886 05de DE4F      		sbci r29,hi8(-286)
 1887 05e0 F883      		st Y,r31
 1888 05e2 CE51      		subi r28,lo8(286)
 1889 05e4 D140      		sbci r29,hi8(286)
 1890               	.LVL211:
 1891               	.L92:
 841:stk500boot.c  **** 			{
 1892               		.loc 1 841 0
 1893 05e6 2981      		ldd r18,Y+1
 1894 05e8 2331      		cpi r18,lo8(19)
 1895 05ea 01F4      		brne .+2
 1896 05ec 00C0      		rjmp .L151
 1897 05ee 00F0      		brlo .+2
 1898 05f0 00C0      		rjmp .L152
 1899 05f2 2630      		cpi r18,lo8(6)
 1900 05f4 01F4      		brne .+2
 1901 05f6 00C0      		rjmp .L153
 1902 05f8 00F0      		brlo .+2
 1903 05fa 00C0      		rjmp .L154
 1904 05fc 2230      		cpi r18,lo8(2)
 1905 05fe 01F4      		brne .+2
 1906 0600 00C0      		rjmp .L280
 1907 0602 2330      		cpi r18,lo8(3)
 1908 0604 01F4      		brne .+2
 1909 0606 00C0      		rjmp .L156
 1910 0608 2130      		cpi r18,lo8(1)
 1911 060a 01F0      		breq .+2
 1912 060c 00C0      		rjmp .L150
 1913               	.LVL212:
 905:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 1914               		.loc 1 905 0
 1915 060e 1A82      		std Y+2,__zero_reg__
 906:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 1916               		.loc 1 906 0
 1917 0610 88E0      		ldi r24,lo8(8)
 1918 0612 8B83      		std Y+3,r24
 907:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 1919               		.loc 1 907 0
 1920 0614 81E4      		ldi r24,lo8(65)
 1921 0616 8C83      		std Y+4,r24
 908:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 1922               		.loc 1 908 0
 1923 0618 86E5      		ldi r24,lo8(86)
 1924 061a 8D83      		std Y+5,r24
 909:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 1925               		.loc 1 909 0
 1926 061c 82E5      		ldi r24,lo8(82)
 1927 061e 8E83      		std Y+6,r24
 910:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 1928               		.loc 1 910 0
 1929 0620 89E4      		ldi r24,lo8(73)
 1930 0622 8F83      		std Y+7,r24
 911:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 1931               		.loc 1 911 0
 1932 0624 83E5      		ldi r24,lo8(83)
 1933 0626 8887      		std Y+8,r24
 912:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 1934               		.loc 1 912 0
 1935 0628 80E5      		ldi r24,lo8(80)
 1936 062a 8987      		std Y+9,r24
 913:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 1937               		.loc 1 913 0
 1938 062c 8FE5      		ldi r24,lo8(95)
 1939 062e 8A87      		std Y+10,r24
 914:stk500boot.c  **** 					break;
 1940               		.loc 1 914 0
 1941 0630 82E3      		ldi r24,lo8(50)
 1942 0632 8B87      		std Y+11,r24
 904:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 1943               		.loc 1 904 0
 1944 0634 0BE0      		ldi r16,lo8(11)
 1945 0636 10E0      		ldi r17,0
 915:stk500boot.c  **** 
 1946               		.loc 1 915 0
 1947 0638 00C0      		rjmp .L170
 1948               	.LVL213:
 1949               	.L74:
 1950               	.LBB247:
 1951               	.LBB245:
2159:stk500boot.c  **** 				VectorDisplay();
 1952               		.loc 1 2159 0
 1953 063a 62E0      		ldi r22,lo8(2)
 1954 063c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1955 063e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1956 0640 0E94 0000 		call PrintFromPROGMEMln
 1957               	.LVL214:
 1958               	.LBB211:
 1959               	.LBB212:
1699:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
 1960               		.loc 1 1699 0
 1961 0644 60E0      		ldi r22,0
 1962 0646 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1963 0648 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1964 064a 0E94 0000 		call PrintFromPROGMEMln
 1965               	.LVL215:
1700:stk500boot.c  **** 	//					 V#   ADDR   op code
 1966               		.loc 1 1700 0
 1967 064e 60E0      		ldi r22,0
 1968 0650 80E0      		ldi r24,lo8(gTextMsg_VECTOR_HEADER)
 1969 0652 90E0      		ldi r25,hi8(gTextMsg_VECTOR_HEADER)
 1970 0654 0E94 0000 		call PrintFromPROGMEMln
 1971               	.LVL216:
1698:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1972               		.loc 1 1698 0
 1973 0658 C75D      		subi r28,lo8(-297)
 1974 065a DE4F      		sbci r29,hi8(-297)
 1975 065c 1982      		std Y+1,__zero_reg__
 1976 065e 1882      		st Y,__zero_reg__
 1977 0660 C952      		subi r28,lo8(297)
 1978 0662 D140      		sbci r29,hi8(297)
1697:stk500boot.c  **** 	vectorIndex		=	0;
 1979               		.loc 1 1697 0
 1980 0664 C25E      		subi r28,lo8(-286)
 1981 0666 DE4F      		sbci r29,hi8(-286)
 1982 0668 1882      		st Y,__zero_reg__
 1983 066a 1982      		std Y+1,__zero_reg__
 1984 066c 1A82      		std Y+2,__zero_reg__
 1985 066e 1B82      		std Y+3,__zero_reg__
 1986 0670 CE51      		subi r28,lo8(286)
 1987 0672 D140      		sbci r29,hi8(286)
 1988               	.LVL217:
 1989               	.L96:
1705:stk500boot.c  **** 		//					 01 - 0000 = 12 34
 1990               		.loc 1 1705 0
 1991 0674 C25E      		subi r28,lo8(-286)
 1992 0676 DE4F      		sbci r29,hi8(-286)
 1993 0678 2881      		ld r18,Y
 1994 067a 3981      		ldd r19,Y+1
 1995 067c 4A81      		ldd r20,Y+2
 1996 067e 5B81      		ldd r21,Y+3
 1997 0680 CE51      		subi r28,lo8(286)
 1998 0682 D140      		sbci r29,hi8(286)
 1999 0684 5695      		lsr r21
 2000 0686 4795      		ror r20
 2001 0688 3795      		ror r19
 2002 068a 2795      		ror r18
 2003 068c C35D      		subi r28,lo8(-301)
 2004 068e DE4F      		sbci r29,hi8(-301)
 2005 0690 2883      		st Y,r18
 2006 0692 3983      		std Y+1,r19
 2007 0694 4A83      		std Y+2,r20
 2008 0696 5B83      		std Y+3,r21
 2009 0698 CD52      		subi r28,lo8(301)
 2010 069a D140      		sbci r29,hi8(301)
 2011               	.LVL218:
1707:stk500boot.c  **** 		sendchar(0x20);
 2012               		.loc 1 1707 0
 2013 069c C75D      		subi r28,lo8(-297)
 2014 069e DE4F      		sbci r29,hi8(-297)
 2015 06a0 4881      		ld r20,Y
 2016 06a2 5981      		ldd r21,Y+1
 2017 06a4 C952      		subi r28,lo8(297)
 2018 06a6 D140      		sbci r29,hi8(297)
 2019 06a8 4F5F      		subi r20,-1
 2020 06aa 5F4F      		sbci r21,-1
 2021 06ac C75D      		subi r28,lo8(-297)
 2022 06ae DE4F      		sbci r29,hi8(-297)
 2023 06b0 5983      		std Y+1,r21
 2024 06b2 4883      		st Y,r20
 2025 06b4 C952      		subi r28,lo8(297)
 2026 06b6 D140      		sbci r29,hi8(297)
 2027               	.LVL219:
 2028 06b8 62E0      		ldi r22,lo8(2)
 2029 06ba 70E0      		ldi r23,0
 2030 06bc CA01      		movw r24,r20
 2031 06be 0E94 0000 		call PrintDecInt
 2032               	.LVL220:
1708:stk500boot.c  **** 		sendchar('-');
 2033               		.loc 1 1708 0
 2034 06c2 80E2      		ldi r24,lo8(32)
 2035 06c4 0E94 0000 		call sendchar
 2036               	.LVL221:
1709:stk500boot.c  **** 		sendchar(0x20);
 2037               		.loc 1 1709 0
 2038 06c8 8DE2      		ldi r24,lo8(45)
 2039 06ca 0E94 0000 		call sendchar
 2040               	.LVL222:
1710:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
 2041               		.loc 1 1710 0
 2042 06ce 80E2      		ldi r24,lo8(32)
 2043 06d0 0E94 0000 		call sendchar
 2044               	.LVL223:
1711:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
 2045               		.loc 1 1711 0
 2046 06d4 80E0      		ldi r24,0
 2047 06d6 0E94 0000 		call PrintHexByte
 2048               	.LVL224:
1712:stk500boot.c  **** 		sendchar(0x20);
 2049               		.loc 1 1712 0
 2050 06da C35D      		subi r28,lo8(-301)
 2051 06dc DE4F      		sbci r29,hi8(-301)
 2052 06de 8881      		ld r24,Y
 2053 06e0 CD52      		subi r28,lo8(301)
 2054 06e2 D140      		sbci r29,hi8(301)
 2055 06e4 0E94 0000 		call PrintHexByte
 2056               	.LVL225:
1713:stk500boot.c  **** 		sendchar('=');
 2057               		.loc 1 1713 0
 2058 06e8 80E2      		ldi r24,lo8(32)
 2059 06ea 0E94 0000 		call sendchar
 2060               	.LVL226:
1714:stk500boot.c  **** 		sendchar(0x20);
 2061               		.loc 1 1714 0
 2062 06ee 8DE3      		ldi r24,lo8(61)
 2063 06f0 0E94 0000 		call sendchar
 2064               	.LVL227:
1715:stk500boot.c  **** 
 2065               		.loc 1 1715 0
 2066 06f4 80E2      		ldi r24,lo8(32)
 2067 06f6 0E94 0000 		call sendchar
 2068               	.LVL228:
 2069               	.LBB213:
1720:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 2070               		.loc 1 1720 0
 2071 06fa C25E      		subi r28,lo8(-286)
 2072 06fc DE4F      		sbci r29,hi8(-286)
 2073 06fe 8881      		ld r24,Y
 2074 0700 9981      		ldd r25,Y+1
 2075 0702 AA81      		ldd r26,Y+2
 2076 0704 BB81      		ldd r27,Y+3
 2077 0706 CE51      		subi r28,lo8(286)
 2078 0708 D140      		sbci r29,hi8(286)
 2079               	/* #APP */
 2080               	 ;  1720 "stk500boot.c" 1
 2081 070a ABBF      		out 59, r26
 2082 070c FC01      		movw r30, r24
 2083 070e 9791      		elpm r25, Z+
 2084               		
 2085               	 ;  0 "" 2
 2086               	/* #NOAPP */
 2087 0710 CB5C      		subi r28,lo8(-309)
 2088 0712 DE4F      		sbci r29,hi8(-309)
 2089 0714 9883      		st Y,r25
 2090 0716 C553      		subi r28,lo8(309)
 2091 0718 D140      		sbci r29,hi8(309)
 2092               	.LVL229:
 2093               	.LBE213:
 2094 071a 892E      		mov r8,r25
 2095 071c 912C      		mov r9,__zero_reg__
 2096 071e B12C      		mov r11,__zero_reg__
 2097 0720 A12C      		mov r10,__zero_reg__
 2098               	.LVL230:
 2099               	.LBB214:
 2100 0722 C25E      		subi r28,lo8(-286)
 2101 0724 DE4F      		sbci r29,hi8(-286)
 2102 0726 8881      		ld r24,Y
 2103 0728 9981      		ldd r25,Y+1
 2104 072a AA81      		ldd r26,Y+2
 2105 072c BB81      		ldd r27,Y+3
 2106 072e CE51      		subi r28,lo8(286)
 2107 0730 D140      		sbci r29,hi8(286)
 2108 0732 0196      		adiw r24,1
 2109 0734 A11D      		adc r26,__zero_reg__
 2110 0736 B11D      		adc r27,__zero_reg__
 2111               	.LVL231:
 2112               	.LBE214:
 2113               	.LBB215:
1721:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2114               		.loc 1 1721 0
 2115               	/* #APP */
 2116               	 ;  1721 "stk500boot.c" 1
 2117 0738 ABBF      		out 59, r26
 2118 073a FC01      		movw r30, r24
 2119 073c 8791      		elpm r24, Z+
 2120               		
 2121               	 ;  0 "" 2
 2122               	.LVL232:
 2123               	/* #NOAPP */
 2124               	.LBE215:
 2125 073e 282F      		mov r18,r24
 2126 0740 30E0      		ldi r19,0
 2127 0742 50E0      		ldi r21,0
 2128 0744 40E0      		ldi r20,0
 2129 0746 CF5C      		subi r28,lo8(-305)
 2130 0748 DE4F      		sbci r29,hi8(-305)
 2131 074a 2883      		st Y,r18
 2132 074c 3983      		std Y+1,r19
 2133 074e 4A83      		std Y+2,r20
 2134 0750 5B83      		std Y+3,r21
 2135 0752 C153      		subi r28,lo8(305)
 2136 0754 D140      		sbci r29,hi8(305)
 2137               	.LVL233:
 2138               	.LBB216:
 2139 0756 C25E      		subi r28,lo8(-286)
 2140 0758 DE4F      		sbci r29,hi8(-286)
 2141 075a 4881      		ld r20,Y
 2142 075c 5981      		ldd r21,Y+1
 2143 075e 6A81      		ldd r22,Y+2
 2144 0760 7B81      		ldd r23,Y+3
 2145 0762 CE51      		subi r28,lo8(286)
 2146 0764 D140      		sbci r29,hi8(286)
 2147 0766 4E5F      		subi r20,-2
 2148 0768 5F4F      		sbci r21,-1
 2149 076a 6F4F      		sbci r22,-1
 2150 076c 7F4F      		sbci r23,-1
 2151               	.LVL234:
 2152               	.LBE216:
 2153               	.LBB217:
1722:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 2154               		.loc 1 1722 0
 2155               	/* #APP */
 2156               	 ;  1722 "stk500boot.c" 1
 2157 076e 6BBF      		out 59, r22
 2158 0770 FA01      		movw r30, r20
 2159 0772 3791      		elpm r19, Z+
 2160               		
 2161               	 ;  0 "" 2
 2162               	/* #NOAPP */
 2163 0774 CA5C      		subi r28,lo8(-310)
 2164 0776 DE4F      		sbci r29,hi8(-310)
 2165 0778 3883      		st Y,r19
 2166 077a C653      		subi r28,lo8(310)
 2167 077c D140      		sbci r29,hi8(310)
 2168               	.LVL235:
 2169               	.LBE217:
 2170               	.LBB218:
1723:stk500boot.c  **** 	#else
 2171               		.loc 1 1723 0
 2172 077e C25E      		subi r28,lo8(-286)
 2173 0780 DE4F      		sbci r29,hi8(-286)
 2174 0782 4881      		ld r20,Y
 2175 0784 5981      		ldd r21,Y+1
 2176 0786 6A81      		ldd r22,Y+2
 2177 0788 7B81      		ldd r23,Y+3
 2178 078a CE51      		subi r28,lo8(286)
 2179 078c D140      		sbci r29,hi8(286)
 2180               	.LVL236:
 2181 078e 4D5F      		subi r20,-3
 2182 0790 5F4F      		sbci r21,-1
 2183 0792 6F4F      		sbci r22,-1
 2184 0794 7F4F      		sbci r23,-1
 2185               	/* #APP */
 2186               	 ;  1723 "stk500boot.c" 1
 2187 0796 6BBF      		out 59, r22
 2188 0798 FA01      		movw r30, r20
 2189 079a 1791      		elpm r17, Z+
 2190               		
 2191               	 ;  0 "" 2
 2192               	/* #NOAPP */
 2193 079c C25E      		subi r28,lo8(-286)
 2194 079e DE4F      		sbci r29,hi8(-286)
 2195 07a0 2881      		ld r18,Y
 2196 07a2 3981      		ldd r19,Y+1
 2197 07a4 4A81      		ldd r20,Y+2
 2198 07a6 5B81      		ldd r21,Y+3
 2199 07a8 CE51      		subi r28,lo8(286)
 2200 07aa D140      		sbci r29,hi8(286)
 2201               	.LVL237:
 2202 07ac 2C5F      		subi r18,-4
 2203 07ae 3F4F      		sbci r19,-1
 2204 07b0 4F4F      		sbci r20,-1
 2205 07b2 5F4F      		sbci r21,-1
 2206 07b4 C25E      		subi r28,lo8(-286)
 2207 07b6 DE4F      		sbci r29,hi8(-286)
 2208 07b8 2883      		st Y,r18
 2209 07ba 3983      		std Y+1,r19
 2210 07bc 4A83      		std Y+2,r20
 2211 07be 5B83      		std Y+3,r21
 2212 07c0 CE51      		subi r28,lo8(286)
 2213 07c2 D140      		sbci r29,hi8(286)
 2214               	.LVL238:
 2215               	.LBE218:
1730:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
 2216               		.loc 1 1730 0
 2217 07c4 CF5C      		subi r28,lo8(-305)
 2218 07c6 DE4F      		sbci r29,hi8(-305)
 2219 07c8 2881      		ld r18,Y
 2220 07ca 3981      		ldd r19,Y+1
 2221 07cc 4A81      		ldd r20,Y+2
 2222 07ce 5B81      		ldd r21,Y+3
 2223 07d0 C153      		subi r28,lo8(305)
 2224 07d2 D140      		sbci r29,hi8(305)
 2225               	.LVL239:
 2226 07d4 CC24      		clr r12
 2227 07d6 D22E      		mov r13,r18
 2228 07d8 E32E      		mov r14,r19
 2229 07da F42E      		mov r15,r20
 2230 07dc C80C      		add r12,r8
 2231 07de D91C      		adc r13,r9
 2232 07e0 EA1C      		adc r14,r10
 2233 07e2 FB1C      		adc r15,r11
 2234               	.LVL240:
1734:stk500boot.c  **** 		sendchar(0x20);
 2235               		.loc 1 1734 0
 2236 07e4 0E94 0000 		call PrintHexByte
 2237               	.LVL241:
1735:stk500boot.c  **** 		PrintHexByte(byte1);
 2238               		.loc 1 1735 0
 2239 07e8 80E2      		ldi r24,lo8(32)
 2240 07ea 0E94 0000 		call sendchar
 2241               	.LVL242:
1736:stk500boot.c  **** 		sendchar(0x20);
 2242               		.loc 1 1736 0
 2243 07ee CB5C      		subi r28,lo8(-309)
 2244 07f0 DE4F      		sbci r29,hi8(-309)
 2245 07f2 8881      		ld r24,Y
 2246 07f4 C553      		subi r28,lo8(309)
 2247 07f6 D140      		sbci r29,hi8(309)
 2248 07f8 0E94 0000 		call PrintHexByte
 2249               	.LVL243:
1737:stk500boot.c  **** 		PrintHexByte(byte4);
 2250               		.loc 1 1737 0
 2251 07fc 80E2      		ldi r24,lo8(32)
 2252 07fe 0E94 0000 		call sendchar
 2253               	.LVL244:
1738:stk500boot.c  **** 		sendchar(0x20);
 2254               		.loc 1 1738 0
 2255 0802 812F      		mov r24,r17
 2256 0804 0E94 0000 		call PrintHexByte
 2257               	.LVL245:
1739:stk500boot.c  **** 		PrintHexByte(byte3);
 2258               		.loc 1 1739 0
 2259 0808 80E2      		ldi r24,lo8(32)
 2260 080a 0E94 0000 		call sendchar
 2261               	.LVL246:
1740:stk500boot.c  **** 		sendchar(0x20);
 2262               		.loc 1 1740 0
 2263 080e CA5C      		subi r28,lo8(-310)
 2264 0810 DE4F      		sbci r29,hi8(-310)
 2265 0812 8881      		ld r24,Y
 2266 0814 C653      		subi r28,lo8(310)
 2267 0816 D140      		sbci r29,hi8(310)
 2268 0818 0E94 0000 		call PrintHexByte
 2269               	.LVL247:
1741:stk500boot.c  **** 	
 2270               		.loc 1 1741 0
 2271 081c 80E2      		ldi r24,lo8(32)
 2272 081e 0E94 0000 		call sendchar
 2273               	.LVL248:
1743:stk500boot.c  **** 		{
 2274               		.loc 1 1743 0
 2275 0822 3FEF      		ldi r19,-1
 2276 0824 C316      		cp r12,r19
 2277 0826 D306      		cpc r13,r19
 2278 0828 E104      		cpc r14,__zero_reg__
 2279 082a F104      		cpc r15,__zero_reg__
 2280 082c 01F4      		brne .L93
1745:stk500boot.c  **** 		}
 2281               		.loc 1 1745 0
 2282 082e 60E0      		ldi r22,0
 2283 0830 80E0      		ldi r24,lo8(gTextMsg_noVector)
 2284 0832 90E0      		ldi r25,hi8(gTextMsg_noVector)
 2285 0834 0E94 0000 		call PrintFromPROGMEM
 2286               	.LVL249:
 2287               	.L94:
1794:stk500boot.c  **** 
 2288               		.loc 1 1794 0
 2289 0838 0E94 0000 		call PrintNewLine
 2290               	.LVL250:
1703:stk500boot.c  **** 	{
 2291               		.loc 1 1703 0
 2292 083c C75D      		subi r28,lo8(-297)
 2293 083e DE4F      		sbci r29,hi8(-297)
 2294 0840 2881      		ld r18,Y
 2295 0842 3981      		ldd r19,Y+1
 2296 0844 C952      		subi r28,lo8(297)
 2297 0846 D140      		sbci r29,hi8(297)
 2298 0848 2933      		cpi r18,57
 2299 084a 3105      		cpc r19,__zero_reg__
 2300 084c 01F0      		breq .+2
 2301 084e 00C0      		rjmp .L96
 2302 0850 00C0      		rjmp .L60
 2303               	.LVL251:
 2304               	.L93:
1747:stk500boot.c  **** 		{
 2305               		.loc 1 1747 0
 2306 0852 D701      		movw r26,r14
 2307 0854 C601      		movw r24,r12
 2308 0856 8827      		clr r24
 2309 0858 907C      		andi r25,192
 2310 085a AA27      		clr r26
 2311 085c BB27      		clr r27
 2312 085e 8115      		cp r24,__zero_reg__
 2313 0860 904C      		sbci r25,-64
 2314 0862 A105      		cpc r26,__zero_reg__
 2315 0864 B105      		cpc r27,__zero_reg__
 2316 0866 01F4      		brne .L95
1750:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
 2317               		.loc 1 1750 0
 2318 0868 5FE3      		ldi r21,63
 2319 086a D522      		and r13,r21
 2320 086c EE24      		clr r14
 2321 086e FF24      		clr r15
 2322               	.LVL252:
1751:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
 2323               		.loc 1 1751 0
 2324 0870 C35D      		subi r28,lo8(-301)
 2325 0872 DE4F      		sbci r29,hi8(-301)
 2326 0874 8880      		ld r8,Y
 2327 0876 9980      		ldd r9,Y+1
 2328 0878 AA80      		ldd r10,Y+2
 2329 087a BB80      		ldd r11,Y+3
 2330 087c CD52      		subi r28,lo8(301)
 2331 087e D140      		sbci r29,hi8(301)
 2332               	.LVL253:
 2333 0880 8C0C      		add r8,r12
 2334 0882 9D1C      		adc r9,r13
 2335 0884 AE1C      		adc r10,r14
 2336 0886 BF1C      		adc r11,r15
 2337               	.LVL254:
1752:stk500boot.c  **** 
 2338               		.loc 1 1752 0
 2339 0888 880C      		lsl r8
 2340 088a 991C      		rol r9
 2341 088c AA1C      		rol r10
 2342 088e BB1C      		rol r11
 2343               	.LVL255:
1754:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
 2344               		.loc 1 1754 0
 2345 0890 60E0      		ldi r22,0
 2346 0892 80E0      		ldi r24,lo8(gTextMsg_rjmp)
 2347 0894 90E0      		ldi r25,hi8(gTextMsg_rjmp)
 2348 0896 0E94 0000 		call PrintFromPROGMEM
 2349               	.LVL256:
1755:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
 2350               		.loc 1 1755 0
 2351 089a 8D2D      		mov r24,r13
 2352 089c 0E94 0000 		call PrintHexByte
 2353               	.LVL257:
1756:stk500boot.c  **** 			sendchar(0x20);
 2354               		.loc 1 1756 0
 2355 08a0 8C2D      		mov r24,r12
 2356 08a2 0E94 0000 		call PrintHexByte
 2357               	.LVL258:
1757:stk500boot.c  **** 			sendchar('>');
 2358               		.loc 1 1757 0
 2359 08a6 80E2      		ldi r24,lo8(32)
 2360 08a8 0E94 0000 		call sendchar
 2361               	.LVL259:
1758:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2362               		.loc 1 1758 0
 2363 08ac 8EE3      		ldi r24,lo8(62)
 2364 08ae 0E94 0000 		call sendchar
 2365               	.LVL260:
1759:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2366               		.loc 1 1759 0
 2367 08b2 80E0      		ldi r24,0
 2368 08b4 0E94 0000 		call PrintHexByte
 2369               	.LVL261:
1760:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2370               		.loc 1 1760 0
 2371 08b8 892D      		mov r24,r9
 2372 08ba 0E94 0000 		call PrintHexByte
 2373               	.LVL262:
1761:stk500boot.c  **** 	
 2374               		.loc 1 1761 0
 2375 08be 882D      		mov r24,r8
 2376               	.LVL263:
 2377               	.L271:
1782:stk500boot.c  **** 		}
 2378               		.loc 1 1782 0
 2379 08c0 0E94 0000 		call PrintHexByte
 2380               	.LVL264:
 2381 08c4 00C0      		rjmp .L94
 2382               	.LVL265:
 2383               	.L95:
1764:stk500boot.c  **** 		{
 2384               		.loc 1 1764 0
 2385 08c6 8EE0      		ldi r24,14
 2386 08c8 C822      		and r12,r24
 2387 08ca E894      		clt
 2388 08cc D0F8      		bld r13,0
 2389 08ce EE24      		clr r14
 2390 08d0 FF24      		clr r15
 2391               	.LVL266:
 2392 08d2 9CE0      		ldi r25,12
 2393 08d4 C916      		cp r12,r25
 2394 08d6 94E9      		ldi r25,-108
 2395 08d8 D906      		cpc r13,r25
 2396 08da E104      		cpc r14,__zero_reg__
 2397 08dc F104      		cpc r15,__zero_reg__
 2398 08de 01F0      		breq .+2
 2399 08e0 00C0      		rjmp .L94
1767:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2400               		.loc 1 1767 0
 2401 08e2 B401      		movw r22,r8
 2402 08e4 5527      		clr r21
 2403 08e6 4427      		clr r20
 2404 08e8 4427      		clr r20
 2405 08ea 5527      		clr r21
 2406 08ec 6170      		andi r22,1
 2407 08ee 7727      		clr r23
1768:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
 2408               		.loc 1 1768 0
 2409 08f0 E1E1      		ldi r30,17
 2410               		1:
 2411 08f2 880C      		lsl r8
 2412 08f4 991C      		rol r9
 2413 08f6 AA1C      		rol r10
 2414 08f8 BB1C      		rol r11
 2415 08fa EA95      		dec r30
 2416 08fc 01F4      		brne 1b
 2417               	.LVL267:
 2418 08fe 8824      		clr r8
 2419 0900 9924      		clr r9
 2420 0902 A0EE      		ldi r26,224
 2421 0904 AA22      		and r10,r26
 2422 0906 A1E0      		ldi r26,1
 2423 0908 BA22      		and r11,r26
1767:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2424               		.loc 1 1767 0
 2425 090a 4829      		or r20,r8
 2426 090c 5929      		or r21,r9
 2427 090e 6A29      		or r22,r10
 2428 0910 7B29      		or r23,r11
1723:stk500boot.c  **** 	#else
 2429               		.loc 1 1723 0
 2430 0912 812F      		mov r24,r17
 2431 0914 90E0      		ldi r25,0
 2432 0916 B0E0      		ldi r27,0
 2433 0918 A0E0      		ldi r26,0
1731:stk500boot.c  **** 
 2434               		.loc 1 1731 0
 2435 091a BA2F      		mov r27,r26
 2436 091c A92F      		mov r26,r25
 2437 091e 982F      		mov r25,r24
 2438 0920 8827      		clr r24
 2439 0922 CA5C      		subi r28,lo8(-310)
 2440 0924 DE4F      		sbci r29,hi8(-310)
 2441 0926 E881      		ld r30,Y
 2442 0928 C653      		subi r28,lo8(310)
 2443 092a D140      		sbci r29,hi8(310)
 2444 092c 8E0F      		add r24,r30
 2445 092e 911D      		adc r25,__zero_reg__
 2446 0930 A11D      		adc r26,__zero_reg__
 2447 0932 B11D      		adc r27,__zero_reg__
1769:stk500boot.c  **** 								word2;
 2448               		.loc 1 1769 0
 2449 0934 CF5C      		subi r28,lo8(-305)
 2450 0936 DE4F      		sbci r29,hi8(-305)
 2451 0938 8880      		ld r8,Y
 2452 093a 9980      		ldd r9,Y+1
 2453 093c AA80      		ldd r10,Y+2
 2454 093e BB80      		ldd r11,Y+3
 2455 0940 C153      		subi r28,lo8(305)
 2456 0942 D140      		sbci r29,hi8(305)
 2457 0944 15E1      		ldi r17,21
 2458               		1:
 2459 0946 880C      		lsl r8
 2460 0948 991C      		rol r9
 2461 094a AA1C      		rol r10
 2462 094c BB1C      		rol r11
 2463 094e 1A95      		dec r17
 2464 0950 01F4      		brne 1b
 2465               	.LVL268:
 2466 0952 8824      		clr r8
 2467 0954 9924      		clr r9
 2468 0956 F0E2      		ldi r31,32
 2469 0958 AF22      		and r10,r31
 2470 095a BB24      		clr r11
1767:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2471               		.loc 1 1767 0
 2472 095c 880D      		add r24,r8
 2473 095e 991D      		adc r25,r9
 2474 0960 AA1D      		adc r26,r10
 2475 0962 BB1D      		adc r27,r11
 2476 0964 4A01      		movw r8,r20
 2477 0966 5B01      		movw r10,r22
 2478 0968 880E      		add r8,r24
 2479 096a 991E      		adc r9,r25
 2480 096c AA1E      		adc r10,r26
 2481 096e BB1E      		adc r11,r27
 2482               	.LVL269:
1772:stk500boot.c  **** 							
 2483               		.loc 1 1772 0
 2484 0970 7501      		movw r14,r10
 2485 0972 6401      		movw r12,r8
 2486 0974 CC0C      		lsl r12
 2487 0976 DD1C      		rol r13
 2488 0978 EE1C      		rol r14
 2489 097a FF1C      		rol r15
1774:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
 2490               		.loc 1 1774 0
 2491 097c 60E0      		ldi r22,0
 2492 097e 80E0      		ldi r24,lo8(gTextMsg_jmp)
 2493 0980 90E0      		ldi r25,hi8(gTextMsg_jmp)
 2494 0982 0E94 0000 		call PrintFromPROGMEM
 2495               	.LVL270:
1775:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
 2496               		.loc 1 1775 0
 2497 0986 8A2D      		mov r24,r10
 2498 0988 0E94 0000 		call PrintHexByte
 2499               	.LVL271:
1776:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
 2500               		.loc 1 1776 0
 2501 098c 892D      		mov r24,r9
 2502 098e 0E94 0000 		call PrintHexByte
 2503               	.LVL272:
1777:stk500boot.c  **** 			sendchar(0x20);
 2504               		.loc 1 1777 0
 2505 0992 882D      		mov r24,r8
 2506 0994 0E94 0000 		call PrintHexByte
 2507               	.LVL273:
1778:stk500boot.c  **** 			sendchar('>');
 2508               		.loc 1 1778 0
 2509 0998 80E2      		ldi r24,lo8(32)
 2510 099a 0E94 0000 		call sendchar
 2511               	.LVL274:
1779:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2512               		.loc 1 1779 0
 2513 099e 8EE3      		ldi r24,lo8(62)
 2514 09a0 0E94 0000 		call sendchar
 2515               	.LVL275:
1780:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2516               		.loc 1 1780 0
 2517 09a4 8E2D      		mov r24,r14
 2518 09a6 0E94 0000 		call PrintHexByte
 2519               	.LVL276:
1781:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2520               		.loc 1 1781 0
 2521 09aa 8D2D      		mov r24,r13
 2522 09ac 0E94 0000 		call PrintHexByte
 2523               	.LVL277:
1782:stk500boot.c  **** 		}
 2524               		.loc 1 1782 0
 2525 09b0 8C2D      		mov r24,r12
 2526 09b2 00C0      		rjmp .L271
 2527               	.LVL278:
 2528               	.L75:
 2529               	.LBE212:
 2530               	.LBE211:
2164:stk500boot.c  **** 				AVR_PortOutput();
 2531               		.loc 1 2164 0
 2532 09b4 62E0      		ldi r22,lo8(2)
 2533 09b6 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 2534 09b8 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 2535 09ba 0E94 0000 		call PrintFromPROGMEMln
 2536               	.LVL279:
 2537               	.LBB219:
 2538               	.LBB220:
1868:stk500boot.c  **** 
 2539               		.loc 1 1868 0
 2540 09be 60E0      		ldi r22,0
 2541 09c0 80E0      		ldi r24,lo8(gTextMsg_WHAT_PORT)
 2542 09c2 90E0      		ldi r25,hi8(gTextMsg_WHAT_PORT)
 2543 09c4 0E94 0000 		call PrintFromPROGMEM
 2544               	.LVL280:
1870:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
 2545               		.loc 1 1870 0
 2546 09c8 0E94 0000 		call recchar
 2547               	.LVL281:
1871:stk500boot.c  **** 	sendchar(portLetter);
 2548               		.loc 1 1871 0
 2549 09cc 182F      		mov r17,r24
 2550               	.LVL282:
 2551 09ce 1F75      		andi r17,lo8(95)
 2552               	.LVL283:
1872:stk500boot.c  **** 	PrintNewLine();
 2553               		.loc 1 1872 0
 2554 09d0 812F      		mov r24,r17
 2555 09d2 0E94 0000 		call sendchar
 2556               	.LVL284:
1873:stk500boot.c  **** 
 2557               		.loc 1 1873 0
 2558 09d6 0E94 0000 		call PrintNewLine
 2559               	.LVL285:
1875:stk500boot.c  **** 	{
 2560               		.loc 1 1875 0
 2561 09da 8FEB      		ldi r24,lo8(-65)
 2562 09dc 810F      		add r24,r17
 2563 09de 8A31      		cpi r24,lo8(26)
 2564 09e0 00F0      		brlo .+2
 2565 09e2 00C0      		rjmp .L98
 2566               	.LVL286:
1878:stk500boot.c  **** 		{
 2567               		.loc 1 1878 0
 2568 09e4 1634      		cpi r17,lo8(70)
 2569 09e6 01F4      		brne .+2
 2570 09e8 00C0      		rjmp .L100
 2571 09ea 00F4      		brsh .L101
 2572 09ec 1334      		cpi r17,lo8(67)
 2573 09ee 01F4      		brne .+2
 2574 09f0 00C0      		rjmp .L102
 2575 09f2 00F4      		brsh .L103
 2576 09f4 1134      		cpi r17,lo8(65)
 2577 09f6 01F0      		breq .L104
 2578 09f8 1234      		cpi r17,lo8(66)
 2579 09fa 01F4      		brne .+2
 2580 09fc 00C0      		rjmp .L105
 2581               	.L99:
2025:stk500boot.c  **** 				getCharFlag	=	false;
 2582               		.loc 1 2025 0
 2583 09fe 60E0      		ldi r22,0
 2584 0a00 80E0      		ldi r24,lo8(gTextMsg_PortNotSupported)
 2585 0a02 90E0      		ldi r25,hi8(gTextMsg_PortNotSupported)
 2586 0a04 00C0      		rjmp .L272
 2587               	.L103:
1878:stk500boot.c  **** 		{
 2588               		.loc 1 1878 0
 2589 0a06 1434      		cpi r17,lo8(68)
 2590 0a08 01F4      		brne .+2
 2591 0a0a 00C0      		rjmp .L106
 2592 0a0c 1534      		cpi r17,lo8(69)
 2593 0a0e 01F4      		brne .L99
1930:stk500boot.c  **** 				while (!Serial_Available())
 2594               		.loc 1 1930 0
 2595 0a10 0DB9      		out 0xd,r16
 2596               	.L123:
 2597               	.LBB221:
 2598               	.LBB222:
 477:stk500boot.c  **** }
 2599               		.loc 1 477 0
 2600 0a12 8091 C000 		lds r24,192
 2601               	.LBE222:
 2602               	.LBE221:
1931:stk500boot.c  **** 				{
 2603               		.loc 1 1931 0
 2604 0a16 87FF      		sbrs r24,7
 2605 0a18 00C0      		rjmp .L124
1936:stk500boot.c  **** 				break;
 2606               		.loc 1 1936 0
 2607 0a1a 1EB8      		out 0xe,__zero_reg__
 2608 0a1c 00C0      		rjmp .L116
 2609               	.L101:
1878:stk500boot.c  **** 		{
 2610               		.loc 1 1878 0
 2611 0a1e 1A34      		cpi r17,lo8(74)
 2612 0a20 01F4      		brne .+2
 2613 0a22 00C0      		rjmp .L108
 2614 0a24 00F4      		brsh .L109
 2615 0a26 1734      		cpi r17,lo8(71)
 2616 0a28 01F4      		brne .+2
 2617 0a2a 00C0      		rjmp .L110
 2618 0a2c 1834      		cpi r17,lo8(72)
 2619 0a2e 01F4      		brne .L99
1966:stk500boot.c  **** 				while (!Serial_Available())
 2620               		.loc 1 1966 0
 2621 0a30 0093 0101 		sts 257,r16
 2622               	.L129:
 2623               	.LBB223:
 2624               	.LBB224:
 477:stk500boot.c  **** }
 2625               		.loc 1 477 0
 2626 0a34 8091 C000 		lds r24,192
 2627               	.LBE224:
 2628               	.LBE223:
1967:stk500boot.c  **** 				{
 2629               		.loc 1 1967 0
 2630 0a38 87FF      		sbrs r24,7
 2631 0a3a 00C0      		rjmp .L130
1972:stk500boot.c  **** 				break;
 2632               		.loc 1 1972 0
 2633 0a3c 1092 0201 		sts 258,__zero_reg__
 2634 0a40 00C0      		rjmp .L116
 2635               	.L109:
1878:stk500boot.c  **** 		{
 2636               		.loc 1 1878 0
 2637 0a42 1B34      		cpi r17,lo8(75)
 2638 0a44 01F4      		brne .+2
 2639 0a46 00C0      		rjmp .L112
 2640 0a48 1C34      		cpi r17,lo8(76)
 2641 0a4a 01F4      		brne .L99
2014:stk500boot.c  **** 				while (!Serial_Available())
 2642               		.loc 1 2014 0
 2643 0a4c 0093 0A01 		sts 266,r16
 2644               	.L135:
 2645               	.LBB225:
 2646               	.LBB226:
 477:stk500boot.c  **** }
 2647               		.loc 1 477 0
 2648 0a50 8091 C000 		lds r24,192
 2649               	.LBE226:
 2650               	.LBE225:
2015:stk500boot.c  **** 				{
 2651               		.loc 1 2015 0
 2652 0a54 87FF      		sbrs r24,7
 2653 0a56 00C0      		rjmp .L136
2020:stk500boot.c  **** 				break;
 2654               		.loc 1 2020 0
 2655 0a58 1092 0B01 		sts 267,__zero_reg__
 2656 0a5c 00C0      		rjmp .L116
 2657               	.L104:
1882:stk500boot.c  **** 				while (!Serial_Available())
 2658               		.loc 1 1882 0
 2659 0a5e 01B9      		out 0x1,r16
 2660               	.L114:
 2661               	.LBB227:
 2662               	.LBB228:
 477:stk500boot.c  **** }
 2663               		.loc 1 477 0
 2664 0a60 8091 C000 		lds r24,192
 2665               	.LBE228:
 2666               	.LBE227:
1883:stk500boot.c  **** 				{
 2667               		.loc 1 1883 0
 2668 0a64 87FF      		sbrs r24,7
 2669 0a66 00C0      		rjmp .L115
1888:stk500boot.c  **** 				break;
 2670               		.loc 1 1888 0
 2671 0a68 12B8      		out 0x2,__zero_reg__
 2672 0a6a 00C0      		rjmp .L116
 2673               	.L115:
1885:stk500boot.c  **** 					delay_ms(200);
 2674               		.loc 1 1885 0
 2675 0a6c 82B1      		in r24,0x2
 2676 0a6e 8095      		com r24
 2677 0a70 82B9      		out 0x2,r24
1886:stk500boot.c  **** 				}
 2678               		.loc 1 1886 0
 2679 0a72 88EC      		ldi r24,lo8(-56)
 2680 0a74 90E0      		ldi r25,0
 2681 0a76 0E94 0000 		call delay_ms
 2682               	.LVL287:
 2683 0a7a 00C0      		rjmp .L114
 2684               	.L105:
1894:stk500boot.c  **** 				while (!Serial_Available())
 2685               		.loc 1 1894 0
 2686 0a7c 04B9      		out 0x4,r16
 2687               	.L117:
 2688               	.LBB229:
 2689               	.LBB230:
 477:stk500boot.c  **** }
 2690               		.loc 1 477 0
 2691 0a7e 8091 C000 		lds r24,192
 2692               	.LBE230:
 2693               	.LBE229:
1895:stk500boot.c  **** 				{
 2694               		.loc 1 1895 0
 2695 0a82 87FF      		sbrs r24,7
 2696 0a84 00C0      		rjmp .L118
1900:stk500boot.c  **** 				break;
 2697               		.loc 1 1900 0
 2698 0a86 15B8      		out 0x5,__zero_reg__
 2699 0a88 00C0      		rjmp .L116
 2700               	.L118:
1897:stk500boot.c  **** 					delay_ms(200);
 2701               		.loc 1 1897 0
 2702 0a8a 85B1      		in r24,0x5
 2703 0a8c 8095      		com r24
 2704 0a8e 85B9      		out 0x5,r24
1898:stk500boot.c  **** 				}
 2705               		.loc 1 1898 0
 2706 0a90 88EC      		ldi r24,lo8(-56)
 2707 0a92 90E0      		ldi r25,0
 2708 0a94 0E94 0000 		call delay_ms
 2709               	.LVL288:
 2710 0a98 00C0      		rjmp .L117
 2711               	.L102:
1906:stk500boot.c  **** 				while (!Serial_Available())
 2712               		.loc 1 1906 0
 2713 0a9a 07B9      		out 0x7,r16
 2714               	.L119:
 2715               	.LBB231:
 2716               	.LBB232:
 477:stk500boot.c  **** }
 2717               		.loc 1 477 0
 2718 0a9c 8091 C000 		lds r24,192
 2719               	.LBE232:
 2720               	.LBE231:
1907:stk500boot.c  **** 				{
 2721               		.loc 1 1907 0
 2722 0aa0 87FF      		sbrs r24,7
 2723 0aa2 00C0      		rjmp .L120
1912:stk500boot.c  **** 				break;
 2724               		.loc 1 1912 0
 2725 0aa4 18B8      		out 0x8,__zero_reg__
 2726 0aa6 00C0      		rjmp .L116
 2727               	.L120:
1909:stk500boot.c  **** 					delay_ms(200);
 2728               		.loc 1 1909 0
 2729 0aa8 88B1      		in r24,0x8
 2730 0aaa 8095      		com r24
 2731 0aac 88B9      		out 0x8,r24
1910:stk500boot.c  **** 				}
 2732               		.loc 1 1910 0
 2733 0aae 88EC      		ldi r24,lo8(-56)
 2734 0ab0 90E0      		ldi r25,0
 2735 0ab2 0E94 0000 		call delay_ms
 2736               	.LVL289:
 2737 0ab6 00C0      		rjmp .L119
 2738               	.L106:
1918:stk500boot.c  **** 				while (!Serial_Available())
 2739               		.loc 1 1918 0
 2740 0ab8 0AB9      		out 0xa,r16
 2741               	.L121:
 2742               	.LBB233:
 2743               	.LBB234:
 477:stk500boot.c  **** }
 2744               		.loc 1 477 0
 2745 0aba 8091 C000 		lds r24,192
 2746               	.LBE234:
 2747               	.LBE233:
1919:stk500boot.c  **** 				{
 2748               		.loc 1 1919 0
 2749 0abe 87FF      		sbrs r24,7
 2750 0ac0 00C0      		rjmp .L122
1924:stk500boot.c  **** 				break;
 2751               		.loc 1 1924 0
 2752 0ac2 1BB8      		out 0xb,__zero_reg__
 2753 0ac4 00C0      		rjmp .L116
 2754               	.L122:
1921:stk500boot.c  **** 					delay_ms(200);
 2755               		.loc 1 1921 0
 2756 0ac6 8BB1      		in r24,0xb
 2757 0ac8 8095      		com r24
 2758 0aca 8BB9      		out 0xb,r24
1922:stk500boot.c  **** 				}
 2759               		.loc 1 1922 0
 2760 0acc 88EC      		ldi r24,lo8(-56)
 2761 0ace 90E0      		ldi r25,0
 2762 0ad0 0E94 0000 		call delay_ms
 2763               	.LVL290:
 2764 0ad4 00C0      		rjmp .L121
 2765               	.L124:
1933:stk500boot.c  **** 					delay_ms(200);
 2766               		.loc 1 1933 0
 2767 0ad6 8EB1      		in r24,0xe
 2768 0ad8 8095      		com r24
 2769 0ada 8EB9      		out 0xe,r24
1934:stk500boot.c  **** 				}
 2770               		.loc 1 1934 0
 2771 0adc 88EC      		ldi r24,lo8(-56)
 2772 0ade 90E0      		ldi r25,0
 2773 0ae0 0E94 0000 		call delay_ms
 2774               	.LVL291:
 2775 0ae4 00C0      		rjmp .L123
 2776               	.L100:
1942:stk500boot.c  **** 				while (!Serial_Available())
 2777               		.loc 1 1942 0
 2778 0ae6 00BB      		out 0x10,r16
 2779               	.L125:
 2780               	.LBB235:
 2781               	.LBB236:
 477:stk500boot.c  **** }
 2782               		.loc 1 477 0
 2783 0ae8 8091 C000 		lds r24,192
 2784               	.LBE236:
 2785               	.LBE235:
1943:stk500boot.c  **** 				{
 2786               		.loc 1 1943 0
 2787 0aec 87FF      		sbrs r24,7
 2788 0aee 00C0      		rjmp .L126
1948:stk500boot.c  **** 				break;
 2789               		.loc 1 1948 0
 2790 0af0 11BA      		out 0x11,__zero_reg__
 2791 0af2 00C0      		rjmp .L116
 2792               	.L126:
1945:stk500boot.c  **** 					delay_ms(200);
 2793               		.loc 1 1945 0
 2794 0af4 81B3      		in r24,0x11
 2795 0af6 8095      		com r24
 2796 0af8 81BB      		out 0x11,r24
1946:stk500boot.c  **** 				}
 2797               		.loc 1 1946 0
 2798 0afa 88EC      		ldi r24,lo8(-56)
 2799 0afc 90E0      		ldi r25,0
 2800 0afe 0E94 0000 		call delay_ms
 2801               	.LVL292:
 2802 0b02 00C0      		rjmp .L125
 2803               	.L110:
1954:stk500boot.c  **** 				while (!Serial_Available())
 2804               		.loc 1 1954 0
 2805 0b04 03BB      		out 0x13,r16
 2806               	.L127:
 2807               	.LBB237:
 2808               	.LBB238:
 477:stk500boot.c  **** }
 2809               		.loc 1 477 0
 2810 0b06 8091 C000 		lds r24,192
 2811               	.LBE238:
 2812               	.LBE237:
1955:stk500boot.c  **** 				{
 2813               		.loc 1 1955 0
 2814 0b0a 87FF      		sbrs r24,7
 2815 0b0c 00C0      		rjmp .L128
1960:stk500boot.c  **** 				break;
 2816               		.loc 1 1960 0
 2817 0b0e 14BA      		out 0x14,__zero_reg__
 2818 0b10 00C0      		rjmp .L116
 2819               	.L128:
1957:stk500boot.c  **** 					delay_ms(200);
 2820               		.loc 1 1957 0
 2821 0b12 84B3      		in r24,0x14
 2822 0b14 8095      		com r24
 2823 0b16 84BB      		out 0x14,r24
1958:stk500boot.c  **** 				}
 2824               		.loc 1 1958 0
 2825 0b18 88EC      		ldi r24,lo8(-56)
 2826 0b1a 90E0      		ldi r25,0
 2827 0b1c 0E94 0000 		call delay_ms
 2828               	.LVL293:
 2829 0b20 00C0      		rjmp .L127
 2830               	.L130:
1969:stk500boot.c  **** 					delay_ms(200);
 2831               		.loc 1 1969 0
 2832 0b22 8091 0201 		lds r24,258
 2833 0b26 8095      		com r24
 2834 0b28 8093 0201 		sts 258,r24
1970:stk500boot.c  **** 				}
 2835               		.loc 1 1970 0
 2836 0b2c 88EC      		ldi r24,lo8(-56)
 2837 0b2e 90E0      		ldi r25,0
 2838 0b30 0E94 0000 		call delay_ms
 2839               	.LVL294:
 2840 0b34 00C0      		rjmp .L129
 2841               	.L108:
1990:stk500boot.c  **** 				while (!Serial_Available())
 2842               		.loc 1 1990 0
 2843 0b36 0093 0401 		sts 260,r16
 2844               	.L131:
 2845               	.LBB239:
 2846               	.LBB240:
 477:stk500boot.c  **** }
 2847               		.loc 1 477 0
 2848 0b3a 8091 C000 		lds r24,192
 2849               	.LBE240:
 2850               	.LBE239:
1991:stk500boot.c  **** 				{
 2851               		.loc 1 1991 0
 2852 0b3e 87FF      		sbrs r24,7
 2853 0b40 00C0      		rjmp .L132
1996:stk500boot.c  **** 				break;
 2854               		.loc 1 1996 0
 2855 0b42 1092 0501 		sts 261,__zero_reg__
 2856 0b46 00C0      		rjmp .L116
 2857               	.L132:
1993:stk500boot.c  **** 					delay_ms(200);
 2858               		.loc 1 1993 0
 2859 0b48 8091 0501 		lds r24,261
 2860 0b4c 8095      		com r24
 2861 0b4e 8093 0501 		sts 261,r24
1994:stk500boot.c  **** 				}
 2862               		.loc 1 1994 0
 2863 0b52 88EC      		ldi r24,lo8(-56)
 2864 0b54 90E0      		ldi r25,0
 2865 0b56 0E94 0000 		call delay_ms
 2866               	.LVL295:
 2867 0b5a 00C0      		rjmp .L131
 2868               	.L112:
2002:stk500boot.c  **** 				while (!Serial_Available())
 2869               		.loc 1 2002 0
 2870 0b5c 0093 0701 		sts 263,r16
 2871               	.L133:
 2872               	.LBB241:
 2873               	.LBB242:
 477:stk500boot.c  **** }
 2874               		.loc 1 477 0
 2875 0b60 8091 C000 		lds r24,192
 2876               	.LBE242:
 2877               	.LBE241:
2003:stk500boot.c  **** 				{
 2878               		.loc 1 2003 0
 2879 0b64 87FF      		sbrs r24,7
 2880 0b66 00C0      		rjmp .L134
2008:stk500boot.c  **** 				break;
 2881               		.loc 1 2008 0
 2882 0b68 1092 0801 		sts 264,__zero_reg__
 2883 0b6c 00C0      		rjmp .L116
 2884               	.L134:
2005:stk500boot.c  **** 					delay_ms(200);
 2885               		.loc 1 2005 0
 2886 0b6e 8091 0801 		lds r24,264
 2887 0b72 8095      		com r24
 2888 0b74 8093 0801 		sts 264,r24
2006:stk500boot.c  **** 				}
 2889               		.loc 1 2006 0
 2890 0b78 88EC      		ldi r24,lo8(-56)
 2891 0b7a 90E0      		ldi r25,0
 2892 0b7c 0E94 0000 		call delay_ms
 2893               	.LVL296:
 2894 0b80 00C0      		rjmp .L133
 2895               	.L136:
2017:stk500boot.c  **** 					delay_ms(200);
 2896               		.loc 1 2017 0
 2897 0b82 8091 0B01 		lds r24,267
 2898 0b86 8095      		com r24
 2899 0b88 8093 0B01 		sts 267,r24
2018:stk500boot.c  **** 				}
 2900               		.loc 1 2018 0
 2901 0b8c 88EC      		ldi r24,lo8(-56)
 2902 0b8e 90E0      		ldi r25,0
 2903 0b90 0E94 0000 		call delay_ms
 2904               	.LVL297:
 2905 0b94 00C0      		rjmp .L135
 2906               	.LVL298:
 2907               	.L98:
2036:stk500boot.c  **** 	}
 2908               		.loc 1 2036 0
 2909 0b96 60E0      		ldi r22,0
 2910 0b98 80E0      		ldi r24,lo8(gTextMsg_MustBeLetter)
 2911 0b9a 90E0      		ldi r25,hi8(gTextMsg_MustBeLetter)
 2912 0b9c 00C0      		rjmp .L272
 2913               	.LVL299:
 2914               	.L55:
 2915               	.LBE220:
 2916               	.LBE219:
 2917               	.LBE245:
 2918               	.LBE247:
 761:stk500boot.c  **** 				{
 2919               		.loc 1 761 0
 2920 0b9e 8330      		cpi r24,lo8(3)
 2921 0ba0 01F4      		brne .+2
 2922 0ba2 00C0      		rjmp .L201
 2923 0ba4 00F4      		brsh .L141
 2924 0ba6 8130      		cpi r24,lo8(1)
 2925 0ba8 01F4      		brne .+2
 2926 0baa 00C0      		rjmp .L199
 2927 0bac 00F0      		brlo .L267
 757:stk500boot.c  **** 				}
 2928               		.loc 1 757 0
 2929 0bae F12C      		mov r15,__zero_reg__
 2930 0bb0 E12C      		mov r14,__zero_reg__
 2931               	.LVL300:
 2932               	.L143:
 791:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 2933               		.loc 1 791 0
 2934 0bb2 292F      		mov r18,r25
 2935               	.LVL301:
 2936 0bb4 30E0      		ldi r19,0
 2937 0bb6 322F      		mov r19,r18
 2938 0bb8 2227      		clr r18
 2939               	.LVL302:
 793:stk500boot.c  **** 						break;
 2940               		.loc 1 793 0
 2941 0bba B926      		eor r11,r25
 2942               	.LVL303:
 792:stk500boot.c  **** 						checksum		^=	c;
 2943               		.loc 1 792 0
 2944 0bbc 83E0      		ldi r24,lo8(3)
 794:stk500boot.c  **** 
 2945               		.loc 1 794 0
 2946 0bbe 00C0      		rjmp .L149
 2947               	.LVL304:
 2948               	.L141:
 761:stk500boot.c  **** 				{
 2949               		.loc 1 761 0
 2950 0bc0 8530      		cpi r24,lo8(5)
 2951 0bc2 01F4      		brne .+2
 2952 0bc4 00C0      		rjmp .L203
 2953 0bc6 00F4      		brsh .+2
 2954 0bc8 00C0      		rjmp .L202
 757:stk500boot.c  **** 				}
 2955               		.loc 1 757 0
 2956 0bca F12C      		mov r15,__zero_reg__
 2957 0bcc E12C      		mov r14,__zero_reg__
 761:stk500boot.c  **** 				{
 2958               		.loc 1 761 0
 2959 0bce 8630      		cpi r24,lo8(6)
 2960 0bd0 01F4      		brne .+2
 2961 0bd2 00C0      		rjmp .L147
 757:stk500boot.c  **** 				}
 2962               		.loc 1 757 0
 2963 0bd4 F12C      		mov r15,__zero_reg__
 2964 0bd6 E12C      		mov r14,__zero_reg__
 2965               	.LVL305:
 2966               	.L139:
 726:stk500boot.c  **** 			{
 2967               		.loc 1 726 0
 2968 0bd8 8730      		cpi r24,lo8(7)
 2969 0bda 01F4      		brne .L149
 2970               	.LVL306:
 2971               	.L208:
 2972 0bdc C25E      		subi r28,lo8(-286)
 2973 0bde DE4F      		sbci r29,hi8(-286)
 2974 0be0 1882      		st Y,__zero_reg__
 2975 0be2 CE51      		subi r28,lo8(286)
 2976 0be4 D140      		sbci r29,hi8(286)
 2977 0be6 00C0      		rjmp .L92
 2978               	.LVL307:
 2979               	.L267:
 757:stk500boot.c  **** 				}
 2980               		.loc 1 757 0
 2981 0be8 F12C      		mov r15,__zero_reg__
 2982 0bea E12C      		mov r14,__zero_reg__
 764:stk500boot.c  **** 						{
 2983               		.loc 1 764 0
 2984 0bec 9B31      		cpi r25,lo8(27)
 2985 0bee 01F4      		brne .+2
 2986 0bf0 00C0      		rjmp .L205
 2987               	.LVL308:
 2988               	.L149:
 632:stk500boot.c  **** 	boot_state	=	0;
 2989               		.loc 1 632 0
 2990 0bf2 50E0      		ldi r21,0
 2991 0bf4 40E0      		ldi r20,0
 2992               	.LVL309:
 2993               	.L193:
 728:stk500boot.c  **** 				{
 2994               		.loc 1 728 0
 2995 0bf6 4130      		cpi r20,1
 2996 0bf8 5105      		cpc r21,__zero_reg__
 2997 0bfa 01F0      		breq .+2
 2998 0bfc 00C0      		rjmp .L53
 2999               	.LVL310:
 3000               	.L270:
 3001               	.LBB248:
 3002               	.LBB185:
 523:stk500boot.c  **** }
 3003               		.loc 1 523 0
 3004 0bfe 9091 C600 		lds r25,198
 3005               	.LVL311:
 3006               	.LBE185:
 3007               	.LBE248:
 741:stk500boot.c  **** 
 3008               		.loc 1 741 0
 3009 0c02 C55D      		subi r28,lo8(-299)
 3010 0c04 DE4F      		sbci r29,hi8(-299)
 3011 0c06 A881      		ld r26,Y
 3012 0c08 B981      		ldd r27,Y+1
 3013 0c0a CB52      		subi r28,lo8(299)
 3014 0c0c D140      		sbci r29,hi8(299)
 3015 0c0e 1196      		adiw r26,1
 3016 0c10 C55D      		subi r28,lo8(-299)
 3017 0c12 DE4F      		sbci r29,hi8(-299)
 3018 0c14 B983      		std Y+1,r27
 3019 0c16 A883      		st Y,r26
 3020 0c18 CB52      		subi r28,lo8(299)
 3021 0c1a D140      		sbci r29,hi8(299)
 3022               	.LVL312:
 743:stk500boot.c  **** 				{
 3023               		.loc 1 743 0
 3024 0c1c 9132      		cpi r25,lo8(33)
 3025 0c1e 01F0      		breq .+2
 3026 0c20 00C0      		rjmp .L55
 743:stk500boot.c  **** 				{
 3027               		.loc 1 743 0 is_stmt 0 discriminator 1
 3028 0c22 1A97      		sbiw r26,10
 3029 0c24 00F0      		brlo .+2
 3030 0c26 00C0      		rjmp .L196
 745:stk500boot.c  **** 					if (exPointCntr == 3)
 3031               		.loc 1 745 0 is_stmt 1
 3032 0c28 BFEF      		ldi r27,-1
 3033 0c2a EB1A      		sub r14,r27
 3034 0c2c FB0A      		sbc r15,r27
 3035               	.LVL313:
 746:stk500boot.c  **** 					{
 3036               		.loc 1 746 0
 3037 0c2e E3E0      		ldi r30,3
 3038 0c30 EE16      		cp r14,r30
 3039 0c32 F104      		cpc r15,__zero_reg__
 3040 0c34 01F0      		breq .+2
 3041 0c36 00C0      		rjmp .L56
 3042 0c38 E5E0      		ldi r30,lo8(5)
 3043 0c3a EE2E      		mov r14,r30
 3044 0c3c F12C      		mov r15,__zero_reg__
 3045               	.LVL314:
 3046               	.L57:
 632:stk500boot.c  **** 	boot_state	=	0;
 3047               		.loc 1 632 0
 3048 0c3e 09E1      		ldi r16,lo8(25)
 3049 0c40 10E0      		ldi r17,0
 3050               	.LVL315:
 3051               	.L58:
 3052               	.LBB249:
 3053               	.LBB246:
2070:stk500boot.c  **** 		}
 3054               		.loc 1 2070 0
 3055 0c42 81E2      		ldi r24,lo8(33)
 3056 0c44 0E94 0000 		call sendchar
 3057               	.LVL316:
 3058 0c48 0150      		subi r16,1
 3059 0c4a 1109      		sbc r17,__zero_reg__
 3060               	.LVL317:
2068:stk500boot.c  **** 		{
 3061               		.loc 1 2068 0
 3062 0c4c 01F4      		brne .L58
2072:stk500boot.c  **** 	}
 3063               		.loc 1 2072 0
 3064 0c4e 0E94 0000 		call PrintNewLine
 3065               	.LVL318:
 3066 0c52 F1E0      		ldi r31,1
 3067 0c54 EF1A      		sub r14,r31
 3068 0c56 F108      		sbc r15,__zero_reg__
 3069               	.LVL319:
2066:stk500boot.c  **** 	{
 3070               		.loc 1 2066 0
 3071 0c58 01F4      		brne .L57
2075:stk500boot.c  **** 	gFlashIndex			=	0;
 3072               		.loc 1 2075 0
 3073 0c5a 1092 0000 		sts gRamIndex,__zero_reg__
 3074 0c5e 1092 0000 		sts gRamIndex+1,__zero_reg__
 3075 0c62 1092 0000 		sts gRamIndex+2,__zero_reg__
 3076 0c66 1092 0000 		sts gRamIndex+3,__zero_reg__
2076:stk500boot.c  **** 	gEepromIndex		=	0;
 3077               		.loc 1 2076 0
 3078 0c6a 1092 0000 		sts gFlashIndex,__zero_reg__
 3079 0c6e 1092 0000 		sts gFlashIndex+1,__zero_reg__
 3080 0c72 1092 0000 		sts gFlashIndex+2,__zero_reg__
 3081 0c76 1092 0000 		sts gFlashIndex+3,__zero_reg__
2077:stk500boot.c  **** 
 3082               		.loc 1 2077 0
 3083 0c7a 1092 0000 		sts gEepromIndex,__zero_reg__
 3084 0c7e 1092 0000 		sts gEepromIndex+1,__zero_reg__
 3085 0c82 1092 0000 		sts gEepromIndex+2,__zero_reg__
 3086 0c86 1092 0000 		sts gEepromIndex+3,__zero_reg__
2079:stk500boot.c  **** 
 3087               		.loc 1 2079 0
 3088 0c8a 60E0      		ldi r22,0
 3089 0c8c 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 3090 0c8e 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 3091 0c90 0E94 0000 		call PrintFromPROGMEMln
 3092               	.LVL320:
 3093               	.LBB244:
 3094               	.LBB243:
1942:stk500boot.c  **** 				while (!Serial_Available())
 3095               		.loc 1 1942 0
 3096 0c94 0FEF      		ldi r16,lo8(-1)
 3097               	.LVL321:
 3098               	.L60:
 3099               	.LBE243:
 3100               	.LBE244:
2084:stk500boot.c  **** 		theChar	=	recchar();
 3101               		.loc 1 2084 0
 3102 0c96 60E0      		ldi r22,0
 3103 0c98 80E0      		ldi r24,lo8(gTextMsg_Prompt)
 3104 0c9a 90E0      		ldi r25,hi8(gTextMsg_Prompt)
 3105 0c9c 0E94 0000 		call PrintFromPROGMEM
 3106               	.LVL322:
2085:stk500boot.c  **** 		if (theChar >= 0x60)
 3107               		.loc 1 2085 0
 3108 0ca0 0E94 0000 		call recchar
 3109               	.LVL323:
 3110 0ca4 182F      		mov r17,r24
 3111               	.LVL324:
2086:stk500boot.c  **** 		{
 3112               		.loc 1 2086 0
 3113 0ca6 8036      		cpi r24,lo8(96)
 3114 0ca8 00F0      		brlo .L138
2088:stk500boot.c  **** 		}
 3115               		.loc 1 2088 0
 3116 0caa 1F75      		andi r17,lo8(95)
 3117               	.LVL325:
 3118               	.L138:
2091:stk500boot.c  **** 		{
 3119               		.loc 1 2091 0
 3120 0cac 1032      		cpi r17,lo8(32)
 3121 0cae 00F0      		brlo .L61
2093:stk500boot.c  **** 			sendchar(0x20);
 3122               		.loc 1 2093 0
 3123 0cb0 812F      		mov r24,r17
 3124 0cb2 0E94 0000 		call sendchar
 3125               	.LVL326:
2094:stk500boot.c  **** 		}
 3126               		.loc 1 2094 0
 3127 0cb6 80E2      		ldi r24,lo8(32)
 3128 0cb8 0E94 0000 		call sendchar
 3129               	.LVL327:
2097:stk500boot.c  **** 		{
 3130               		.loc 1 2097 0
 3131 0cbc 1634      		cpi r17,lo8(70)
 3132 0cbe 01F4      		brne .+2
 3133 0cc0 00C0      		rjmp .L62
 3134 0cc2 00F0      		brlo .+2
 3135 0cc4 00C0      		rjmp .L63
 3136 0cc6 1034      		cpi r17,lo8(64)
 3137 0cc8 01F4      		brne .+2
 3138 0cca 00C0      		rjmp .L64
 3139 0ccc 00F0      		brlo .+2
 3140 0cce 00C0      		rjmp .L65
 3141 0cd0 1033      		cpi r17,lo8(48)
 3142 0cd2 01F4      		brne .+2
 3143 0cd4 00C0      		rjmp .L66
 3144 0cd6 1F33      		cpi r17,lo8(63)
 3145 0cd8 01F4      		brne .+2
 3146 0cda 00C0      		rjmp .L67
 3147               	.L61:
 3148               		.loc 1 2169 0
 3149 0cdc 60E0      		ldi r22,0
 3150 0cde 80E0      		ldi r24,lo8(gTextMsg_HUH)
 3151 0ce0 90E0      		ldi r25,hi8(gTextMsg_HUH)
 3152 0ce2 00C0      		rjmp .L272
 3153               	.LVL328:
 3154               	.L199:
 3155               	.LBE246:
 3156               	.LBE249:
 757:stk500boot.c  **** 				}
 3157               		.loc 1 757 0
 3158 0ce4 F12C      		mov r15,__zero_reg__
 3159 0ce6 E12C      		mov r14,__zero_reg__
 3160               	.LVL329:
 3161               	.L142:
 775:stk500boot.c  **** 					#else
 3162               		.loc 1 775 0
 3163 0ce8 B926      		eor r11,r25
 3164               	.LVL330:
 788:stk500boot.c  **** 
 3165               		.loc 1 788 0
 3166 0cea C85D      		subi r28,lo8(-296)
 3167 0cec DE4F      		sbci r29,hi8(-296)
 3168 0cee 9883      		st Y,r25
 3169 0cf0 C852      		subi r28,lo8(296)
 3170 0cf2 D140      		sbci r29,hi8(296)
 774:stk500boot.c  **** 						checksum		^=	c;
 3171               		.loc 1 774 0
 3172 0cf4 82E0      		ldi r24,lo8(2)
 788:stk500boot.c  **** 
 3173               		.loc 1 788 0
 3174 0cf6 00C0      		rjmp .L149
 3175               	.LVL331:
 3176               	.L201:
 757:stk500boot.c  **** 				}
 3177               		.loc 1 757 0
 3178 0cf8 F12C      		mov r15,__zero_reg__
 3179 0cfa E12C      		mov r14,__zero_reg__
 3180               	.LVL332:
 3181               	.L140:
 797:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 3182               		.loc 1 797 0
 3183 0cfc 292B      		or r18,r25
 3184               	.LVL333:
 799:stk500boot.c  **** 						break;
 3185               		.loc 1 799 0
 3186 0cfe B926      		eor r11,r25
 3187               	.LVL334:
 798:stk500boot.c  **** 						checksum		^=	c;
 3188               		.loc 1 798 0
 3189 0d00 84E0      		ldi r24,lo8(4)
 800:stk500boot.c  **** 
 3190               		.loc 1 800 0
 3191 0d02 00C0      		rjmp .L149
 3192               	.LVL335:
 3193               	.L202:
 757:stk500boot.c  **** 				}
 3194               		.loc 1 757 0
 3195 0d04 F12C      		mov r15,__zero_reg__
 3196 0d06 E12C      		mov r14,__zero_reg__
 803:stk500boot.c  **** 						{
 3197               		.loc 1 803 0
 3198 0d08 9E30      		cpi r25,lo8(14)
 3199 0d0a 01F0      		breq .+2
 3200 0d0c 00C0      		rjmp .L206
 3201               	.LVL336:
 806:stk500boot.c  **** 							ii				=	0;
 3202               		.loc 1 806 0
 3203 0d0e B926      		eor r11,r25
 3204               	.LVL337:
 807:stk500boot.c  **** 						}
 3205               		.loc 1 807 0
 3206 0d10 CE5D      		subi r28,lo8(-290)
 3207 0d12 DE4F      		sbci r29,hi8(-290)
 3208 0d14 1982      		std Y+1,__zero_reg__
 3209 0d16 1882      		st Y,__zero_reg__
 3210 0d18 C252      		subi r28,lo8(290)
 3211 0d1a D140      		sbci r29,hi8(290)
 3212               	.LVL338:
 3213               	.L269:
 818:stk500boot.c  **** 						{
 3214               		.loc 1 818 0
 3215 0d1c 85E0      		ldi r24,lo8(5)
 3216 0d1e 00C0      		rjmp .L149
 3217               	.LVL339:
 3218               	.L203:
 757:stk500boot.c  **** 				}
 3219               		.loc 1 757 0
 3220 0d20 F12C      		mov r15,__zero_reg__
 3221 0d22 E12C      		mov r14,__zero_reg__
 3222               	.LVL340:
 3223               	.L145:
 816:stk500boot.c  **** 						checksum		^=	c;
 3224               		.loc 1 816 0
 3225 0d24 CE5D      		subi r28,lo8(-290)
 3226 0d26 DE4F      		sbci r29,hi8(-290)
 3227 0d28 4881      		ld r20,Y
 3228 0d2a 5981      		ldd r21,Y+1
 3229 0d2c C252      		subi r28,lo8(290)
 3230 0d2e D140      		sbci r29,hi8(290)
 3231 0d30 4F5F      		subi r20,-1
 3232 0d32 5F4F      		sbci r21,-1
 3233               	.LVL341:
 3234 0d34 CE5D      		subi r28,lo8(-290)
 3235 0d36 DE4F      		sbci r29,hi8(-290)
 3236 0d38 E881      		ld r30,Y
 3237 0d3a F981      		ldd r31,Y+1
 3238 0d3c C252      		subi r28,lo8(290)
 3239 0d3e D140      		sbci r29,hi8(290)
 3240 0d40 E60D      		add r30,r6
 3241 0d42 F71D      		adc r31,r7
 3242 0d44 9083      		st Z,r25
 817:stk500boot.c  **** 						if (ii == msgLength )
 3243               		.loc 1 817 0
 3244 0d46 B926      		eor r11,r25
 3245               	.LVL342:
 818:stk500boot.c  **** 						{
 3246               		.loc 1 818 0
 3247 0d48 4217      		cp r20,r18
 3248 0d4a 5307      		cpc r21,r19
 3249 0d4c 01F4      		brne .+2
 3250 0d4e 00C0      		rjmp .L207
 3251 0d50 CE5D      		subi r28,lo8(-290)
 3252 0d52 DE4F      		sbci r29,hi8(-290)
 3253 0d54 5983      		std Y+1,r21
 3254 0d56 4883      		st Y,r20
 3255 0d58 C252      		subi r28,lo8(290)
 3256 0d5a D140      		sbci r29,hi8(290)
 3257 0d5c 00C0      		rjmp .L269
 3258               	.LVL343:
 3259               	.L154:
 841:stk500boot.c  **** 			{
 3260               		.loc 1 841 0
 3261 0d5e 2131      		cpi r18,lo8(17)
 3262 0d60 01F4      		brne .+2
 3263 0d62 00C0      		rjmp .L209
 3264 0d64 00F0      		brlo .+2
 3265 0d66 00C0      		rjmp .L159
 3266 0d68 2031      		cpi r18,lo8(16)
 3267 0d6a 01F4      		brne .+2
 3268 0d6c 00C0      		rjmp .L280
 3269               	.L150:
 3270               	.LVL344:
1135:stk500boot.c  **** 					break;
 3271               		.loc 1 1135 0
 3272 0d6e 80EC      		ldi r24,lo8(-64)
 3273 0d70 8A83      		std Y+2,r24
 3274 0d72 00C0      		rjmp .L277
 3275               	.LVL345:
 3276               	.L152:
 841:stk500boot.c  **** 			{
 3277               		.loc 1 841 0
 3278 0d74 2831      		cpi r18,lo8(24)
 3279 0d76 01F4      		brne .+2
 3280 0d78 00C0      		rjmp .L160
 3281 0d7a 00F4      		brsh .L161
 3282 0d7c 2531      		cpi r18,lo8(21)
 3283 0d7e 01F4      		brne .+2
 3284 0d80 00C0      		rjmp .L151
 3285 0d82 00F0      		brlo .L162
 3286 0d84 2631      		cpi r18,lo8(22)
 3287 0d86 01F4      		brne .L150
 3288               	.L162:
 3289 0d88 8A81      		ldd r24,Y+2
 3290 0d8a 9B81      		ldd r25,Y+3
 3291 0d8c 9827      		eor r25,r24
 3292 0d8e 8927      		eor r24,r25
 3293 0d90 9827      		eor r25,r24
 3294               	.LVL346:
 3295               	.LBB250:
1096:stk500boot.c  **** 
 3296               		.loc 1 1096 0
 3297 0d92 8C01      		movw r16,r24
 3298 0d94 0D5F      		subi r16,-3
 3299 0d96 1F4F      		sbci r17,-1
 3300               	.LVL347:
1098:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 3301               		.loc 1 1098 0
 3302 0d98 1A82      		std Y+2,__zero_reg__
1099:stk500boot.c  **** 						{
 3303               		.loc 1 1099 0
 3304 0d9a 2431      		cpi r18,lo8(20)
 3305 0d9c 01F0      		breq .+2
 3306 0d9e 00C0      		rjmp .L186
 3307 0da0 D301      		movw r26,r6
 3308               	.LVL348:
 3309               	.L187:
 3310               	.LBB251:
 3311               	.LBB252:
1107:stk500boot.c  **** 						#else
 3312               		.loc 1 1107 0 discriminator 1
 3313               	/* #APP */
 3314               	 ;  1107 "stk500boot.c" 1
 3315 0da2 4BBE      		out 59, r4
 3316 0da4 F101      		movw r30, r2
 3317 0da6 2791      		elpm r18, Z+
 3318 0da8 3691      		elpm r19, Z
 3319               		
 3320               	 ;  0 "" 2
 3321               	.LVL349:
 3322               	/* #NOAPP */
 3323               	.LBE252:
1111:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 3324               		.loc 1 1111 0 discriminator 1
 3325 0daa 1296      		adiw r26,2
 3326 0dac 2C93      		st X,r18
 3327 0dae 1297      		sbiw r26,2
 3328 0db0 FD01      		movw r30,r26
 3329 0db2 3496      		adiw r30,4
 3330               	.LVL350:
1112:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 3331               		.loc 1 1112 0 discriminator 1
 3332 0db4 1396      		adiw r26,3
 3333 0db6 3C93      		st X,r19
 3334 0db8 1397      		sbiw r26,3
1113:stk500boot.c  **** 								size	-=	2;
 3335               		.loc 1 1113 0 discriminator 1
 3336 0dba 22E0      		ldi r18,2
 3337 0dbc 220E      		add r2,r18
 3338 0dbe 311C      		adc r3,__zero_reg__
 3339 0dc0 411C      		adc r4,__zero_reg__
 3340 0dc2 511C      		adc r5,__zero_reg__
 3341               	.LVL351:
1114:stk500boot.c  **** 							}while (size);
 3342               		.loc 1 1114 0 discriminator 1
 3343 0dc4 0297      		sbiw r24,2
 3344               	.LVL352:
 3345 0dc6 1296      		adiw r26,2
1115:stk500boot.c  **** 						}
 3346               		.loc 1 1115 0 discriminator 1
 3347 0dc8 0097      		sbiw r24,0
 3348 0dca 01F4      		brne .L187
 3349               	.LVL353:
 3350               	.L188:
 3351               	.LBE251:
1129:stk500boot.c  **** 					}
 3352               		.loc 1 1129 0
 3353 0dcc 1082      		st Z,__zero_reg__
 3354               	.LBE250:
1131:stk500boot.c  **** 
 3355               		.loc 1 1131 0
 3356 0dce 00C0      		rjmp .L170
 3357               	.LVL354:
 3358               	.L161:
 841:stk500boot.c  **** 			{
 3359               		.loc 1 841 0
 3360 0dd0 2A31      		cpi r18,lo8(26)
 3361 0dd2 01F4      		brne .+2
 3362 0dd4 00C0      		rjmp .L163
 3363 0dd6 00F4      		brsh .+2
 3364 0dd8 00C0      		rjmp .L164
 3365 0dda 2B31      		cpi r18,lo8(27)
 3366 0ddc 01F4      		brne .+2
 3367 0dde 00C0      		rjmp .L165
 3368 0de0 2D31      		cpi r18,lo8(29)
 3369 0de2 01F0      		breq .+2
 3370 0de4 00C0      		rjmp .L150
 3371               	.LVL355:
 3372               	.LBB253:
 849:stk500boot.c  **** 						{
 3373               		.loc 1 849 0
 3374 0de6 9D81      		ldd r25,Y+5
 3375 0de8 9033      		cpi r25,lo8(48)
 3376 0dea 01F0      		breq .+2
 3377 0dec 00C0      		rjmp .L167
 3378               	.LBB254:
 851:stk500boot.c  **** 
 3379               		.loc 1 851 0
 3380 0dee 8F81      		ldd r24,Y+7
 3381               	.LVL356:
 853:stk500boot.c  **** 							{
 3382               		.loc 1 853 0
 3383 0df0 8823      		tst r24
 3384 0df2 01F4      		brne .+2
 3385 0df4 00C0      		rjmp .L210
 857:stk500boot.c  **** 							{
 3386               		.loc 1 857 0
 3387 0df6 8130      		cpi r24,lo8(1)
 3388 0df8 01F0      		breq .+2
 3389 0dfa 00C0      		rjmp .L211
 859:stk500boot.c  **** 							}
 3390               		.loc 1 859 0
 3391 0dfc 88E9      		ldi r24,lo8(-104)
 3392               	.LVL357:
 3393               	.L168:
 3394               	.LBE254:
 893:stk500boot.c  **** 							msgBuffer[2]	=	0;
 3395               		.loc 1 893 0
 3396 0dfe 1A82      		std Y+2,__zero_reg__
 894:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 3397               		.loc 1 894 0
 3398 0e00 1B82      		std Y+3,__zero_reg__
 895:stk500boot.c  **** 							msgBuffer[4]	=	0;
 3399               		.loc 1 895 0
 3400 0e02 9C83      		std Y+4,r25
 896:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 3401               		.loc 1 896 0
 3402 0e04 1D82      		std Y+5,__zero_reg__
 897:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 3403               		.loc 1 897 0
 3404 0e06 8E83      		std Y+6,r24
 898:stk500boot.c  **** 						}
 3405               		.loc 1 898 0
 3406 0e08 1F82      		std Y+7,__zero_reg__
 892:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 3407               		.loc 1 892 0
 3408 0e0a 07E0      		ldi r16,lo8(7)
 3409 0e0c 10E0      		ldi r17,0
 3410               	.LVL358:
 3411               	.L170:
 3412               	.LBE253:
1142:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
 3413               		.loc 1 1142 0
 3414 0e0e 8BE1      		ldi r24,lo8(27)
 3415 0e10 0E94 0000 		call sendchar
 3416               	.LVL359:
1145:stk500boot.c  **** 			checksum	^=	seqNum;
 3417               		.loc 1 1145 0
 3418 0e14 C85D      		subi r28,lo8(-296)
 3419 0e16 DE4F      		sbci r29,hi8(-296)
 3420 0e18 8881      		ld r24,Y
 3421 0e1a C852      		subi r28,lo8(296)
 3422 0e1c D140      		sbci r29,hi8(296)
 3423 0e1e 0E94 0000 		call sendchar
 3424               	.LVL360:
1149:stk500boot.c  **** 			checksum	^=	c;
 3425               		.loc 1 1149 0
 3426 0e22 812F      		mov r24,r17
 3427 0e24 0E94 0000 		call sendchar
 3428               	.LVL361:
1153:stk500boot.c  **** 			checksum ^= c;
 3429               		.loc 1 1153 0
 3430 0e28 802F      		mov r24,r16
 3431 0e2a 0E94 0000 		call sendchar
 3432               	.LVL362:
 3433 0e2e 95E1      		ldi r25,lo8(21)
 3434 0e30 B92E      		mov r11,r25
 3435 0e32 C85D      		subi r28,lo8(-296)
 3436 0e34 DE4F      		sbci r29,hi8(-296)
 3437 0e36 3881      		ld r19,Y
 3438 0e38 C852      		subi r28,lo8(296)
 3439 0e3a D140      		sbci r29,hi8(296)
 3440 0e3c B326      		eor r11,r19
 3441 0e3e B026      		eor r11,r16
 3442               	.LVL363:
1156:stk500boot.c  **** 			checksum ^= TOKEN;
 3443               		.loc 1 1156 0
 3444 0e40 8EE0      		ldi r24,lo8(14)
 3445 0e42 0E94 0000 		call sendchar
 3446               	.LVL364:
1157:stk500boot.c  **** 
 3447               		.loc 1 1157 0
 3448 0e46 B126      		eor r11,r17
 3449               	.LVL365:
 3450 0e48 AE01      		movw r20,r28
 3451 0e4a 4F5F      		subi r20,-1
 3452 0e4c 5F4F      		sbci r21,-1
 3453 0e4e 6A01      		movw r12,r20
 3454 0e50 040F      		add r16,r20
 3455 0e52 151F      		adc r17,r21
 3456               	.LVL366:
 3457               	.L190:
1160:stk500boot.c  **** 			{
 3458               		.loc 1 1160 0
 3459 0e54 0C15      		cp r16,r12
 3460 0e56 1D05      		cpc r17,r13
 3461 0e58 01F0      		breq .+2
 3462 0e5a 00C0      		rjmp .L191
1167:stk500boot.c  **** 			seqNum++;
 3463               		.loc 1 1167 0
 3464 0e5c 8B2D      		mov r24,r11
 3465 0e5e 0E94 0000 		call sendchar
 3466               	.LVL367:
1168:stk500boot.c  **** 	
 3467               		.loc 1 1168 0
 3468 0e62 C85D      		subi r28,lo8(-296)
 3469 0e64 DE4F      		sbci r29,hi8(-296)
 3470 0e66 B881      		ld r27,Y
 3471 0e68 C852      		subi r28,lo8(296)
 3472 0e6a D140      		sbci r29,hi8(296)
 3473 0e6c BF5F      		subi r27,lo8(-(1))
 3474 0e6e C85D      		subi r28,lo8(-296)
 3475 0e70 DE4F      		sbci r29,hi8(-296)
 3476 0e72 B883      		st Y,r27
 3477 0e74 C852      		subi r28,lo8(296)
 3478 0e76 D140      		sbci r29,hi8(296)
 3479               	.LVL368:
1172:stk500boot.c  **** 		#endif
 3480               		.loc 1 1172 0
 3481 0e78 85B1      		in r24,0x5
 3482 0e7a 8058      		subi r24,lo8(-(-128))
 3483 0e7c 85B9      		out 0x5,r24
 3484               	.LVL369:
 720:stk500boot.c  **** 		{
 3485               		.loc 1 720 0
 3486 0e7e C25E      		subi r28,lo8(-286)
 3487 0e80 DE4F      		sbci r29,hi8(-286)
 3488 0e82 E881      		ld r30,Y
 3489 0e84 CE51      		subi r28,lo8(286)
 3490 0e86 D140      		sbci r29,hi8(286)
 3491 0e88 EE23      		tst r30
 3492 0e8a 01F4      		brne .+2
 3493 0e8c 00C0      		rjmp .L216
 3494               	.LVL370:
 3495               	.L49:
1207:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 3496               		.loc 1 1207 0
 3497 0e8e 2798      		cbi 0x4,7
1208:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
 3498               		.loc 1 1208 0
 3499 0e90 2F98      		cbi 0x5,7
1210:stk500boot.c  **** #endif
 3500               		.loc 1 1210 0
 3501 0e92 84E6      		ldi r24,lo8(100)
 3502 0e94 90E0      		ldi r25,0
 3503 0e96 0E94 0000 		call delay_ms
 3504               	.LVL371:
1214:stk500boot.c  **** 
 3505               		.loc 1 1214 0
 3506               	/* #APP */
 3507               	 ;  1214 "stk500boot.c" 1
 3508 0e9a 0000      		nop
 3509               	 ;  0 "" 2
1220:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 3510               		.loc 1 1220 0
 3511               	/* #NOAPP */
 3512 0e9c 8091 C000 		lds r24,192
 3513 0ea0 8D7F      		andi r24,lo8(-3)
 3514 0ea2 8093 C000 		sts 192,r24
1221:stk500boot.c  **** 
 3515               		.loc 1 1221 0
 3516 0ea6 81E1      		ldi r24,lo8(17)
 3517               	/* #APP */
 3518               	 ;  1221 "stk500boot.c" 1
 3519 0ea8 8093 5700 		sts 87, r24
 3520 0eac E895      		spm
 3521               		
 3522               	 ;  0 "" 2
1224:stk500boot.c  **** 			"clr	r30		\n\t"
 3523               		.loc 1 1224 0
 3524               	 ;  1224 "stk500boot.c" 1
 3525 0eae EE27      		clr	r30		
 3526 0eb0 FF27      		clr	r31		
 3527 0eb2 0994      		ijmp	
 3528               		
 3529               	 ;  0 "" 2
 3530               	/* #NOAPP */
 3531               	.L192:
 3532 0eb4 00C0      		rjmp .L192
 3533               	.LVL372:
 3534               	.L167:
 3535 0eb6 892F      		mov r24,r25
 3536 0eb8 8075      		andi r24,lo8(80)
 3537               	.LBB258:
 866:stk500boot.c  **** 						{
 3538               		.loc 1 866 0
 3539 0eba 01F4      		brne .+2
 3540 0ebc 00C0      		rjmp .L168
 3541               	.LBB255:
 875:stk500boot.c  **** 							}
 3542               		.loc 1 875 0
 3543 0ebe 89E0      		ldi r24,lo8(9)
 3544 0ec0 F0E0      		ldi r31,0
 3545 0ec2 E0E0      		ldi r30,0
 3546               	.LBE255:
 873:stk500boot.c  **** 							{
 3547               		.loc 1 873 0
 3548 0ec4 9035      		cpi r25,lo8(80)
 3549 0ec6 01F0      		breq .L274
 888:stk500boot.c  **** 						}
 3550               		.loc 1 888 0
 3551 0ec8 80E0      		ldi r24,0
 877:stk500boot.c  **** 							{
 3552               		.loc 1 877 0
 3553 0eca 9835      		cpi r25,lo8(88)
 3554 0ecc 01F0      		breq .+2
 3555 0ece 00C0      		rjmp .L168
 3556               	.LBB256:
 879:stk500boot.c  **** 							}
 3557               		.loc 1 879 0
 3558 0ed0 89E0      		ldi r24,lo8(9)
 3559 0ed2 E3E0      		ldi r30,lo8(3)
 3560 0ed4 F0E0      		ldi r31,0
 3561               	.L274:
 3562               	/* #APP */
 3563               	 ;  879 "stk500boot.c" 1
 3564 0ed6 8093 5700 		sts 87, r24
 3565 0eda 8491      		lpm r24, Z
 3566               		
 3567               	 ;  0 "" 2
 3568               	.LVL373:
 3569               	/* #NOAPP */
 3570               	.LBE256:
 3571 0edc 00C0      		rjmp .L168
 3572               	.LVL374:
 3573               	.L210:
 3574               	.LBB257:
 855:stk500boot.c  **** 							}
 3575               		.loc 1 855 0
 3576 0ede 8EE1      		ldi r24,lo8(30)
 3577               	.LVL375:
 3578 0ee0 00C0      		rjmp .L168
 3579               	.LVL376:
 3580               	.L211:
 863:stk500boot.c  **** 							}
 3581               		.loc 1 863 0
 3582 0ee2 81E0      		ldi r24,lo8(1)
 3583               	.LVL377:
 3584 0ee4 00C0      		rjmp .L168
 3585               	.LVL378:
 3586               	.L156:
 3587 0ee6 EA81      		ldd r30,Y+2
 3588 0ee8 E059      		subi r30,lo8(-(112))
 3589               	.LBE257:
 3590               	.LBE258:
 3591               	.LBB259:
 921:stk500boot.c  **** 						{
 3592               		.loc 1 921 0
 3593 0eea 80E0      		ldi r24,0
 3594 0eec E330      		cpi r30,lo8(3)
 3595 0eee 00F4      		brsh .L171
 3596 0ef0 F0E0      		ldi r31,0
 3597 0ef2 E050      		subi r30,lo8(-(CSWTCH.63))
 3598 0ef4 F040      		sbci r31,hi8(-(CSWTCH.63))
 3599 0ef6 8081      		ld r24,Z
 3600               	.L171:
 3601               	.LVL379:
 943:stk500boot.c  **** 						msgBuffer[2]	=	value;
 3602               		.loc 1 943 0
 3603 0ef8 1A82      		std Y+2,__zero_reg__
 944:stk500boot.c  **** 					}
 3604               		.loc 1 944 0
 3605 0efa 8B83      		std Y+3,r24
 3606               	.LVL380:
 3607               	.L276:
 3608               	.LBE259:
 3609               	.LBB260:
1015:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3610               		.loc 1 1015 0
 3611 0efc 03E0      		ldi r16,lo8(3)
 3612 0efe 10E0      		ldi r17,0
 3613               	.LBE260:
1019:stk500boot.c  **** 	#endif
 3614               		.loc 1 1019 0
 3615 0f00 00C0      		rjmp .L170
 3616               	.LVL381:
 3617               	.L209:
 949:stk500boot.c  **** 					//*	fall thru
 3618               		.loc 1 949 0
 3619 0f02 F1E0      		ldi r31,lo8(1)
 3620 0f04 C25E      		subi r28,lo8(-286)
 3621 0f06 DE4F      		sbci r29,hi8(-286)
 3622 0f08 F883      		st Y,r31
 3623 0f0a CE51      		subi r28,lo8(286)
 3624 0f0c D140      		sbci r29,hi8(286)
 3625               	.LVL382:
 3626               	.L280:
1035:stk500boot.c  **** 					break;
 3627               		.loc 1 1035 0
 3628 0f0e 1A82      		std Y+2,__zero_reg__
 3629               	.LVL383:
 3630               	.L277:
1134:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 3631               		.loc 1 1134 0
 3632 0f10 02E0      		ldi r16,lo8(2)
 3633 0f12 10E0      		ldi r17,0
1136:stk500boot.c  **** 			}
 3634               		.loc 1 1136 0
 3635 0f14 00C0      		rjmp .L170
 3636               	.LVL384:
 3637               	.L165:
 3638               	.LBB262:
 960:stk500boot.c  **** 						unsigned char signature;
 3639               		.loc 1 960 0
 3640 0f16 8D81      		ldd r24,Y+5
 3641               	.LVL385:
 963:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 3642               		.loc 1 963 0
 3643 0f18 8823      		tst r24
 3644 0f1a 01F0      		breq .L214
 965:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 3645               		.loc 1 965 0
 3646 0f1c 8130      		cpi r24,lo8(1)
 3647 0f1e 01F4      		brne .L215
 966:stk500boot.c  **** 						else
 3648               		.loc 1 966 0
 3649 0f20 88E9      		ldi r24,lo8(-104)
 3650               	.LVL386:
 3651               	.L279:
 3652               	.LBE262:
 3653               	.LBB263:
1000:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 3654               		.loc 1 1000 0
 3655 0f22 1A82      		std Y+2,__zero_reg__
 3656 0f24 00C0      		rjmp .L278
 3657               	.LVL387:
 3658               	.L214:
 3659               	.LBE263:
 3660               	.LBB268:
 964:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 3661               		.loc 1 964 0
 3662 0f26 8EE1      		ldi r24,lo8(30)
 3663               	.LVL388:
 3664 0f28 00C0      		rjmp .L279
 3665               	.LVL389:
 3666               	.L215:
 968:stk500boot.c  **** 
 3667               		.loc 1 968 0
 3668 0f2a 81E0      		ldi r24,lo8(1)
 3669               	.LVL390:
 3670 0f2c 00C0      		rjmp .L279
 3671               	.LVL391:
 3672               	.L163:
 3673               	.LBE268:
 979:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 3674               		.loc 1 979 0
 3675 0f2e 1A82      		std Y+2,__zero_reg__
 3676               	.LBB269:
 980:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 3677               		.loc 1 980 0
 3678 0f30 89E0      		ldi r24,lo8(9)
 3679 0f32 E1E0      		ldi r30,lo8(1)
 3680 0f34 F0E0      		ldi r31,0
 3681               	/* #APP */
 3682               	 ;  980 "stk500boot.c" 1
 3683 0f36 8093 5700 		sts 87, r24
 3684 0f3a 8491      		lpm r24, Z
 3685               		
 3686               	 ;  0 "" 2
 3687               	/* #NOAPP */
 3688               	.L278:
 3689               	.LVL392:
 3690               	.LBE269:
 3691 0f3c 8B83      		std Y+3,r24
 981:stk500boot.c  **** 					break;
 3692               		.loc 1 981 0
 3693 0f3e 1C82      		std Y+4,__zero_reg__
 978:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 3694               		.loc 1 978 0
 3695 0f40 04E0      		ldi r16,lo8(4)
 3696 0f42 10E0      		ldi r17,0
 982:stk500boot.c  **** 
 3697               		.loc 1 982 0
 3698 0f44 00C0      		rjmp .L170
 3699               	.LVL393:
 3700               	.L160:
 3701               	.LBB270:
 988:stk500boot.c  **** 						{
 3702               		.loc 1 988 0
 3703 0f46 8B81      		ldd r24,Y+3
 3704 0f48 8035      		cpi r24,lo8(80)
 3705 0f4a 01F4      		brne .L173
 990:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 3706               		.loc 1 990 0
 3707 0f4c 8C81      		ldd r24,Y+4
 3708 0f4e 8830      		cpi r24,lo8(8)
 3709 0f50 01F4      		brne .L174
 3710               	.LBB264:
 991:stk500boot.c  **** 							else
 3711               		.loc 1 991 0
 3712 0f52 89E0      		ldi r24,lo8(9)
 3713 0f54 E2E0      		ldi r30,lo8(2)
 3714 0f56 F0E0      		ldi r31,0
 3715               	.L275:
 3716               	.LBE264:
 3717               	.LBB265:
 997:stk500boot.c  **** 						}
 3718               		.loc 1 997 0
 3719               	/* #APP */
 3720               	 ;  997 "stk500boot.c" 1
 3721 0f58 8093 5700 		sts 87, r24
 3722 0f5c 8491      		lpm r24, Z
 3723               		
 3724               	 ;  0 "" 2
 3725               	.LVL394:
 3726               	/* #NOAPP */
 3727 0f5e 00C0      		rjmp .L279
 3728               	.LVL395:
 3729               	.L174:
 3730               	.LBE265:
 3731               	.LBB266:
 993:stk500boot.c  **** 						}
 3732               		.loc 1 993 0
 3733 0f60 89E0      		ldi r24,lo8(9)
 3734 0f62 F0E0      		ldi r31,0
 3735 0f64 E0E0      		ldi r30,0
 3736 0f66 00C0      		rjmp .L275
 3737               	.L173:
 3738               	.LBE266:
 3739               	.LBB267:
 997:stk500boot.c  **** 						}
 3740               		.loc 1 997 0
 3741 0f68 89E0      		ldi r24,lo8(9)
 3742 0f6a E3E0      		ldi r30,lo8(3)
 3743 0f6c F0E0      		ldi r31,0
 3744 0f6e 00C0      		rjmp .L275
 3745               	.L164:
 3746               	.LVL396:
 3747               	.LBE267:
 3748               	.LBE270:
 3749               	.LBB271:
1011:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 3750               		.loc 1 1011 0
 3751 0f70 8D81      		ldd r24,Y+5
 3752               	.LVL397:
 3753               	.LBB261:
1012:stk500boot.c  **** 						boot_spm_busy_wait();
 3754               		.loc 1 1012 0
 3755 0f72 836C      		ori r24,lo8(-61)
 3756               	.LVL398:
 3757 0f74 99E0      		ldi r25,lo8(9)
 3758               	/* #APP */
 3759               	 ;  1012 "stk500boot.c" 1
 3760 0f76 E1E0      		ldi r30, 1
 3761 0f78 F0E0      		ldi r31, 0
 3762 0f7a 082E      		mov r0, r24
 3763 0f7c 9093 5700 		sts 87, r25
 3764 0f80 E895      		spm
 3765               		
 3766               	 ;  0 "" 2
 3767               	/* #NOAPP */
 3768               	.L176:
 3769               	.LBE261:
1013:stk500boot.c  **** 
 3770               		.loc 1 1013 0 discriminator 1
 3771 0f82 07B6      		in __tmp_reg__,0x37
 3772 0f84 00FC      		sbrc __tmp_reg__,0
 3773 0f86 00C0      		rjmp .L176
 3774               	.LVL399:
1016:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 3775               		.loc 1 1016 0
 3776 0f88 1A82      		std Y+2,__zero_reg__
1017:stk500boot.c  **** 					}
 3777               		.loc 1 1017 0
 3778 0f8a 1B82      		std Y+3,__zero_reg__
 3779 0f8c 00C0      		rjmp .L276
 3780               	.LVL400:
 3781               	.L159:
 3782               	.LBE271:
1025:stk500boot.c  **** 					break;
 3783               		.loc 1 1025 0
 3784 0f8e 80EC      		ldi r24,lo8(-64)
 3785 0f90 8A83      		std Y+2,r24
1023:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 3786               		.loc 1 1023 0
 3787 0f92 02E0      		ldi r16,lo8(2)
 3788 0f94 10E0      		ldi r17,0
1022:stk500boot.c  **** 					msgLength		=	2;
 3789               		.loc 1 1022 0
 3790 0f96 CC5D      		subi r28,lo8(-292)
 3791 0f98 DE4F      		sbci r29,hi8(-292)
 3792 0f9a 1882      		st Y,__zero_reg__
 3793 0f9c 1982      		std Y+1,__zero_reg__
 3794 0f9e 1A82      		std Y+2,__zero_reg__
 3795 0fa0 1B82      		std Y+3,__zero_reg__
 3796 0fa2 C452      		subi r28,lo8(292)
 3797 0fa4 D140      		sbci r29,hi8(292)
1026:stk500boot.c  **** 
 3798               		.loc 1 1026 0
 3799 0fa6 00C0      		rjmp .L170
 3800               	.LVL401:
 3801               	.L153:
 3802 0fa8 6A81      		ldd r22,Y+2
 3803 0faa 7B81      		ldd r23,Y+3
 3804 0fac 8C81      		ldd r24,Y+4
 3805 0fae 9D81      		ldd r25,Y+5
 3806 0fb0 0E94 0000 		call __bswapsi2
1030:stk500boot.c  **** 	#else
 3807               		.loc 1 1030 0
 3808 0fb4 1B01      		movw r2,r22
 3809 0fb6 2C01      		movw r4,r24
 3810 0fb8 220C      		lsl r2
 3811 0fba 331C      		rol r3
 3812 0fbc 441C      		rol r4
 3813 0fbe 551C      		rol r5
 3814 0fc0 00C0      		rjmp .L280
 3815               	.L151:
 3816 0fc2 0A81      		ldd r16,Y+2
 3817 0fc4 1B81      		ldd r17,Y+3
 3818 0fc6 1027      		eor r17,r16
 3819 0fc8 0127      		eor r16,r17
 3820 0fca 1027      		eor r17,r16
 3821               	.LVL402:
 3822               	.LBB272:
1048:stk500boot.c  **** 						{
 3823               		.loc 1 1048 0
 3824 0fcc 2331      		cpi r18,lo8(19)
 3825 0fce 01F0      		breq .+2
 3826 0fd0 00C0      		rjmp .L177
1051:stk500boot.c  **** 							{
 3827               		.loc 1 1051 0
 3828 0fd2 CC5D      		subi r28,lo8(-292)
 3829 0fd4 DE4F      		sbci r29,hi8(-292)
 3830 0fd6 2881      		ld r18,Y
 3831 0fd8 3981      		ldd r19,Y+1
 3832 0fda 4A81      		ldd r20,Y+2
 3833 0fdc 5B81      		ldd r21,Y+3
 3834 0fde C452      		subi r28,lo8(292)
 3835 0fe0 D140      		sbci r29,hi8(292)
 3836 0fe2 2115      		cp r18,__zero_reg__
 3837 0fe4 80EC      		ldi r24,-64
 3838 0fe6 3807      		cpc r19,r24
 3839 0fe8 83E0      		ldi r24,3
 3840 0fea 4807      		cpc r20,r24
 3841 0fec 5105      		cpc r21,__zero_reg__
 3842 0fee 00F4      		brsh .L178
1053:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 3843               		.loc 1 1053 0
 3844 0ff0 83E0      		ldi r24,lo8(3)
 3845               	/* #APP */
 3846               	 ;  1053 "stk500boot.c" 1
 3847 0ff2 F901      		movw r30, r18
 3848 0ff4 4093 5B00 		sts  91, r20
 3849 0ff8 8093 5700 		sts 87, r24
 3850 0ffc E895      		spm
 3851               		
 3852               	 ;  0 "" 2
 3853               	/* #NOAPP */
 3854               	.L179:
1054:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 3855               		.loc 1 1054 0 discriminator 1
 3856 0ffe 07B6      		in __tmp_reg__,0x37
 3857 1000 00FC      		sbrc __tmp_reg__,0
 3858 1002 00C0      		rjmp .L179
1055:stk500boot.c  **** 							}
 3859               		.loc 1 1055 0
 3860 1004 CC5D      		subi r28,lo8(-292)
 3861 1006 DE4F      		sbci r29,hi8(-292)
 3862 1008 2881      		ld r18,Y
 3863 100a 3981      		ldd r19,Y+1
 3864 100c 4A81      		ldd r20,Y+2
 3865 100e 5B81      		ldd r21,Y+3
 3866 1010 C452      		subi r28,lo8(292)
 3867 1012 D140      		sbci r29,hi8(292)
 3868 1014 3F5F      		subi r19,-1
 3869 1016 4F4F      		sbci r20,-1
 3870 1018 5F4F      		sbci r21,-1
 3871 101a CC5D      		subi r28,lo8(-292)
 3872 101c DE4F      		sbci r29,hi8(-292)
 3873 101e 2883      		st Y,r18
 3874 1020 3983      		std Y+1,r19
 3875 1022 4A83      		std Y+2,r20
 3876 1024 5B83      		std Y+3,r21
 3877 1026 C452      		subi r28,lo8(292)
 3878 1028 D140      		sbci r29,hi8(292)
 3879               	.LVL403:
 3880               	.L178:
 3881 102a 8B85      		ldd r24,Y+11
 3882 102c DE01      		movw r26,r28
 3883 102e 1196      		adiw r26,1
 3884               	.LBE272:
 3885               	.LBB274:
 968:stk500boot.c  **** 
 3886               		.loc 1 968 0 discriminator 1
 3887 1030 B201      		movw r22,r4
 3888 1032 A101      		movw r20,r2
 3889               	.LBE274:
 3890               	.LBB275:
1064:stk500boot.c  **** 
 3891               		.loc 1 1064 0 discriminator 1
 3892 1034 21E0      		ldi r18,lo8(1)
 3893               	.L181:
 3894               	.LVL404:
1063:stk500boot.c  **** 								boot_page_fill(address,data);
 3895               		.loc 1 1063 0 discriminator 1
 3896 1036 1B96      		adiw r26,11
 3897 1038 9C91      		ld r25,X
 3898 103a 1B97      		sbiw r26,11
1064:stk500boot.c  **** 
 3899               		.loc 1 1064 0 discriminator 1
 3900               	/* #APP */
 3901               	 ;  1064 "stk500boot.c" 1
 3902 103c 0C01      		movw  r0, r24
 3903 103e FA01      		movw r30, r20
 3904 1040 6093 5B00 		sts 91, r22
 3905 1044 2093 5700 		sts 87, r18
 3906 1048 E895      		spm
 3907 104a 1124      		clr  r1
 3908               		
 3909               	 ;  0 "" 2
1066:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 3910               		.loc 1 1066 0 discriminator 1
 3911               	/* #NOAPP */
 3912 104c 4E5F      		subi r20,-2
 3913 104e 5F4F      		sbci r21,-1
 3914 1050 6F4F      		sbci r22,-1
 3915 1052 7F4F      		sbci r23,-1
 3916               	.LVL405:
1067:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 3917               		.loc 1 1067 0 discriminator 1
 3918 1054 0250      		subi r16,2
 3919 1056 1109      		sbc r17,__zero_reg__
 3920               	.LVL406:
 3921 1058 1296      		adiw r26,2
 3922               	.LVL407:
1068:stk500boot.c  **** 
 3923               		.loc 1 1068 0 discriminator 1
 3924 105a 0115      		cp r16,__zero_reg__
 3925 105c 1105      		cpc r17,__zero_reg__
 3926 105e 01F0      		breq .L180
1061:stk500boot.c  **** 
 3927               		.loc 1 1061 0
 3928 1060 1A96      		adiw r26,10
 3929 1062 8C91      		ld r24,X
 3930 1064 1A97      		sbiw r26,10
 3931               	.LVL408:
 3932 1066 00C0      		rjmp .L181
 3933               	.LVL409:
 3934               	.L180:
1070:stk500boot.c  **** 							boot_spm_busy_wait();
 3935               		.loc 1 1070 0
 3936 1068 35E0      		ldi r19,lo8(5)
 3937               	/* #APP */
 3938               	 ;  1070 "stk500boot.c" 1
 3939 106a F101      		movw r30, r2
 3940 106c 4092 5B00 		sts 91, r4
 3941 1070 3093 5700 		sts 87, r19
 3942 1074 E895      		spm
 3943               		
 3944               	 ;  0 "" 2
 3945               	/* #NOAPP */
 3946               	.L182:
1071:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 3947               		.loc 1 1071 0 discriminator 1
 3948 1076 07B6      		in __tmp_reg__,0x37
 3949 1078 00FC      		sbrc __tmp_reg__,0
 3950 107a 00C0      		rjmp .L182
1072:stk500boot.c  **** 						}
 3951               		.loc 1 1072 0
 3952 107c 81E1      		ldi r24,lo8(17)
 3953               	.LVL410:
 3954               	/* #APP */
 3955               	 ;  1072 "stk500boot.c" 1
 3956 107e 8093 5700 		sts 87, r24
 3957 1082 E895      		spm
 3958               		
 3959               	 ;  0 "" 2
 3960               	.LVL411:
 3961               	/* #NOAPP */
 3962               	.L183:
1087:stk500boot.c  **** 					}
 3963               		.loc 1 1087 0
 3964 1084 1A82      		std Y+2,__zero_reg__
 3965               	.LBE275:
1089:stk500boot.c  **** 
 3966               		.loc 1 1089 0
 3967 1086 1A01      		movw r2,r20
 3968               	.LVL412:
 3969 1088 2B01      		movw r4,r22
 3970 108a 00C0      		rjmp .L277
 3971               	.LVL413:
 3972               	.L177:
 3973               	.LBB276:
 3974               	.LBB273:
1077:stk500boot.c  **** 							/* write EEPROM */
 3975               		.loc 1 1077 0
 3976 108c D201      		movw r26,r4
 3977 108e C101      		movw r24,r2
 3978 1090 B695      		lsr r27
 3979 1092 A795      		ror r26
 3980 1094 9795      		ror r25
 3981 1096 8795      		ror r24
 3982               	.LVL414:
 3983 1098 4301      		movw r8,r6
 3984 109a 800E      		add r8,r16
 3985 109c 911E      		adc r9,r17
1079:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 3986               		.loc 1 1079 0
 3987 109e 6301      		movw r12,r6
1080:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 3988               		.loc 1 1080 0
 3989 10a0 5C01      		movw r10,r24
 3990 10a2 A618      		sub r10,r6
 3991 10a4 B708      		sbc r11,r7
 3992               	.LVL415:
 3993               	.L184:
1079:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 3994               		.loc 1 1079 0
 3995 10a6 8C14      		cp r8,r12
 3996 10a8 9D04      		cpc r9,r13
 3997 10aa 01F4      		brne .L185
 3998 10ac 30E0      		ldi r19,0
 3999 10ae 20E0      		ldi r18,0
 4000 10b0 000F      		lsl r16
 4001 10b2 111F      		rol r17
 4002 10b4 221F      		rol r18
 4003 10b6 331F      		rol r19
 4004 10b8 B901      		movw r22,r18
 4005 10ba A801      		movw r20,r16
 4006 10bc 420D      		add r20,r2
 4007 10be 531D      		adc r21,r3
 4008 10c0 641D      		adc r22,r4
 4009 10c2 751D      		adc r23,r5
 4010 10c4 00C0      		rjmp .L183
 4011               	.L185:
 4012               	.LVL416:
1080:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 4013               		.loc 1 1080 0
 4014 10c6 D601      		movw r26,r12
 4015 10c8 1A96      		adiw r26,10
 4016 10ca 6C91      		ld r22,X
 4017 10cc C501      		movw r24,r10
 4018 10ce 8C0D      		add r24,r12
 4019 10d0 9D1D      		adc r25,r13
 4020 10d2 0E94 0000 		call eeprom_write_byte
 4021               	.LVL417:
 4022 10d6 BFEF      		ldi r27,-1
 4023 10d8 CB1A      		sub r12,r27
 4024 10da DB0A      		sbc r13,r27
 4025               	.LVL418:
 4026 10dc 00C0      		rjmp .L184
 4027               	.LVL419:
 4028               	.L186:
 4029 10de F301      		movw r30,r6
 4030 10e0 9301      		movw r18,r6
 4031 10e2 280F      		add r18,r24
 4032 10e4 391F      		adc r19,r25
 4033               	.LBE273:
 4034               	.LBE276:
 4035               	.LBB277:
1099:stk500boot.c  **** 						{
 4036               		.loc 1 1099 0
 4037 10e6 B201      		movw r22,r4
 4038 10e8 A101      		movw r20,r2
 4039               	.LVL420:
 4040               	.L189:
1121:stk500boot.c  **** 								EEARH	=	((address >> 8));
 4041               		.loc 1 1121 0 discriminator 1
 4042 10ea 41BD      		out 0x21,r20
1122:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 4043               		.loc 1 1122 0 discriminator 1
 4044 10ec 852E      		mov r8,r21
 4045 10ee 962E      		mov r9,r22
 4046 10f0 A72E      		mov r10,r23
 4047 10f2 BB24      		clr r11
 4048 10f4 82BC      		out 0x22,r8
1123:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 4049               		.loc 1 1123 0 discriminator 1
 4050 10f6 4F5F      		subi r20,-1
 4051 10f8 5F4F      		sbci r21,-1
 4052 10fa 6F4F      		sbci r22,-1
 4053 10fc 7F4F      		sbci r23,-1
 4054               	.LVL421:
1124:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 4055               		.loc 1 1124 0 discriminator 1
 4056 10fe F89A      		sbi 0x1f,0
 4057               	.LVL422:
1125:stk500boot.c  **** 								size--;
 4058               		.loc 1 1125 0 discriminator 1
 4059 1100 A0B5      		in r26,0x20
 4060 1102 A283      		std Z+2,r26
 4061 1104 3196      		adiw r30,1
 4062               	.LVL423:
1127:stk500boot.c  **** 						}
 4063               		.loc 1 1127 0 discriminator 1
 4064 1106 E217      		cp r30,r18
 4065 1108 F307      		cpc r31,r19
 4066 110a 01F4      		brne .L189
 4067 110c AC01      		movw r20,r24
 4068               	.LVL424:
 4069 110e 4150      		subi r20,1
 4070 1110 5109      		sbc r21,__zero_reg__
 4071 1112 70E0      		ldi r23,0
 4072 1114 60E0      		ldi r22,0
 4073 1116 4F5F      		subi r20,-1
 4074 1118 5F4F      		sbci r21,-1
 4075 111a 6F4F      		sbci r22,-1
 4076 111c 7F4F      		sbci r23,-1
 4077 111e 240E      		add r2,r20
 4078 1120 351E      		adc r3,r21
 4079 1122 461E      		adc r4,r22
 4080 1124 571E      		adc r5,r23
 4081 1126 E3E0      		ldi r30,lo8(3)
 4082 1128 F0E0      		ldi r31,0
 4083               	.LVL425:
 4084 112a EC0F      		add r30,r28
 4085 112c FD1F      		adc r31,r29
 4086 112e E80F      		add r30,r24
 4087 1130 F91F      		adc r31,r25
 4088 1132 00C0      		rjmp .L188
 4089               	.LVL426:
 4090               	.L191:
 4091               	.LBE277:
1162:stk500boot.c  **** 				sendchar(c);
 4092               		.loc 1 1162 0
 4093 1134 D601      		movw r26,r12
 4094 1136 AD90      		ld r10,X+
 4095               	.LVL427:
 4096 1138 6D01      		movw r12,r26
 4097               	.LVL428:
1163:stk500boot.c  **** 				checksum ^=c;
 4098               		.loc 1 1163 0
 4099 113a 8A2D      		mov r24,r10
 4100 113c 0E94 0000 		call sendchar
 4101               	.LVL429:
1164:stk500boot.c  **** 				msgLength--;
 4102               		.loc 1 1164 0
 4103 1140 BA24      		eor r11,r10
 4104               	.LVL430:
 4105 1142 00C0      		rjmp .L190
 4106               	.LVL431:
 4107               	.L216:
 4108 1144 50E0      		ldi r21,0
 4109 1146 40E0      		ldi r20,0
 4110 1148 0C94 0000 		jmp .L48
 4111               	.LVL432:
 4112               	.L205:
 767:stk500boot.c  **** 						}
 4113               		.loc 1 767 0
 4114 114c 8BE1      		ldi r24,lo8(27)
 4115 114e B82E      		mov r11,r24
 4116               	.LVL433:
 766:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 4117               		.loc 1 766 0
 4118 1150 81E0      		ldi r24,lo8(1)
 4119 1152 00C0      		rjmp .L149
 4120               	.LVL434:
 4121               	.L207:
 4122 1154 CE5D      		subi r28,lo8(-290)
 4123 1156 DE4F      		sbci r29,hi8(-290)
 4124 1158 3983      		std Y+1,r19
 4125 115a 2883      		st Y,r18
 4126 115c C252      		subi r28,lo8(290)
 4127 115e D140      		sbci r29,hi8(290)
 820:stk500boot.c  **** 						}
 4128               		.loc 1 820 0
 4129 1160 86E0      		ldi r24,lo8(6)
 4130               	.LVL435:
 4131 1162 00C0      		rjmp .L149
 4132               	.LVL436:
 4133               	.L196:
 757:stk500boot.c  **** 				}
 4134               		.loc 1 757 0
 4135 1164 F12C      		mov r15,__zero_reg__
 4136 1166 E12C      		mov r14,__zero_reg__
 4137               	.LVL437:
 4138               	.L56:
 761:stk500boot.c  **** 				{
 4139               		.loc 1 761 0
 4140 1168 8330      		cpi r24,lo8(3)
 4141 116a 01F4      		brne .+2
 4142 116c 00C0      		rjmp .L140
 4143 116e 00F4      		brsh .L194
 4144 1170 8130      		cpi r24,lo8(1)
 4145 1172 01F4      		brne .+2
 4146 1174 00C0      		rjmp .L142
 4147 1176 00F4      		brsh .+2
 4148 1178 00C0      		rjmp .L149
 4149 117a 00C0      		rjmp .L143
 4150               	.L194:
 4151 117c 8530      		cpi r24,lo8(5)
 4152 117e 01F4      		brne .+2
 4153 1180 00C0      		rjmp .L145
 4154 1182 00F0      		brlo .L206
 4155 1184 8630      		cpi r24,lo8(6)
 4156 1186 01F0      		breq .+2
 4157 1188 00C0      		rjmp .L139
 4158               	.LVL438:
 4159               	.L147:
 825:stk500boot.c  **** 						{
 4160               		.loc 1 825 0
 4161 118a 9B15      		cp r25,r11
 4162 118c 01F4      		brne .+2
 4163 118e 00C0      		rjmp .L208
 4164               	.L206:
 811:stk500boot.c  **** 						}
 4165               		.loc 1 811 0
 4166 1190 80E0      		ldi r24,0
 4167               	.LVL439:
 4168 1192 00C0      		rjmp .L149
 4169               		.cfi_endproc
 4170               	.LFE23:
 4172               		.section	.rodata
 4175               	CSWTCH.63:
 4176 0000 0F        		.byte	15
 4177 0001 02        		.byte	2
 4178 0002 0A        		.byte	10
 4179               	.global	gTextMsg_END
 4180               		.section	.progmem.data,"a",@progbits
 4183               	gTextMsg_END:
 4184 0000 2A00      		.string	"*"
 4185               	.global	gTextMsg_HELP_MSG_Y
 4188               	gTextMsg_HELP_MSG_Y:
 4189 0002 593D 506F 		.string	"Y=Port blink"
 4189      7274 2062 
 4189      6C69 6E6B 
 4189      00
 4190               	.global	gTextMsg_HELP_MSG_V
 4193               	gTextMsg_HELP_MSG_V:
 4194 000f 563D 7368 		.string	"V=show interrupt Vectors"
 4194      6F77 2069 
 4194      6E74 6572 
 4194      7275 7074 
 4194      2056 6563 
 4195               	.global	gTextMsg_HELP_MSG_R
 4198               	gTextMsg_HELP_MSG_R:
 4199 0028 523D 4475 		.string	"R=Dump RAM"
 4199      6D70 2052 
 4199      414D 00
 4200               	.global	gTextMsg_HELP_MSG_Q
 4203               	gTextMsg_HELP_MSG_Q:
 4204 0033 513D 5175 		.string	"Q=Quit"
 4204      6974 00
 4205               	.global	gTextMsg_HELP_MSG_L
 4208               	gTextMsg_HELP_MSG_L:
 4209 003a 4C3D 4C69 		.string	"L=List I/O Ports"
 4209      7374 2049 
 4209      2F4F 2050 
 4209      6F72 7473 
 4209      00
 4210               	.global	gTextMsg_HELP_MSG_H
 4213               	gTextMsg_HELP_MSG_H:
 4214 004b 483D 4865 		.string	"H=Help"
 4214      6C70 00
 4215               	.global	gTextMsg_HELP_MSG_F
 4218               	gTextMsg_HELP_MSG_F:
 4219 0052 463D 4475 		.string	"F=Dump FLASH"
 4219      6D70 2046 
 4219      4C41 5348 
 4219      00
 4220               	.global	gTextMsg_HELP_MSG_E
 4223               	gTextMsg_HELP_MSG_E:
 4224 005f 453D 4475 		.string	"E=Dump EEPROM"
 4224      6D70 2045 
 4224      4550 524F 
 4224      4D00 
 4225               	.global	gTextMsg_HELP_MSG_B
 4228               	gTextMsg_HELP_MSG_B:
 4229 006d 423D 426C 		.string	"B=Blink LED"
 4229      696E 6B20 
 4229      4C45 4400 
 4230               	.global	gTextMsg_HELP_MSG_AT
 4233               	gTextMsg_HELP_MSG_AT:
 4234 0079 403D 4545 		.string	"@=EEPROM test"
 4234      5052 4F4D 
 4234      2074 6573 
 4234      7400 
 4235               	.global	gTextMsg_HELP_MSG_QM
 4238               	gTextMsg_HELP_MSG_QM:
 4239 0087 3F3D 4350 		.string	"?=CPU stats"
 4239      5520 7374 
 4239      6174 7300 
 4240               	.global	gTextMsg_HELP_MSG_0
 4243               	gTextMsg_HELP_MSG_0:
 4244 0093 303D 5A65 		.string	"0=Zero addr"
 4244      726F 2061 
 4244      6464 7200 
 4245               	.global	gTextMsg_PORT
 4248               	gTextMsg_PORT:
 4249 009f 504F 5254 		.string	"PORT"
 4249      00
 4250               	.global	gTextMsg_EEPROMerrorCnt
 4253               	gTextMsg_EEPROMerrorCnt:
 4254 00a4 4545 2065 		.string	"EE err cnt="
 4254      7272 2063 
 4254      6E74 3D00 
 4255               	.global	gTextMsg_ReadingEEprom
 4258               	gTextMsg_ReadingEEprom:
 4259 00b0 5265 6164 		.string	"Reading EE"
 4259      696E 6720 
 4259      4545 00
 4260               	.global	gTextMsg_WriteToEEprom
 4263               	gTextMsg_WriteToEEprom:
 4264 00bb 5772 6974 		.string	"Writting EE"
 4264      7469 6E67 
 4264      2045 4500 
 4265               	.global	gTextMsg_SPACE
 4268               	gTextMsg_SPACE:
 4269 00c7 2000      		.string	" "
 4270               	.global	gTextMsg_MustBeLetter
 4273               	gTextMsg_MustBeLetter:
 4274 00c9 4D75 7374 		.string	"Must be a letter"
 4274      2062 6520 
 4274      6120 6C65 
 4274      7474 6572 
 4274      00
 4275               	.global	gTextMsg_PortNotSupported
 4278               	gTextMsg_PortNotSupported:
 4279 00da 506F 7274 		.string	"Port not supported"
 4279      206E 6F74 
 4279      2073 7570 
 4279      706F 7274 
 4279      6564 00
 4280               	.global	gTextMsg_WHAT_PORT
 4283               	gTextMsg_WHAT_PORT:
 4284 00ed 5768 6174 		.string	"What port:"
 4284      2070 6F72 
 4284      743A 00
 4285               	.global	gTextMsg_jmp
 4288               	gTextMsg_jmp:
 4289 00f8 6A6D 7020 		.string	"jmp "
 4289      00
 4290               	.global	gTextMsg_rjmp
 4293               	gTextMsg_rjmp:
 4294 00fd 726A 6D70 		.string	"rjmp  "
 4294      2020 00
 4295               	.global	gTextMsg_noVector
 4298               	gTextMsg_noVector:
 4299 0104 6E6F 2076 		.string	"no vector"
 4299      6563 746F 
 4299      7200 
 4300               	.global	gTextMsg_VECTOR_HEADER
 4303               	gTextMsg_VECTOR_HEADER:
 4304 010e 5623 2020 		.string	"V#   ADDR   op code     instruction addr   Interrupt"
 4304      2041 4444 
 4304      5220 2020 
 4304      6F70 2063 
 4304      6F64 6520 
 4305               	.global	gTextMsg_GCC_VERSION_STR
 4308               	gTextMsg_GCC_VERSION_STR:
 4309 0143 372E 332E 		.string	"7.3.0"
 4309      3000 
 4310               	.global	gTextMsg_AVR_LIBC_VER_STR
 4313               	gTextMsg_AVR_LIBC_VER_STR:
 4314 0149 322E 302E 		.string	"2.0.0"
 4314      3000 
 4315               	.global	gTextMsg_GCC_DATE_STR
 4318               	gTextMsg_GCC_DATE_STR:
 4319 014f 4A61 6E20 		.string	"Jan 23 2026"
 4319      3233 2032 
 4319      3032 3600 
 4320               	.global	gTextMsg_FUSE_BYTE_LOCK
 4323               	gTextMsg_FUSE_BYTE_LOCK:
 4324 015b 4C6F 636B 		.string	"Lock fuse   = "
 4324      2066 7573 
 4324      6520 2020 
 4324      3D20 00
 4325               	.global	gTextMsg_FUSE_BYTE_EXT
 4328               	gTextMsg_FUSE_BYTE_EXT:
 4329 016a 4578 7420 		.string	"Ext fuse    = "
 4329      6675 7365 
 4329      2020 2020 
 4329      3D20 00
 4330               	.global	gTextMsg_FUSE_BYTE_HIGH
 4333               	gTextMsg_FUSE_BYTE_HIGH:
 4334 0179 4869 6768 		.string	"High fuse   = "
 4334      2066 7573 
 4334      6520 2020 
 4334      3D20 00
 4335               	.global	gTextMsg_FUSE_BYTE_LOW
 4338               	gTextMsg_FUSE_BYTE_LOW:
 4339 0188 4C6F 7720 		.string	"Low fuse    = "
 4339      6675 7365 
 4339      2020 2020 
 4339      3D20 00
 4340               	.global	gTextMsg_CPU_SIGNATURE
 4343               	gTextMsg_CPU_SIGNATURE:
 4344 0197 4350 5520 		.string	"CPU ID      = "
 4344      4944 2020 
 4344      2020 2020 
 4344      3D20 00
 4345               	.global	gTextMsg_GCC_VERSION
 4348               	gTextMsg_GCC_VERSION:
 4349 01a6 4743 4320 		.string	"GCC Version = "
 4349      5665 7273 
 4349      696F 6E20 
 4349      3D20 00
 4350               	.global	gTextMsg_AVR_LIBC
 4353               	gTextMsg_AVR_LIBC:
 4354 01b5 4156 5220 		.string	"AVR LibC Ver= "
 4354      4C69 6243 
 4354      2056 6572 
 4354      3D20 00
 4355               	.global	gTextMsg_AVR_ARCH
 4358               	gTextMsg_AVR_ARCH:
 4359 01c4 5F5F 4156 		.string	"__AVR_ARCH__= "
 4359      525F 4152 
 4359      4348 5F5F 
 4359      3D20 00
 4360               	.global	gTextMsg_CPU_Type
 4363               	gTextMsg_CPU_Type:
 4364 01d3 4350 5520 		.string	"CPU Type    = "
 4364      5479 7065 
 4364      2020 2020 
 4364      3D20 00
 4365               	.global	gTextMsg_COMPILED_ON
 4368               	gTextMsg_COMPILED_ON:
 4369 01e2 436F 6D70 		.string	"Compiled on = "
 4369      696C 6564 
 4369      206F 6E20 
 4369      3D20 00
 4370               	.global	gTextMsg_HUH
 4373               	gTextMsg_HUH:
 4374 01f1 4875 683F 		.string	"Huh?"
 4374      00
 4375               	.global	gTextMsg_Prompt
 4378               	gTextMsg_Prompt:
 4379 01f6 426F 6F74 		.string	"Bootloader>"
 4379      6C6F 6164 
 4379      6572 3E00 
 4380               	.global	gTextMsg_Explorer
 4383               	gTextMsg_Explorer:
 4384 0202 4172 6475 		.string	"Arduino explorer stk500V2 by MLS"
 4384      696E 6F20 
 4384      6578 706C 
 4384      6F72 6572 
 4384      2073 746B 
 4385               	.global	gTextMsg_CPU_Name
 4388               	gTextMsg_CPU_Name:
 4389 0223 4154 6D65 		.string	"ATmega2560"
 4389      6761 3235 
 4389      3630 00
 4390               		.comm	gEepromIndex,4,1
 4391               		.comm	gFlashIndex,4,1
 4392               		.comm	gRamIndex,4,1
 4393               	.global	app_start
 4394               		.section .bss
 4397               	app_start:
 4398 0000 0000      		.zero	2
 4399               		.text
 4400               	.Letext0:
 4401               		.file 3 "/usr/lib/avr/include/stdint.h"
 4402               		.file 4 "/usr/lib/gcc/avr/7.3.0/include/stddef.h"
 4403               		.file 5 "/usr/lib/avr/include/stdlib.h"
 4404               		.file 6 "/usr/lib/avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 stk500boot.c
     /tmp/ccG1xuE7.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccG1xuE7.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccG1xuE7.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccG1xuE7.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccG1xuE7.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccG1xuE7.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccG1xuE7.s:12     .text:0000000000000000 sendchar
     /tmp/ccG1xuE7.s:43     .text.unlikely:0000000000000000 recchar
     /tmp/ccG1xuE7.s:67     .init9:0000000000000000 __jumpMain
     /tmp/ccG1xuE7.s:78     *ABS*:00000000000021ff __stack
     /tmp/ccG1xuE7.s:788    .text.startup:0000000000000000 main
     /tmp/ccG1xuE7.s:117    .text:0000000000000018 delay_ms
     /tmp/ccG1xuE7.s:163    .text:0000000000000036 PrintFromPROGMEM
     /tmp/ccG1xuE7.s:226    .text:000000000000005e PrintNewLine
     /tmp/ccG1xuE7.s:247    .text.unlikely:000000000000000e PrintAvailablePort
     /tmp/ccG1xuE7.s:4248   .progmem.data:000000000000009f gTextMsg_PORT
     /tmp/ccG1xuE7.s:285    .text:000000000000006a PrintFromPROGMEMln
     /tmp/ccG1xuE7.s:305    .text:0000000000000072 PrintString
     /tmp/ccG1xuE7.s:348    .text:000000000000008a PrintHexByte
     /tmp/ccG1xuE7.s:408    .text.unlikely:0000000000000028 DumpHex.constprop.0
     /tmp/ccG1xuE7.s:688    .text:00000000000000b8 PrintDecInt
     /tmp/ccG1xuE7.s:4397   .bss:0000000000000000 app_start
     /tmp/ccG1xuE7.s:4223   .progmem.data:000000000000005f gTextMsg_HELP_MSG_E
                            *COM*:0000000000000004 gEepromIndex
     /tmp/ccG1xuE7.s:4208   .progmem.data:000000000000003a gTextMsg_HELP_MSG_L
     /tmp/ccG1xuE7.s:4198   .progmem.data:0000000000000028 gTextMsg_HELP_MSG_R
                            *COM*:0000000000000004 gRamIndex
     /tmp/ccG1xuE7.s:4243   .progmem.data:0000000000000093 gTextMsg_HELP_MSG_0
                            *COM*:0000000000000004 gFlashIndex
     /tmp/ccG1xuE7.s:4238   .progmem.data:0000000000000087 gTextMsg_HELP_MSG_QM
     /tmp/ccG1xuE7.s:4383   .progmem.data:0000000000000202 gTextMsg_Explorer
     /tmp/ccG1xuE7.s:4368   .progmem.data:00000000000001e2 gTextMsg_COMPILED_ON
     /tmp/ccG1xuE7.s:4318   .progmem.data:000000000000014f gTextMsg_GCC_DATE_STR
     /tmp/ccG1xuE7.s:4363   .progmem.data:00000000000001d3 gTextMsg_CPU_Type
     /tmp/ccG1xuE7.s:4388   .progmem.data:0000000000000223 gTextMsg_CPU_Name
     /tmp/ccG1xuE7.s:4358   .progmem.data:00000000000001c4 gTextMsg_AVR_ARCH
     /tmp/ccG1xuE7.s:4348   .progmem.data:00000000000001a6 gTextMsg_GCC_VERSION
     /tmp/ccG1xuE7.s:4308   .progmem.data:0000000000000143 gTextMsg_GCC_VERSION_STR
     /tmp/ccG1xuE7.s:4353   .progmem.data:00000000000001b5 gTextMsg_AVR_LIBC
     /tmp/ccG1xuE7.s:4313   .progmem.data:0000000000000149 gTextMsg_AVR_LIBC_VER_STR
     /tmp/ccG1xuE7.s:4343   .progmem.data:0000000000000197 gTextMsg_CPU_SIGNATURE
     /tmp/ccG1xuE7.s:4338   .progmem.data:0000000000000188 gTextMsg_FUSE_BYTE_LOW
     /tmp/ccG1xuE7.s:4333   .progmem.data:0000000000000179 gTextMsg_FUSE_BYTE_HIGH
     /tmp/ccG1xuE7.s:4328   .progmem.data:000000000000016a gTextMsg_FUSE_BYTE_EXT
     /tmp/ccG1xuE7.s:4323   .progmem.data:000000000000015b gTextMsg_FUSE_BYTE_LOCK
     /tmp/ccG1xuE7.s:4233   .progmem.data:0000000000000079 gTextMsg_HELP_MSG_AT
     /tmp/ccG1xuE7.s:4263   .progmem.data:00000000000000bb gTextMsg_WriteToEEprom
     /tmp/ccG1xuE7.s:4258   .progmem.data:00000000000000b0 gTextMsg_ReadingEEprom
     /tmp/ccG1xuE7.s:4253   .progmem.data:00000000000000a4 gTextMsg_EEPROMerrorCnt
     /tmp/ccG1xuE7.s:4268   .progmem.data:00000000000000c7 gTextMsg_SPACE
     /tmp/ccG1xuE7.s:4228   .progmem.data:000000000000006d gTextMsg_HELP_MSG_B
     /tmp/ccG1xuE7.s:4218   .progmem.data:0000000000000052 gTextMsg_HELP_MSG_F
     /tmp/ccG1xuE7.s:4213   .progmem.data:000000000000004b gTextMsg_HELP_MSG_H
     /tmp/ccG1xuE7.s:4203   .progmem.data:0000000000000033 gTextMsg_HELP_MSG_Q
     /tmp/ccG1xuE7.s:4193   .progmem.data:000000000000000f gTextMsg_HELP_MSG_V
     /tmp/ccG1xuE7.s:4188   .progmem.data:0000000000000002 gTextMsg_HELP_MSG_Y
     /tmp/ccG1xuE7.s:4303   .progmem.data:000000000000010e gTextMsg_VECTOR_HEADER
     /tmp/ccG1xuE7.s:4298   .progmem.data:0000000000000104 gTextMsg_noVector
     /tmp/ccG1xuE7.s:4293   .progmem.data:00000000000000fd gTextMsg_rjmp
     /tmp/ccG1xuE7.s:4288   .progmem.data:00000000000000f8 gTextMsg_jmp
     /tmp/ccG1xuE7.s:4283   .progmem.data:00000000000000ed gTextMsg_WHAT_PORT
     /tmp/ccG1xuE7.s:4278   .progmem.data:00000000000000da gTextMsg_PortNotSupported
     /tmp/ccG1xuE7.s:4273   .progmem.data:00000000000000c9 gTextMsg_MustBeLetter
     /tmp/ccG1xuE7.s:4378   .progmem.data:00000000000001f6 gTextMsg_Prompt
     /tmp/ccG1xuE7.s:4373   .progmem.data:00000000000001f1 gTextMsg_HUH
     /tmp/ccG1xuE7.s:4175   .rodata:0000000000000000 CSWTCH.63
     /tmp/ccG1xuE7.s:4183   .progmem.data:0000000000000000 gTextMsg_END

UNDEFINED SYMBOLS
eeprom_read_byte
__divmodhi4
__udivmodsi4
eeprom_write_byte
__bswapsi2
__do_copy_data
__do_clear_bss
