   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB13:
  14               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   6:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   7:stk500boot.c  **** License:   GNU General Public License
   8:stk500boot.c  **** 
   9:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  10:stk500boot.c  **** Date:      17 October 2007
  11:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  12:stk500boot.c  **** Compiler:  WINAVR20060421
  13:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  14:stk500boot.c  **** 
  15:stk500boot.c  **** DESCRIPTION:
  16:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  17:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  18:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  19:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  20:stk500boot.c  ****     "reset" vector in Application area.
  21:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  22:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  23:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  24:stk500boot.c  **** 
  25:stk500boot.c  **** USAGE:
  26:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  27:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  28:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  29:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  30:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  31:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  32:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  33:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  34:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  35:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  36:stk500boot.c  ****     - AVRISP will detect the bootloader
  37:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  38:stk500boot.c  **** 
  39:stk500boot.c  **** Note:
  40:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  41:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  42:stk500boot.c  ****     Flash is always erased before programming.
  43:stk500boot.c  **** 
  44:stk500boot.c  **** 	AVRdude:
  45:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  46:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  47:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  48:stk500boot.c  **** 
  49:stk500boot.c  **** NOTES:
  50:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  51:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  52:stk500boot.c  **** 
  53:stk500boot.c  **** LICENSE:
  54:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  55:stk500boot.c  **** 
  56:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  57:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  58:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  59:stk500boot.c  ****     any later version.
  60:stk500boot.c  **** 
  61:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  62:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  63:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  64:stk500boot.c  ****     GNU General Public License for more details.
  65:stk500boot.c  **** 
  66:stk500boot.c  **** *****************************************************************************/
  67:stk500boot.c  **** 
  68:stk500boot.c  **** //************************************************************************
  69:stk500boot.c  **** //*	Edit History
  70:stk500boot.c  **** //************************************************************************
  71:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  74:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  76:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  78:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  79:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  80:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  81:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  82:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  83:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  84:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  86:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  89:stk500boot.c  **** //************************************************************************
  90:stk500boot.c  **** 
  91:stk500boot.c  **** //************************************************************************
  92:stk500boot.c  **** //*	these are used to test issues
  93:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  94:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  95:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  96:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
  97:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  98:stk500boot.c  **** #define	_FIX_ISSUE_505_
  99:stk500boot.c  **** //************************************************************************
 100:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 101:stk500boot.c  **** #define	_FIX_ISSUE_181_
 102:stk500boot.c  **** 
 103:stk500boot.c  **** #include	<inttypes.h>
 104:stk500boot.c  **** #include	<avr/io.h>
 105:stk500boot.c  **** #include	<avr/interrupt.h>
 106:stk500boot.c  **** #include	<avr/boot.h>
 107:stk500boot.c  **** #include	<avr/pgmspace.h>
 108:stk500boot.c  **** #include	<util/delay.h>
 109:stk500boot.c  **** #include	<avr/eeprom.h>
 110:stk500boot.c  **** #include	<avr/common.h>
 111:stk500boot.c  **** #include	<stdlib.h>
 112:stk500boot.c  **** #include	"command.h"
 113:stk500boot.c  **** 
 114:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 115:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 116:stk500boot.c  **** 	#undef		ENABLE_MONITOR
 117:stk500boot.c  **** 	#define		ENABLE_MONITOR
 118:stk500boot.c  **** 	static void	RunMonitor(void);
 119:stk500boot.c  **** #endif
 120:stk500boot.c  **** 
 121:stk500boot.c  **** #ifndef EEWE
 122:stk500boot.c  **** 	#define EEWE    1
 123:stk500boot.c  **** #endif
 124:stk500boot.c  **** #ifndef EEMWE
 125:stk500boot.c  **** 	#define EEMWE   2
 126:stk500boot.c  **** #endif
 127:stk500boot.c  **** 
 128:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 129:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 130:stk500boot.c  **** 
 131:stk500boot.c  **** 
 132:stk500boot.c  **** /*
 133:stk500boot.c  ****  * Uncomment the following lines to save code space
 134:stk500boot.c  ****  */
 135:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 136:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 137:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 138:stk500boot.c  **** //
 139:stk500boot.c  **** 
 140:stk500boot.c  **** 
 141:stk500boot.c  **** 
 142:stk500boot.c  **** //************************************************************************
 143:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 144:stk500boot.c  **** //*	indicates that bootloader is active
 145:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 146:stk500boot.c  **** //************************************************************************
 147:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 148:stk500boot.c  **** 
 149:stk500boot.c  **** #ifdef _MEGA_BOARD_
 150:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 151:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 152:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 153:stk500boot.c  **** #elif defined( _BOARD_AMBER128_ )
 154:stk500boot.c  **** 	//*	this is for the amber 128 http://www.soc-robotics.com/
 155:stk500boot.c  **** 	//*	onbarod led is PORTE4
 156:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 157:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 158:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 159:stk500boot.c  **** #elif defined( _CEREBOTPLUS_BOARD_ ) || defined(_CEREBOT_II_BOARD_)
 160:stk500boot.c  **** 	//*	this is for the Cerebot 2560 board and the Cerebot-ii
 161:stk500boot.c  **** 	//*	onbarod leds are on PORTE4-7
 162:stk500boot.c  **** 	#define PROGLED_PORT	PORTE
 163:stk500boot.c  **** 	#define PROGLED_DDR		DDRE
 164:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 165:stk500boot.c  **** #elif defined( _PENGUINO_ )
 166:stk500boot.c  **** 	//*	this is for the Penguino
 167:stk500boot.c  **** 	//*	onbarod led is PORTE4
 168:stk500boot.c  **** 	#define PROGLED_PORT	PORTC
 169:stk500boot.c  **** 	#define PROGLED_DDR		DDRC
 170:stk500boot.c  **** 	#define PROGLED_PIN		PINC6
 171:stk500boot.c  **** #elif defined( _ANDROID_2561_ ) || defined( __AVR_ATmega2561__ )
 172:stk500boot.c  **** 	//*	this is for the Boston Android 2561
 173:stk500boot.c  **** 	//*	onbarod led is PORTE4
 174:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 175:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 176:stk500boot.c  **** 	#define PROGLED_PIN		PINA3
 177:stk500boot.c  **** #elif defined( _BOARD_MEGA16 )
 178:stk500boot.c  **** 	//*	onbarod led is PORTA7
 179:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 180:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 181:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 182:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 183:stk500boot.c  **** 
 184:stk500boot.c  **** #elif defined( _BOARD_BAHBOT_ )
 185:stk500boot.c  **** 	//*	dosent have an onboard LED but this is what will probably be added to this port
 186:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 187:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 188:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 189:stk500boot.c  **** 
 190:stk500boot.c  **** #elif defined( _BOARD_ROBOTX_ )
 191:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 192:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 193:stk500boot.c  **** 	#define PROGLED_PIN		PINB6
 194:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_BLINK_B0_ )
 195:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 196:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 197:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 198:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_ )
 199:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 200:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 201:stk500boot.c  **** 	#define PROGLED_PIN		PIND5
 202:stk500boot.c  **** #elif defined( _AVRLIP_ )
 203:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 204:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 205:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 206:stk500boot.c  **** #elif defined( _BOARD_STK500_ )
 207:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 208:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 209:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 210:stk500boot.c  **** #elif defined( _BOARD_STK502_ )
 211:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 212:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 213:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 214:stk500boot.c  **** #elif defined( _BOARD_STK525_ )
 215:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 216:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 217:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 218:stk500boot.c  **** #else
 219:stk500boot.c  **** 	#define PROGLED_PORT	PORTG
 220:stk500boot.c  **** 	#define PROGLED_DDR		DDRG
 221:stk500boot.c  **** 	#define PROGLED_PIN		PING2
 222:stk500boot.c  **** #endif
 223:stk500boot.c  **** 
 224:stk500boot.c  **** 
 225:stk500boot.c  **** 
 226:stk500boot.c  **** /*
 227:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 228:stk500boot.c  ****  */
 229:stk500boot.c  **** #ifndef F_CPU
 230:stk500boot.c  **** 	#define F_CPU 16000000UL
 231:stk500boot.c  **** #endif
 232:stk500boot.c  **** 
 233:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 234:stk500boot.c  **** /*
 235:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 236:stk500boot.c  ****  */
 237:stk500boot.c  **** 
 238:stk500boot.c  **** #ifndef BAUDRATE
 239:stk500boot.c  **** 	#define BAUDRATE 115200
 240:stk500boot.c  **** #endif
 241:stk500boot.c  **** 
 242:stk500boot.c  **** /*
 243:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 244:stk500boot.c  ****  */
 245:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 246:stk500boot.c  **** 	#if defined (__AVR_ATmega32__)
 247:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 248:stk500boot.c  **** 	#else
 249:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 250:stk500boot.c  **** 	#endif
 251:stk500boot.c  **** #endif
 252:stk500boot.c  **** 
 253:stk500boot.c  **** /*
 254:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 255:stk500boot.c  ****  */
 256:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 257:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 258:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 259:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 260:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 261:stk500boot.c  **** 
 262:stk500boot.c  **** /*
 263:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 264:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 265:stk500boot.c  ****  */
 266:stk500boot.c  **** //#define BOOTSIZE 1024
 267:stk500boot.c  **** #if FLASHEND > 0x0F000
 268:stk500boot.c  **** 	#define BOOTSIZE 8192
 269:stk500boot.c  **** #else
 270:stk500boot.c  **** 	#define BOOTSIZE 2048
 271:stk500boot.c  **** #endif
 272:stk500boot.c  **** 
 273:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 274:stk500boot.c  **** 
 275:stk500boot.c  **** /*
 276:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 277:stk500boot.c  ****  */
 278:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 279:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9307
 280:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 281:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9403
 282:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 283:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9502
 284:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 285:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9306
 286:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 287:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9308
 288:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 289:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9404
 290:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 291:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9702
 292:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 293:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9703
 294:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 295:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9801
 296:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 297:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9802
 298:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 299:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9705
 300:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 301:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9608
 302:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 303:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1E9602
 304:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 305:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9405
 306:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 307:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9782
 308:stk500boot.c  **** #else
 309:stk500boot.c  **** 	#error "no signature definition for MCU available"
 310:stk500boot.c  **** #endif
 311:stk500boot.c  **** 
 312:stk500boot.c  **** 
 313:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 314:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 315:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 316:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 317:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 318:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 319:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 320:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 321:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 322:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 323:stk500boot.c  **** 
 324:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 325:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 326:stk500boot.c  **** 	/* ATMega8 with one USART */
 327:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 328:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 329:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 330:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 331:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 332:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 333:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 334:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 335:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 336:stk500boot.c  **** 
 337:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 338:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 339:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 340:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 341:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 342:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 343:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 344:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 345:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 346:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 347:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 348:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 349:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 350:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 351:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 352:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 353:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 354:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 355:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 356:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 357:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 358:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 359:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 360:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 361:stk500boot.c  **** 	//* catch all
 362:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 363:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 364:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 365:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 366:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 367:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 368:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 369:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 370:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 371:stk500boot.c  **** #else
 372:stk500boot.c  **** 	#error "no UART definition for MCU available"
 373:stk500boot.c  **** #endif
 374:stk500boot.c  **** 
 375:stk500boot.c  **** 
 376:stk500boot.c  **** 
 377:stk500boot.c  **** /*
 378:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 379:stk500boot.c  ****  */
 380:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 381:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 382:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 383:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 384:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 385:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 386:stk500boot.c  **** #else
 387:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 388:stk500boot.c  **** #endif
 389:stk500boot.c  **** 
 390:stk500boot.c  **** 
 391:stk500boot.c  **** /*
 392:stk500boot.c  ****  * States used in the receive state machine
 393:stk500boot.c  ****  */
 394:stk500boot.c  **** #define	ST_START		0
 395:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 396:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 397:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 398:stk500boot.c  **** #define ST_GET_TOKEN	4
 399:stk500boot.c  **** #define ST_GET_DATA		5
 400:stk500boot.c  **** #define	ST_GET_CHECK	6
 401:stk500boot.c  **** #define	ST_PROCESS		7
 402:stk500boot.c  **** 
 403:stk500boot.c  **** /*
 404:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 405:stk500boot.c  ****  */
 406:stk500boot.c  **** #if defined(RAMPZ)
 407:stk500boot.c  **** 	typedef uint32_t address_t;
 408:stk500boot.c  **** #else
 409:stk500boot.c  **** 	typedef uint16_t address_t;
 410:stk500boot.c  **** #endif
 411:stk500boot.c  **** 
 412:stk500boot.c  **** /*
 413:stk500boot.c  ****  * function prototypes
 414:stk500boot.c  ****  */
 415:stk500boot.c  **** static void sendchar(char c);
 416:stk500boot.c  **** static unsigned char recchar(void);
 417:stk500boot.c  **** 
 418:stk500boot.c  **** /*
 419:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 420:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 421:stk500boot.c  ****  */
 422:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 423:stk500boot.c  **** #include <avr/sfr_defs.h>
 424:stk500boot.c  **** 
 425:stk500boot.c  **** //#define	SPH_REG	0x3E
 426:stk500boot.c  **** //#define	SPL_REG	0x3D
 427:stk500boot.c  **** 
 428:stk500boot.c  **** //*****************************************************************************
 429:stk500boot.c  **** void __jumpMain(void)
 430:stk500boot.c  **** {
 431:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 432:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 433:stk500boot.c  **** 
 434:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 435:stk500boot.c  **** 
 436:stk500boot.c  **** //*	set stack pointer to top of RAM
 437:stk500boot.c  **** 
 438:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 439:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 440:stk500boot.c  **** 
 441:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 442:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 443:stk500boot.c  **** 
 444:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 445:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 446:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 447:stk500boot.c  **** }
 448:stk500boot.c  **** 
 449:stk500boot.c  **** 
 450:stk500boot.c  **** //*****************************************************************************
 451:stk500boot.c  **** void delay_ms(unsigned int timedelay)
 452:stk500boot.c  **** {
 453:stk500boot.c  **** 	unsigned int i;
 454:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 455:stk500boot.c  **** 	{
 456:stk500boot.c  **** 		_delay_ms(0.5);
 457:stk500boot.c  **** 	}
 458:stk500boot.c  **** }
 459:stk500boot.c  **** 
 460:stk500boot.c  **** 
 461:stk500boot.c  **** //*****************************************************************************
 462:stk500boot.c  **** /*
 463:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 464:stk500boot.c  ****  */
 465:stk500boot.c  **** static void sendchar(char c)
 466:stk500boot.c  **** {
  15               		.loc 1 466 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 467:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
  22               		.loc 1 467 0
  23 0000 8093 C600 		sts 198,r24
  24               	.LVL1:
  25               	.L2:
 468:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  26               		.loc 1 468 0 discriminator 1
  27 0004 8091 C000 		lds r24,192
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L2
 469:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  30               		.loc 1 469 0
  31 000c 8091 C000 		lds r24,192
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C000 		sts 192,r24
  34               	.LVL2:
  35               	/* epilogue start */
 470:stk500boot.c  **** }
  36               		.loc 1 470 0
  37 0016 0895      		ret
  38               		.cfi_endproc
  39               	.LFE13:
  41               		.section	.text.unlikely,"ax",@progbits
  43               	recchar:
  44               	.LFB15:
 471:stk500boot.c  **** 
 472:stk500boot.c  **** 
 473:stk500boot.c  **** //************************************************************************
 474:stk500boot.c  **** static int	Serial_Available(void)
 475:stk500boot.c  **** {
 476:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 477:stk500boot.c  **** }
 478:stk500boot.c  **** 
 479:stk500boot.c  **** 
 480:stk500boot.c  **** //*****************************************************************************
 481:stk500boot.c  **** /*
 482:stk500boot.c  ****  * Read single byte from USART, block if no data available
 483:stk500boot.c  ****  */
 484:stk500boot.c  **** static unsigned char recchar(void)
 485:stk500boot.c  **** {
  45               		.loc 1 485 0
  46               		.cfi_startproc
  47               	/* prologue: function */
  48               	/* frame size = 0 */
  49               	/* stack size = 0 */
  50               	.L__stack_usage = 0
  51               	.L6:
 486:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
  52               		.loc 1 486 0 discriminator 1
  53 0000 8091 C000 		lds r24,192
  54 0004 87FF      		sbrs r24,7
  55 0006 00C0      		rjmp .L6
 487:stk500boot.c  **** 	{
 488:stk500boot.c  **** 		// wait for data
 489:stk500boot.c  **** 	}
 490:stk500boot.c  **** 	return UART_DATA_REG;
  56               		.loc 1 490 0
  57 0008 8091 C600 		lds r24,198
  58               	/* epilogue start */
 491:stk500boot.c  **** }
  59               		.loc 1 491 0
  60 000c 0895      		ret
  61               		.cfi_endproc
  62               	.LFE15:
  64               		.text
  66               	corebeep_init:
  67               	.LFB19:
 492:stk500boot.c  **** 
 493:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 494:stk500boot.c  **** //*****************************************************************************
 495:stk500boot.c  **** static unsigned char recchar_timeout(void)
 496:stk500boot.c  **** {
 497:stk500boot.c  **** uint32_t count = 0;
 498:stk500boot.c  **** 
 499:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 500:stk500boot.c  **** 	{
 501:stk500boot.c  **** 		// wait for data
 502:stk500boot.c  **** 		count++;
 503:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 504:stk500boot.c  **** 		{
 505:stk500boot.c  **** 		unsigned int	data;
 506:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
 507:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 508:stk500boot.c  **** 		#else
 509:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 510:stk500boot.c  **** 		#endif
 511:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 512:stk500boot.c  **** 			{
 513:stk500boot.c  **** 				asm volatile(
 514:stk500boot.c  **** 						"clr	r30		\n\t"
 515:stk500boot.c  **** 						"clr	r31		\n\t"
 516:stk500boot.c  **** 						"ijmp	\n\t"
 517:stk500boot.c  **** 						);
 518:stk500boot.c  **** 			}
 519:stk500boot.c  **** 			count	=	0;
 520:stk500boot.c  **** 		}
 521:stk500boot.c  **** 	}
 522:stk500boot.c  **** 	return UART_DATA_REG;
 523:stk500boot.c  **** }
 524:stk500boot.c  **** 
 525:stk500boot.c  **** //*	for watch dog timer startup
 526:stk500boot.c  **** void (*app_start)(void) = 0x0000;
 527:stk500boot.c  **** 
 528:stk500boot.c  **** // ====== [修改 1] 添加 EEPROM 计数定义 ======
 529:stk500boot.c  **** // 选择 EEPROM 地址 4 作为计数存储位 (避开地址0，因为掉电容易损坏)
 530:stk500boot.c  **** #define EEPROM_COUNTER_ADDR  ((uint8_t*)0x04)
 531:stk500boot.c  **** #define MAX_BOOT_COUNTS      5
 532:stk500boot.c  **** 
 533:stk500boot.c  **** // ===== EEPROM 清除跳线（Mega2560：D22 = PA0）=====
 534:stk500boot.c  **** #define CLR_EE_DDR   DDRA
 535:stk500boot.c  **** #define CLR_EE_PORT  PORTA
 536:stk500boot.c  **** #define CLR_EE_PINR  PINA
 537:stk500boot.c  **** #define CLR_EE_BIT   0    // PA0 = D22
 538:stk500boot.c  **** 
 539:stk500boot.c  **** #define COREBEEP_DDR   DDRB
 540:stk500boot.c  **** #define COREBEEP_PORT PORTB
 541:stk500boot.c  **** #define COREBEEP_BIT  4      // PB4 = Arduino D10
 542:stk500boot.c  **** 
 543:stk500boot.c  **** // ====== BEEP on Arduino D9 (Mega2560: PH6) ======
 544:stk500boot.c  **** #define BEEP_DDR   DDRH
 545:stk500boot.c  **** #define BEEP_PORT  PORTH
 546:stk500boot.c  **** #define BEEP_PINR  PINH
 547:stk500boot.c  **** #define BEEP_BIT   6      // PH6 = D9
 548:stk500boot.c  **** 
 549:stk500boot.c  **** // 如果你的蜂鸣器是“高电平响”
 550:stk500boot.c  **** #define BEEP_ON()   (BEEP_PORT |=  (1 << BEEP_BIT))
 551:stk500boot.c  **** #define BEEP_OFF()  (BEEP_PORT &= ~(1 << BEEP_BIT))
 552:stk500boot.c  **** 
 553:stk500boot.c  **** 
 554:stk500boot.c  **** #define TURNON  1
 555:stk500boot.c  **** #define TURNOFF 0
 556:stk500boot.c  **** 
 557:stk500boot.c  **** typedef enum {
 558:stk500boot.c  ****     CLR_IDLE = 0,
 559:stk500boot.c  ****     CLR_COUNTING,
 560:stk500boot.c  ****     CLR_TRIGGERED_WAIT_RELEASE
 561:stk500boot.c  **** } clr_state_t;
 562:stk500boot.c  **** 
 563:stk500boot.c  **** static unsigned char gHasFlashed;
 564:stk500boot.c  **** static unsigned char gInterceptAppJump;
 565:stk500boot.c  **** static uint8_t current_boot_count;
 566:stk500boot.c  **** 
 567:stk500boot.c  **** static void sendstring(const char *s)
 568:stk500boot.c  **** {
 569:stk500boot.c  ****     if (s == 0) return;
 570:stk500boot.c  ****     while (*s)
 571:stk500boot.c  ****     {
 572:stk500boot.c  ****         sendchar(*s++);
 573:stk500boot.c  ****     }
 574:stk500boot.c  **** }
 575:stk500boot.c  **** 
 576:stk500boot.c  **** // static void send_uint8(uint8_t v)
 577:stk500boot.c  **** // {
 578:stk500boot.c  **** //     char buf[4];              // 0..255 最多 3 位 + '\0'
 579:stk500boot.c  **** //     utoa(v, buf, 10);         // 转十进制字符串
 580:stk500boot.c  **** //     sendstring(buf);
 581:stk500boot.c  **** // }
 582:stk500boot.c  **** 
 583:stk500boot.c  **** 
 584:stk500boot.c  **** static uint8_t is_clear_eeprom_requested_sm(void)
 585:stk500boot.c  **** {
 586:stk500boot.c  ****     static clr_state_t st = CLR_IDLE;
 587:stk500boot.c  ****     static uint16_t low_cnt = 0;
 588:stk500boot.c  **** 
 589:stk500boot.c  ****     // input + pull-up（每次调用做一次也没问题；想省可以只初始化一次）
 590:stk500boot.c  ****     CLR_EE_DDR  &= ~(1 << CLR_EE_BIT);
 591:stk500boot.c  ****     CLR_EE_PORT |=  (1 << CLR_EE_BIT);
 592:stk500boot.c  **** 
 593:stk500boot.c  ****     // 读引脚：1=高，0=低（接地）
 594:stk500boot.c  ****     uint8_t pin_low = ((CLR_EE_PINR & (1 << CLR_EE_BIT)) == 0);
 595:stk500boot.c  **** 
 596:stk500boot.c  ****     // 阈值：连续低电平多少次才算“稳定按下”
 597:stk500boot.c  ****     // 你循环里 delay_ms(500)，那一次循环很慢；
 598:stk500boot.c  ****     // 如果你后面把主循环改快了，这个阈值再调大即可。
 599:stk500boot.c  ****     const uint16_t THRESH = 50;
 600:stk500boot.c  **** 
 601:stk500boot.c  ****     switch (st)
 602:stk500boot.c  ****     {
 603:stk500boot.c  ****         case CLR_IDLE:
 604:stk500boot.c  ****             low_cnt = 0;
 605:stk500boot.c  ****             if (pin_low) {
 606:stk500boot.c  ****                 st = CLR_COUNTING;
 607:stk500boot.c  ****                 low_cnt = 1;
 608:stk500boot.c  ****             }
 609:stk500boot.c  ****             break;
 610:stk500boot.c  **** 
 611:stk500boot.c  ****         case CLR_COUNTING:
 612:stk500boot.c  ****             if (pin_low) {
 613:stk500boot.c  ****                 if (low_cnt < 0xFFFF) low_cnt++;
 614:stk500boot.c  ****                 if (low_cnt >= THRESH) {
 615:stk500boot.c  ****                     st = CLR_TRIGGERED_WAIT_RELEASE;
 616:stk500boot.c  ****                     return 1;   // 触发一次
 617:stk500boot.c  ****                 }
 618:stk500boot.c  ****             } else {
 619:stk500boot.c  ****                 st = CLR_IDLE; // 抖回高电平，重新来
 620:stk500boot.c  ****             }
 621:stk500boot.c  ****             break;
 622:stk500boot.c  **** 
 623:stk500boot.c  ****         case CLR_TRIGGERED_WAIT_RELEASE:
 624:stk500boot.c  ****             // 等用户松开跳线（回到高电平）再允许下次触发
 625:stk500boot.c  ****             if (!pin_low) {
 626:stk500boot.c  ****                 st = CLR_IDLE;
 627:stk500boot.c  ****             }
 628:stk500boot.c  ****             break;
 629:stk500boot.c  ****     }
 630:stk500boot.c  ****     return 0;
 631:stk500boot.c  **** }
 632:stk500boot.c  **** 
 633:stk500boot.c  **** static inline void corebeep_init(void)
 634:stk500boot.c  **** {
  68               		.loc 1 634 0
  69               		.cfi_startproc
  70               	/* prologue: function */
  71               	/* frame size = 0 */
  72               	/* stack size = 0 */
  73               	.L__stack_usage = 0
 635:stk500boot.c  ****     COREBEEP_DDR |= (1 << COREBEEP_BIT);      // output
  74               		.loc 1 635 0
  75 0018 249A      		sbi 0x4,4
 636:stk500boot.c  ****     COREBEEP_PORT &= ~(1 << COREBEEP_BIT);    // default OFF
  76               		.loc 1 636 0
  77 001a 2C98      		cbi 0x5,4
  78               	/* epilogue start */
 637:stk500boot.c  **** }
  79               		.loc 1 637 0
  80 001c 0895      		ret
  81               		.cfi_endproc
  82               	.LFE19:
  85               	beep_init:
  86               	.LFB22:
 638:stk500boot.c  **** 
 639:stk500boot.c  **** static inline void corebeep_on(void)
 640:stk500boot.c  **** {
 641:stk500boot.c  ****     COREBEEP_PORT |= (1 << COREBEEP_BIT);
 642:stk500boot.c  **** }
 643:stk500boot.c  **** 
 644:stk500boot.c  **** static inline void corebeep_off(void)
 645:stk500boot.c  **** {
 646:stk500boot.c  ****     COREBEEP_PORT &= ~(1 << COREBEEP_BIT);
 647:stk500boot.c  **** }
 648:stk500boot.c  **** 
 649:stk500boot.c  **** static inline void beep_init(void)
 650:stk500boot.c  **** {
  87               		.loc 1 650 0
  88               		.cfi_startproc
  89               	/* prologue: function */
  90               	/* frame size = 0 */
  91               	/* stack size = 0 */
  92               	.L__stack_usage = 0
 651:stk500boot.c  ****     BEEP_DDR  |=  (1 << BEEP_BIT);   // 输出
  93               		.loc 1 651 0
  94 001e E1E0      		ldi r30,lo8(1)
  95 0020 F1E0      		ldi r31,lo8(1)
  96 0022 8081      		ld r24,Z
  97 0024 8064      		ori r24,lo8(64)
  98 0026 8083      		st Z,r24
 652:stk500boot.c  ****     BEEP_OFF();                      // 默认关闭
  99               		.loc 1 652 0
 100 0028 E2E0      		ldi r30,lo8(2)
 101 002a F1E0      		ldi r31,lo8(1)
 102 002c 8081      		ld r24,Z
 103 002e 8F7B      		andi r24,lo8(-65)
 104 0030 8083      		st Z,r24
 105               	/* epilogue start */
 653:stk500boot.c  **** }
 106               		.loc 1 653 0
 107 0032 0895      		ret
 108               		.cfi_endproc
 109               	.LFE22:
 111               		.section	.init9,"ax",@progbits
 112               	.global	__jumpMain
 114               	__jumpMain:
 115               	.LFB11:
 430:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 116               		.loc 1 430 0
 117               		.cfi_startproc
 118               	/* prologue: naked */
 119               	/* frame size = 0 */
 120               	/* stack size = 0 */
 121               	.L__stack_usage = 0
 434:stk500boot.c  **** 
 122               		.loc 1 434 0
 123               	/* #APP */
 124               	 ;  434 "stk500boot.c" 1
 125               		.set __stack, 8703
 126               	 ;  0 "" 2
 438:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 127               		.loc 1 438 0
 128               	 ;  438 "stk500boot.c" 1
 129 0000 01E2      		ldi	16, 33
 130               	 ;  0 "" 2
 439:stk500boot.c  **** 
 131               		.loc 1 439 0
 132               	 ;  439 "stk500boot.c" 1
 133 0002 0EBF      		out 62,16
 134               	 ;  0 "" 2
 441:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 135               		.loc 1 441 0
 136               	 ;  441 "stk500boot.c" 1
 137 0004 0FEF      		ldi	16, 255
 138               	 ;  0 "" 2
 442:stk500boot.c  **** 
 139               		.loc 1 442 0
 140               	 ;  442 "stk500boot.c" 1
 141 0006 0DBF      		out 61,16
 142               	 ;  0 "" 2
 444:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 143               		.loc 1 444 0
 144               	 ;  444 "stk500boot.c" 1
 145 0008 1124      		clr __zero_reg__
 146               	 ;  0 "" 2
 445:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 147               		.loc 1 445 0
 148               	 ;  445 "stk500boot.c" 1
 149 000a 1FBE      		out 63, __zero_reg__
 150               	 ;  0 "" 2
 446:stk500boot.c  **** }
 151               		.loc 1 446 0
 152               	 ;  446 "stk500boot.c" 1
 153 000c 0C94 0000 		jmp main
 154               	 ;  0 "" 2
 155               	/* epilogue start */
 447:stk500boot.c  **** 
 156               		.loc 1 447 0
 157               	/* #NOAPP */
 158               		.cfi_endproc
 159               	.LFE11:
 161               		.text
 162               	.global	delay_ms
 164               	delay_ms:
 165               	.LFB12:
 452:stk500boot.c  **** 	unsigned int i;
 166               		.loc 1 452 0
 167               		.cfi_startproc
 168               	.LVL3:
 169               	/* prologue: function */
 170               	/* frame size = 0 */
 171               	/* stack size = 0 */
 172               	.L__stack_usage = 0
 454:stk500boot.c  **** 	{
 173               		.loc 1 454 0
 174 0034 30E0      		ldi r19,0
 175 0036 20E0      		ldi r18,0
 176               	.LVL4:
 177               	.L12:
 454:stk500boot.c  **** 	{
 178               		.loc 1 454 0 is_stmt 0 discriminator 1
 179 0038 2817      		cp r18,r24
 180 003a 3907      		cpc r19,r25
 181 003c 01F4      		brne .L13
 182               	/* epilogue start */
 458:stk500boot.c  **** 
 183               		.loc 1 458 0 is_stmt 1
 184 003e 0895      		ret
 185               	.L13:
 186               	.LVL5:
 187               	.LBB83:
 188               	.LBB84:
 189               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 190               		.loc 2 187 0
 191 0040 EFEC      		ldi r30,lo8(1999)
 192 0042 F7E0      		ldi r31,hi8(1999)
 193 0044 3197      	1:	sbiw r30,1
 194 0046 01F4      		brne 1b
 195 0048 00C0      		rjmp .
 196 004a 0000      		nop
 197               	.LVL6:
 198               	.LBE84:
 199               	.LBE83:
 454:stk500boot.c  **** 	{
 200               		.loc 1 454 0
 201 004c 2F5F      		subi r18,-1
 202 004e 3F4F      		sbci r19,-1
 203               	.LVL7:
 204 0050 00C0      		rjmp .L12
 205               		.cfi_endproc
 206               	.LFE12:
 208               		.section	.rodata.str1.1,"aMS",@progbits,1
 209               	.LC0:
 210 0000 4545 5052 		.string	"EEPROM CLEAR...\r\n"
 210      4F4D 2043 
 210      4C45 4152 
 210      2E2E 2E0D 
 210      0A00 
 211               	.LC1:
 212 0012 4545 5052 		.string	"EEPROM CLEARED, JUMP APP\r\n"
 212      4F4D 2043 
 212      4C45 4152 
 212      4544 2C20 
 212      4A55 4D50 
 213               		.text
 214               	.global	user_code
 216               	user_code:
 217               	.LFB26:
 654:stk500boot.c  **** 
 655:stk500boot.c  **** static inline void beep_on(void)
 656:stk500boot.c  **** {
 657:stk500boot.c  ****     BEEP_ON();
 658:stk500boot.c  **** }
 659:stk500boot.c  **** 
 660:stk500boot.c  **** static inline void beep_off(void)
 661:stk500boot.c  **** {
 662:stk500boot.c  ****     BEEP_OFF();
 663:stk500boot.c  **** }
 664:stk500boot.c  **** 
 665:stk500boot.c  **** 
 666:stk500boot.c  **** static void jump_to_app(void)
 667:stk500boot.c  **** {
 668:stk500boot.c  ****     // 关中断，避免带着 bootloader 状态进 App
 669:stk500boot.c  ****     cli();
 670:stk500boot.c  **** 
 671:stk500boot.c  ****     // 可选：关 UART（避免 App 初始化前串口状态干扰）
 672:stk500boot.c  ****     UART_CONTROL_REG = 0;
 673:stk500boot.c  **** 
 674:stk500boot.c  ****     // 可选：清一些可能影响 App 的状态（按需）
 675:stk500boot.c  ****     // UART_STATUS_REG = 0;
 676:stk500boot.c  **** 
 677:stk500boot.c  ****     // 跳到 0x0000（App reset vector）
 678:stk500boot.c  ****     asm volatile(
 679:stk500boot.c  ****         "clr r30\n\t"
 680:stk500boot.c  ****         "clr r31\n\t"
 681:stk500boot.c  ****         "ijmp\n\t"
 682:stk500boot.c  ****     );
 683:stk500boot.c  **** }
 684:stk500boot.c  **** 
 685:stk500boot.c  **** void user_code(void)
 686:stk500boot.c  **** {
 218               		.loc 1 686 0
 219               		.cfi_startproc
 220               	/* prologue: function */
 221               	/* frame size = 0 */
 222               	/* stack size = 0 */
 223               	.L__stack_usage = 0
 687:stk500boot.c  ****     // 确保 UART 已初始化（你之前做得对）
 688:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 689:stk500boot.c  ****     UART_STATUS_REG |= (1 << UART_DOUBLE_SPEED);
 224               		.loc 1 689 0
 225 0052 8091 C000 		lds r24,192
 226 0056 8260      		ori r24,lo8(2)
 227 0058 8093 C000 		sts 192,r24
 690:stk500boot.c  **** #endif
 691:stk500boot.c  ****     UART_BAUD_RATE_LOW = UART_BAUD_SELECT(BAUDRATE, F_CPU);
 228               		.loc 1 691 0
 229 005c 80E1      		ldi r24,lo8(16)
 230 005e 8093 C400 		sts 196,r24
 692:stk500boot.c  ****     UART_CONTROL_REG   = (1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 231               		.loc 1 692 0
 232 0062 88E1      		ldi r24,lo8(24)
 233 0064 8093 C100 		sts 193,r24
 234               	.LVL8:
 693:stk500boot.c  **** 	uint32_t time = 0;
 694:stk500boot.c  **** 	corebeep_init();
 235               		.loc 1 694 0
 236 0068 0E94 0000 		call corebeep_init
 237               	.LVL9:
 238               	.LBB101:
 239               	.LBB102:
 646:stk500boot.c  **** }
 240               		.loc 1 646 0
 241 006c 2C98      		cbi 0x5,4
 242               	.LBE102:
 243               	.LBE101:
 695:stk500boot.c  **** 	corebeep_off();
 696:stk500boot.c  **** 	beep_init();
 244               		.loc 1 696 0
 245 006e 0E94 0000 		call beep_init
 246               	.LVL10:
 247               	.LBB103:
 248               	.LBB104:
 662:stk500boot.c  **** }
 249               		.loc 1 662 0
 250 0072 8091 0201 		lds r24,258
 251 0076 8F7B      		andi r24,lo8(-65)
 252 0078 8093 0201 		sts 258,r24
 253               	.LBE104:
 254               	.LBE103:
 255               	.LBB105:
 256               	.LBB106:
 615:stk500boot.c  ****                     return 1;   // 触发一次
 257               		.loc 1 615 0
 258 007c 82E0      		ldi r24,lo8(2)
 259 007e F82E      		mov r15,r24
 606:stk500boot.c  ****                 low_cnt = 1;
 260               		.loc 1 606 0
 261 0080 EE24      		clr r14
 262 0082 E394      		inc r14
 607:stk500boot.c  ****             }
 263               		.loc 1 607 0
 264 0084 C1E0      		ldi r28,lo8(1)
 265 0086 D0E0      		ldi r29,0
 266               	.LVL11:
 267               	.L27:
 590:stk500boot.c  ****     CLR_EE_PORT |=  (1 << CLR_EE_BIT);
 268               		.loc 1 590 0
 269 0088 0898      		cbi 0x1,0
 591:stk500boot.c  **** 
 270               		.loc 1 591 0
 271 008a 109A      		sbi 0x2,0
 594:stk500boot.c  **** 
 272               		.loc 1 594 0
 273 008c 80B1      		in r24,0
 274 008e 8170      		andi r24,lo8(1)
 275               	.LVL12:
 601:stk500boot.c  ****     {
 276               		.loc 1 601 0
 277 0090 9091 0000 		lds r25,st.2050
 278 0094 9130      		cpi r25,lo8(1)
 279 0096 01F0      		breq .L16
 280 0098 00F0      		brlo .L17
 281 009a 9230      		cpi r25,lo8(2)
 282 009c 01F4      		brne .+2
 283 009e 00C0      		rjmp .L18
 284               	.LVL13:
 285               	.L15:
 286               	.LBE106:
 287               	.LBE105:
 697:stk500boot.c  **** 	beep_off();
 698:stk500boot.c  ****     while (1)
 699:stk500boot.c  ****     {
 700:stk500boot.c  **** 		if (time % 50 == 0) {
 701:stk500boot.c  **** 			// 1) 打印当前计数
 702:stk500boot.c  **** 			// sendstring("[RECOVERY MODE]\r\n");
 703:stk500boot.c  **** 			// sendstring("Boot counter = ");
 704:stk500boot.c  **** 			// send_uint8(current_boot_count);
 705:stk500boot.c  **** 			// sendstring("\r\n");
 706:stk500boot.c  **** 			// sendstring("To reset counter and start application:\r\n");
 707:stk500boot.c  **** 			// sendstring("Short D22 to GND, then release.\r\n\r\n");
 708:stk500boot.c  **** 		}
 709:stk500boot.c  **** 
 710:stk500boot.c  ****         // 2) 检测 D22 跳线（无 delay 状态机）
 711:stk500boot.c  ****         if (is_clear_eeprom_requested_sm())
 712:stk500boot.c  ****         {
 713:stk500boot.c  ****             sendstring("EEPROM CLEAR...\r\n");
 714:stk500boot.c  **** 
 715:stk500boot.c  ****             // 只清计数（你要全清 EEPROM 就换成 clear_all）
 716:stk500boot.c  ****             eeprom_write_byte(EEPROM_COUNTER_ADDR, 0);
 717:stk500boot.c  **** 
 718:stk500boot.c  ****             sendstring("EEPROM CLEARED, JUMP APP\r\n");
 719:stk500boot.c  **** 
 720:stk500boot.c  ****             // 3) 跳入 APP
 721:stk500boot.c  ****             jump_to_app();
 722:stk500boot.c  ****         }
 723:stk500boot.c  **** 		time++;
 724:stk500boot.c  ****         delay_ms(10);
 288               		.loc 1 724 0
 289 00a0 8AE0      		ldi r24,lo8(10)
 290 00a2 90E0      		ldi r25,0
 291 00a4 0E94 0000 		call delay_ms
 292               	.LVL14:
 700:stk500boot.c  **** 			// 1) 打印当前计数
 293               		.loc 1 700 0
 294 00a8 00C0      		rjmp .L27
 295               	.LVL15:
 296               	.L17:
 297               	.LBB109:
 298               	.LBB107:
 604:stk500boot.c  ****             if (pin_low) {
 299               		.loc 1 604 0
 300 00aa 1092 0000 		sts low_cnt.2051+1,__zero_reg__
 301 00ae 1092 0000 		sts low_cnt.2051,__zero_reg__
 605:stk500boot.c  ****                 st = CLR_COUNTING;
 302               		.loc 1 605 0
 303 00b2 8111      		cpse r24,__zero_reg__
 304 00b4 00C0      		rjmp .L15
 606:stk500boot.c  ****                 low_cnt = 1;
 305               		.loc 1 606 0
 306 00b6 E092 0000 		sts st.2050,r14
 607:stk500boot.c  ****             }
 307               		.loc 1 607 0
 308 00ba D093 0000 		sts low_cnt.2051+1,r29
 309 00be C093 0000 		sts low_cnt.2051,r28
 310 00c2 00C0      		rjmp .L15
 311               	.L16:
 612:stk500boot.c  ****                 if (low_cnt < 0xFFFF) low_cnt++;
 312               		.loc 1 612 0
 313 00c4 8111      		cpse r24,__zero_reg__
 314 00c6 00C0      		rjmp .L20
 613:stk500boot.c  ****                 if (low_cnt >= THRESH) {
 315               		.loc 1 613 0
 316 00c8 8091 0000 		lds r24,low_cnt.2051
 317 00cc 9091 0000 		lds r25,low_cnt.2051+1
 318               	.LVL16:
 319 00d0 8F3F      		cpi r24,-1
 320 00d2 9807      		cpc r25,r24
 321 00d4 01F0      		breq .L21
 322 00d6 0196      		adiw r24,1
 323 00d8 9093 0000 		sts low_cnt.2051+1,r25
 324 00dc 8093 0000 		sts low_cnt.2051,r24
 325               	.L21:
 614:stk500boot.c  ****                     st = CLR_TRIGGERED_WAIT_RELEASE;
 326               		.loc 1 614 0
 327 00e0 8091 0000 		lds r24,low_cnt.2051
 328 00e4 9091 0000 		lds r25,low_cnt.2051+1
 329 00e8 C297      		sbiw r24,50
 330 00ea 00F0      		brlo .L15
 615:stk500boot.c  ****                     return 1;   // 触发一次
 331               		.loc 1 615 0
 332 00ec F092 0000 		sts st.2050,r15
 333 00f0 00E0      		ldi r16,lo8(.LC0)
 334 00f2 10E0      		ldi r17,hi8(.LC0)
 335               	.L23:
 336               	.LVL17:
 337               	.LBE107:
 338               	.LBE109:
 339               	.LBB110:
 340               	.LBB111:
 341               	.LBB112:
 570:stk500boot.c  ****     {
 342               		.loc 1 570 0
 343 00f4 F801      		movw r30,r16
 344 00f6 8191      		ld r24,Z+
 345 00f8 8F01      		movw r16,r30
 346               	.LVL18:
 347 00fa 8111      		cpse r24,__zero_reg__
 348 00fc 00C0      		rjmp .L24
 349               	.LVL19:
 350               	.LBE112:
 351               	.LBE111:
 352               	.LBE110:
 716:stk500boot.c  **** 
 353               		.loc 1 716 0
 354 00fe 60E0      		ldi r22,0
 355 0100 84E0      		ldi r24,lo8(4)
 356 0102 90E0      		ldi r25,0
 357 0104 0E94 0000 		call eeprom_write_byte
 358               	.LVL20:
 359 0108 00E0      		ldi r16,lo8(.LC1)
 360 010a 10E0      		ldi r17,hi8(.LC1)
 361               	.LVL21:
 362               	.L25:
 363               	.LBB115:
 364               	.LBB116:
 365               	.LBB117:
 570:stk500boot.c  ****     {
 366               		.loc 1 570 0
 367 010c F801      		movw r30,r16
 368 010e 8191      		ld r24,Z+
 369 0110 8F01      		movw r16,r30
 370               	.LVL22:
 371 0112 8111      		cpse r24,__zero_reg__
 372 0114 00C0      		rjmp .L26
 373               	.LVL23:
 374               	.LBE117:
 375               	.LBE116:
 376               	.LBE115:
 377               	.LBB120:
 378               	.LBB121:
 669:stk500boot.c  **** 
 379               		.loc 1 669 0
 380               	/* #APP */
 381               	 ;  669 "stk500boot.c" 1
 382 0116 F894      		cli
 383               	 ;  0 "" 2
 672:stk500boot.c  **** 
 384               		.loc 1 672 0
 385               	/* #NOAPP */
 386 0118 1092 C100 		sts 193,__zero_reg__
 678:stk500boot.c  ****         "clr r30\n\t"
 387               		.loc 1 678 0
 388               	/* #APP */
 389               	 ;  678 "stk500boot.c" 1
 390 011c EE27      		clr r30
 391 011e FF27      		clr r31
 392 0120 0994      		ijmp
 393               		
 394               	 ;  0 "" 2
 395               	/* #NOAPP */
 396 0122 00C0      		rjmp .L15
 397               	.LVL24:
 398               	.L18:
 399               	.LBE121:
 400               	.LBE120:
 401               	.LBB122:
 402               	.LBB108:
 625:stk500boot.c  ****                 st = CLR_IDLE;
 403               		.loc 1 625 0
 404 0124 8823      		tst r24
 405 0126 01F4      		brne .+2
 406 0128 00C0      		rjmp .L15
 407               	.L20:
 619:stk500boot.c  ****             }
 408               		.loc 1 619 0
 409 012a 1092 0000 		sts st.2050,__zero_reg__
 410 012e 00C0      		rjmp .L15
 411               	.LVL25:
 412               	.L24:
 413               	.LBE108:
 414               	.LBE122:
 415               	.LBB123:
 416               	.LBB114:
 417               	.LBB113:
 572:stk500boot.c  ****     }
 418               		.loc 1 572 0
 419 0130 0E94 0000 		call sendchar
 420               	.LVL26:
 421 0134 00C0      		rjmp .L23
 422               	.LVL27:
 423               	.L26:
 424               	.LBE113:
 425               	.LBE114:
 426               	.LBE123:
 427               	.LBB124:
 428               	.LBB119:
 429               	.LBB118:
 430 0136 0E94 0000 		call sendchar
 431               	.LVL28:
 432 013a 00C0      		rjmp .L25
 433               	.LBE118:
 434               	.LBE119:
 435               	.LBE124:
 436               		.cfi_endproc
 437               	.LFE26:
 439               	.global	PrintFromPROGMEM
 441               	PrintFromPROGMEM:
 442               	.LFB28:
 725:stk500boot.c  ****     }
 726:stk500boot.c  **** }
 727:stk500boot.c  **** 
 728:stk500boot.c  **** 
 729:stk500boot.c  **** //*****************************************************************************
 730:stk500boot.c  **** int main(void)
 731:stk500boot.c  **** {
 732:stk500boot.c  **** 	address_t		address			=	0;
 733:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 734:stk500boot.c  **** 	unsigned char	msgParseState;
 735:stk500boot.c  **** 	unsigned int	ii				=	0;
 736:stk500boot.c  **** 	unsigned char	checksum		=	0;
 737:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 738:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 739:stk500boot.c  **** 	unsigned char	msgBuffer[285];
 740:stk500boot.c  **** 	unsigned char	c, *p;
 741:stk500boot.c  **** 	unsigned char   isLeave = 0;
 742:stk500boot.c  **** 
 743:stk500boot.c  **** 	unsigned long	boot_timeout;
 744:stk500boot.c  **** 	unsigned long	boot_timer;
 745:stk500boot.c  **** 	unsigned int	boot_state;
 746:stk500boot.c  **** #ifdef ENABLE_MONITOR
 747:stk500boot.c  **** 	unsigned int	exPointCntr		=	0;
 748:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 749:stk500boot.c  **** #endif
 750:stk500boot.c  **** 
 751:stk500boot.c  **** 	//*	some chips dont set the stack properly
 752:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 753:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 754:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 755:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 756:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 757:stk500boot.c  **** 
 758:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 759:stk500boot.c  **** 	//************************************************************************
 760:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 761:stk500boot.c  **** 	//*	handle the watch dog timer
 762:stk500boot.c  **** 	uint8_t	mcuStatusReg;
 763:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 764:stk500boot.c  **** 
 765:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 766:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 767:stk500boot.c  **** 	MCUSR	=	0;
 768:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 769:stk500boot.c  **** 	WDTCSR	=	0;
 770:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 771:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 772:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 773:stk500boot.c  **** 	{
 774:stk500boot.c  **** 		app_start();
 775:stk500boot.c  **** 	}
 776:stk500boot.c  **** 	//************************************************************************
 777:stk500boot.c  **** #endif
 778:stk500boot.c  **** 
 779:stk500boot.c  **** 
 780:stk500boot.c  **** 	boot_timer	=	0;
 781:stk500boot.c  **** 	boot_state	=	0;
 782:stk500boot.c  **** 
 783:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 784:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 785:stk500boot.c  **** //	boot_timeout	=	170000;
 786:stk500boot.c  **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 787:stk500boot.c  **** #else
 788:stk500boot.c  **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 789:stk500boot.c  **** #endif
 790:stk500boot.c  **** 	/*
 791:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 792:stk500boot.c  **** 	 */
 793:stk500boot.c  **** 
 794:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 795:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 796:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 797:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 798:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 799:stk500boot.c  **** 
 800:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 801:stk500boot.c  **** 	for (ii=0; ii<3; ii++)
 802:stk500boot.c  **** 	{
 803:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 804:stk500boot.c  **** 		delay_ms(100);
 805:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 806:stk500boot.c  **** 		delay_ms(100);
 807:stk500boot.c  **** 	}
 808:stk500boot.c  **** #endif
 809:stk500boot.c  **** 
 810:stk500boot.c  **** #endif
 811:stk500boot.c  **** 	/*
 812:stk500boot.c  **** 	 * Init UART
 813:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 814:stk500boot.c  **** 	 */
 815:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 816:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 817:stk500boot.c  **** #endif
 818:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 819:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 820:stk500boot.c  **** 
 821:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 822:stk500boot.c  **** 	
 823:stk500boot.c  **** 	corebeep_init();
 824:stk500boot.c  **** 	corebeep_off();
 825:stk500boot.c  **** 	beep_init();
 826:stk500boot.c  **** 	beep_off();
 827:stk500boot.c  **** 	
 828:stk500boot.c  **** 	current_boot_count = eeprom_read_byte(EEPROM_COUNTER_ADDR);
 829:stk500boot.c  **** 	if (current_boot_count == 0xFF) {
 830:stk500boot.c  **** 		current_boot_count = 0;
 831:stk500boot.c  **** 		eeprom_write_byte(EEPROM_COUNTER_ADDR, 0);
 832:stk500boot.c  **** 	}
 833:stk500boot.c  **** 
 834:stk500boot.c  **** 	if (current_boot_count >= MAX_BOOT_COUNTS)
 835:stk500boot.c  **** 	{
 836:stk500boot.c  **** 		gInterceptAppJump = 1;
 837:stk500boot.c  **** 	}
 838:stk500boot.c  **** 
 839:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
 840:stk500boot.c  **** //	delay_ms(500);
 841:stk500boot.c  **** 
 842:stk500boot.c  **** 	sendchar('s');
 843:stk500boot.c  **** 	sendchar('t');
 844:stk500boot.c  **** 	sendchar('k');
 845:stk500boot.c  **** //	sendchar('5');
 846:stk500boot.c  **** //	sendchar('0');
 847:stk500boot.c  **** //	sendchar('0');
 848:stk500boot.c  **** 	sendchar('v');
 849:stk500boot.c  **** 	sendchar('2');
 850:stk500boot.c  **** 	sendchar(0x0d);
 851:stk500boot.c  **** 	sendchar(0x0a);
 852:stk500boot.c  **** 
 853:stk500boot.c  **** 	delay_ms(100);
 854:stk500boot.c  **** #endif
 855:stk500boot.c  **** 
 856:stk500boot.c  **** 	while (boot_state==0)
 857:stk500boot.c  **** 	{
 858:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 859:stk500boot.c  **** 		{
 860:stk500boot.c  **** 			_delay_ms(0.001);
 861:stk500boot.c  **** 			boot_timer++;
 862:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 863:stk500boot.c  **** 			{
 864:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 865:stk500boot.c  **** 			}
 866:stk500boot.c  **** 		#ifdef BLINK_LED_WHILE_WAITING
 867:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 868:stk500boot.c  **** 			{
 869:stk500boot.c  **** 				//*	toggle the LED
 870:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 871:stk500boot.c  **** 			}
 872:stk500boot.c  **** 		#endif
 873:stk500boot.c  **** 		}
 874:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 875:stk500boot.c  **** 	}
 876:stk500boot.c  **** 
 877:stk500boot.c  **** 
 878:stk500boot.c  **** 	if (boot_state==1)
 879:stk500boot.c  **** 	{
 880:stk500boot.c  **** 		//*	main loop
 881:stk500boot.c  **** 		while (!isLeave)
 882:stk500boot.c  **** 		{
 883:stk500boot.c  **** 			/*
 884:stk500boot.c  **** 			 * Collect received bytes to a complete message
 885:stk500boot.c  **** 			 */
 886:stk500boot.c  **** 			msgParseState	=	ST_START;
 887:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 888:stk500boot.c  **** 			{
 889:stk500boot.c  **** 				if (boot_state==1)
 890:stk500boot.c  **** 				{
 891:stk500boot.c  **** 					boot_state	=	0;
 892:stk500boot.c  **** 					c			=	UART_DATA_REG;
 893:stk500boot.c  **** 				}
 894:stk500boot.c  **** 				else
 895:stk500boot.c  **** 				{
 896:stk500boot.c  **** 				//	c	=	recchar();
 897:stk500boot.c  **** 					c	=	recchar_timeout();
 898:stk500boot.c  **** 					
 899:stk500boot.c  **** 				}
 900:stk500boot.c  **** 
 901:stk500boot.c  **** 			#ifdef ENABLE_MONITOR
 902:stk500boot.c  **** 				rcvdCharCntr++;
 903:stk500boot.c  **** 
 904:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 905:stk500boot.c  **** 				{
 906:stk500boot.c  **** 					exPointCntr++;
 907:stk500boot.c  **** 					if (exPointCntr == 3)
 908:stk500boot.c  **** 					{
 909:stk500boot.c  **** 						RunMonitor();
 910:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 911:stk500boot.c  **** 						isLeave			=	1;
 912:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 913:stk500boot.c  **** 						break;
 914:stk500boot.c  **** 					}
 915:stk500boot.c  **** 				}
 916:stk500boot.c  **** 				else
 917:stk500boot.c  **** 				{
 918:stk500boot.c  **** 					exPointCntr	=	0;
 919:stk500boot.c  **** 				}
 920:stk500boot.c  **** 			#endif
 921:stk500boot.c  **** 
 922:stk500boot.c  **** 				switch (msgParseState)
 923:stk500boot.c  **** 				{
 924:stk500boot.c  **** 					case ST_START:
 925:stk500boot.c  **** 						if ( c == MESSAGE_START )
 926:stk500boot.c  **** 						{
 927:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 928:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 929:stk500boot.c  **** 						}
 930:stk500boot.c  **** 						break;
 931:stk500boot.c  **** 
 932:stk500boot.c  **** 					case ST_GET_SEQ_NUM:
 933:stk500boot.c  **** 					#ifdef _FIX_ISSUE_505_
 934:stk500boot.c  **** 						seqNum			=	c;
 935:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 936:stk500boot.c  **** 						checksum		^=	c;
 937:stk500boot.c  **** 					#else
 938:stk500boot.c  **** 						if ( (c == 1) || (c == seqNum) )
 939:stk500boot.c  **** 						{
 940:stk500boot.c  **** 							seqNum			=	c;
 941:stk500boot.c  **** 							msgParseState	=	ST_MSG_SIZE_1;
 942:stk500boot.c  **** 							checksum		^=	c;
 943:stk500boot.c  **** 						}
 944:stk500boot.c  **** 						else
 945:stk500boot.c  **** 						{
 946:stk500boot.c  **** 							msgParseState	=	ST_START;
 947:stk500boot.c  **** 						}
 948:stk500boot.c  **** 					#endif
 949:stk500boot.c  **** 						break;
 950:stk500boot.c  **** 
 951:stk500boot.c  **** 					case ST_MSG_SIZE_1:
 952:stk500boot.c  **** 						msgLength		=	c<<8;
 953:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 954:stk500boot.c  **** 						checksum		^=	c;
 955:stk500boot.c  **** 						break;
 956:stk500boot.c  **** 
 957:stk500boot.c  **** 					case ST_MSG_SIZE_2:
 958:stk500boot.c  **** 						msgLength		|=	c;
 959:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 960:stk500boot.c  **** 						checksum		^=	c;
 961:stk500boot.c  **** 						break;
 962:stk500boot.c  **** 
 963:stk500boot.c  **** 					case ST_GET_TOKEN:
 964:stk500boot.c  **** 						if ( c == TOKEN )
 965:stk500boot.c  **** 						{
 966:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 967:stk500boot.c  **** 							checksum		^=	c;
 968:stk500boot.c  **** 							ii				=	0;
 969:stk500boot.c  **** 						}
 970:stk500boot.c  **** 						else
 971:stk500boot.c  **** 						{
 972:stk500boot.c  **** 							msgParseState	=	ST_START;
 973:stk500boot.c  **** 						}
 974:stk500boot.c  **** 						break;
 975:stk500boot.c  **** 
 976:stk500boot.c  **** 					case ST_GET_DATA:
 977:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 978:stk500boot.c  **** 						checksum		^=	c;
 979:stk500boot.c  **** 						if (ii == msgLength )
 980:stk500boot.c  **** 						{
 981:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 982:stk500boot.c  **** 						}
 983:stk500boot.c  **** 						break;
 984:stk500boot.c  **** 
 985:stk500boot.c  **** 					case ST_GET_CHECK:
 986:stk500boot.c  **** 						if ( c == checksum )
 987:stk500boot.c  **** 						{
 988:stk500boot.c  **** 							msgParseState	=	ST_PROCESS;
 989:stk500boot.c  **** 						}
 990:stk500boot.c  **** 						else
 991:stk500boot.c  **** 						{
 992:stk500boot.c  **** 							msgParseState	=	ST_START;
 993:stk500boot.c  **** 						}
 994:stk500boot.c  **** 						break;
 995:stk500boot.c  **** 				}	//	switch
 996:stk500boot.c  **** 			}	//	while(msgParseState)
 997:stk500boot.c  **** 
 998:stk500boot.c  **** 			/*
 999:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
1000:stk500boot.c  **** 			 */
1001:stk500boot.c  **** 
1002:stk500boot.c  **** 			switch (msgBuffer[0])
1003:stk500boot.c  **** 			{
1004:stk500boot.c  **** 	#ifndef REMOVE_CMD_SPI_MULTI
1005:stk500boot.c  **** 				case CMD_SPI_MULTI:
1006:stk500boot.c  **** 					{
1007:stk500boot.c  **** 						unsigned char answerByte;
1008:stk500boot.c  **** 						unsigned char flag=0;
1009:stk500boot.c  **** 
1010:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
1011:stk500boot.c  **** 						{
1012:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
1013:stk500boot.c  **** 
1014:stk500boot.c  **** 							if ( signatureIndex == 0 )
1015:stk500boot.c  **** 							{
1016:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
1017:stk500boot.c  **** 							}
1018:stk500boot.c  **** 							else if ( signatureIndex == 1 )
1019:stk500boot.c  **** 							{
1020:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
1021:stk500boot.c  **** 							}
1022:stk500boot.c  **** 							else
1023:stk500boot.c  **** 							{
1024:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
1025:stk500boot.c  **** 							}
1026:stk500boot.c  **** 						}
1027:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
1028:stk500boot.c  **** 						{
1029:stk500boot.c  **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
1030:stk500boot.c  **** 						//*	I cant find the docs that say what these are supposed to be but this was figured out by t
1031:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1032:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1033:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
1034:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
1035:stk500boot.c  **** 							{
1036:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1037:stk500boot.c  **** 							}
1038:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
1039:stk500boot.c  **** 							{
1040:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1041:stk500boot.c  **** 							}
1042:stk500boot.c  **** 							else
1043:stk500boot.c  **** 							{
1044:stk500boot.c  **** 								answerByte	=	0;
1045:stk500boot.c  **** 							}
1046:stk500boot.c  **** 						}
1047:stk500boot.c  **** 						else
1048:stk500boot.c  **** 						{
1049:stk500boot.c  **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
1050:stk500boot.c  **** 						}
1051:stk500boot.c  **** 						if ( !flag )
1052:stk500boot.c  **** 						{
1053:stk500boot.c  **** 							msgLength		=	7;
1054:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
1055:stk500boot.c  **** 							msgBuffer[2]	=	0;
1056:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
1057:stk500boot.c  **** 							msgBuffer[4]	=	0;
1058:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
1059:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
1060:stk500boot.c  **** 						}
1061:stk500boot.c  **** 					}
1062:stk500boot.c  **** 					break;
1063:stk500boot.c  **** 	#endif
1064:stk500boot.c  **** 				case CMD_SIGN_ON:
1065:stk500boot.c  **** 					msgLength		=	11;
1066:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
1067:stk500boot.c  **** 					msgBuffer[2] 	=	8;
1068:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
1069:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
1070:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
1071:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
1072:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
1073:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
1074:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
1075:stk500boot.c  **** 					msgBuffer[10]	=	'2';
1076:stk500boot.c  **** 					break;
1077:stk500boot.c  **** 
1078:stk500boot.c  **** 				case CMD_GET_PARAMETER:
1079:stk500boot.c  **** 					{
1080:stk500boot.c  **** 						unsigned char value;
1081:stk500boot.c  **** 
1082:stk500boot.c  **** 						switch(msgBuffer[1])
1083:stk500boot.c  **** 						{
1084:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_LOW:
1085:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
1086:stk500boot.c  **** 							break;
1087:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_HIGH:
1088:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
1089:stk500boot.c  **** 							break;
1090:stk500boot.c  **** 						case PARAM_HW_VER:
1091:stk500boot.c  **** 							value	=	CONFIG_PARAM_HW_VER;
1092:stk500boot.c  **** 							break;
1093:stk500boot.c  **** 						case PARAM_SW_MAJOR:
1094:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MAJOR;
1095:stk500boot.c  **** 							break;
1096:stk500boot.c  **** 						case PARAM_SW_MINOR:
1097:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MINOR;
1098:stk500boot.c  **** 							break;
1099:stk500boot.c  **** 						default:
1100:stk500boot.c  **** 							value	=	0;
1101:stk500boot.c  **** 							break;
1102:stk500boot.c  **** 						}
1103:stk500boot.c  **** 						msgLength		=	3;
1104:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1105:stk500boot.c  **** 						msgBuffer[2]	=	value;
1106:stk500boot.c  **** 					}
1107:stk500boot.c  **** 					break;
1108:stk500boot.c  **** 
1109:stk500boot.c  **** 				case CMD_LEAVE_PROGMODE_ISP:
1110:stk500boot.c  **** 					if (gHasFlashed)
1111:stk500boot.c  **** 					{
1112:stk500boot.c  **** 						uint8_t cnt = eeprom_read_byte(EEPROM_COUNTER_ADDR);
1113:stk500boot.c  **** 						if (cnt == 0xFF) cnt = 0;
1114:stk500boot.c  **** 
1115:stk500boot.c  **** 						if (cnt < MAX_BOOT_COUNTS) {
1116:stk500boot.c  **** 							cnt++;
1117:stk500boot.c  **** 							eeprom_write_byte(EEPROM_COUNTER_ADDR, cnt);
1118:stk500boot.c  **** 						}
1119:stk500boot.c  **** 					}
1120:stk500boot.c  **** 					isLeave = 1;
1121:stk500boot.c  **** 					//*	fall thru
1122:stk500boot.c  **** 
1123:stk500boot.c  **** 				case CMD_SET_PARAMETER:
1124:stk500boot.c  **** 				case CMD_ENTER_PROGMODE_ISP:
1125:stk500boot.c  **** 					msgLength		=	2;
1126:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
1127:stk500boot.c  **** 					break;
1128:stk500boot.c  **** 
1129:stk500boot.c  **** 				case CMD_READ_SIGNATURE_ISP:
1130:stk500boot.c  **** 					{
1131:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
1132:stk500boot.c  **** 						unsigned char signature;
1133:stk500boot.c  **** 
1134:stk500boot.c  **** 						if ( signatureIndex == 0 )
1135:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
1136:stk500boot.c  **** 						else if ( signatureIndex == 1 )
1137:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
1138:stk500boot.c  **** 						else
1139:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
1140:stk500boot.c  **** 
1141:stk500boot.c  **** 						msgLength		=	4;
1142:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1143:stk500boot.c  **** 						msgBuffer[2]	=	signature;
1144:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
1145:stk500boot.c  **** 					}
1146:stk500boot.c  **** 					break;
1147:stk500boot.c  **** 
1148:stk500boot.c  **** 				case CMD_READ_LOCK_ISP:
1149:stk500boot.c  **** 					msgLength		=	4;
1150:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
1151:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
1152:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
1153:stk500boot.c  **** 					break;
1154:stk500boot.c  **** 
1155:stk500boot.c  **** 				case CMD_READ_FUSE_ISP:
1156:stk500boot.c  **** 					{
1157:stk500boot.c  **** 						unsigned char fuseBits;
1158:stk500boot.c  **** 
1159:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
1160:stk500boot.c  **** 						{
1161:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
1162:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
1163:stk500boot.c  **** 							else
1164:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
1165:stk500boot.c  **** 						}
1166:stk500boot.c  **** 						else
1167:stk500boot.c  **** 						{
1168:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
1169:stk500boot.c  **** 						}
1170:stk500boot.c  **** 						msgLength		=	4;
1171:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1172:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
1173:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
1174:stk500boot.c  **** 					}
1175:stk500boot.c  **** 					break;
1176:stk500boot.c  **** 
1177:stk500boot.c  **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
1178:stk500boot.c  **** 				case CMD_PROGRAM_LOCK_ISP:
1179:stk500boot.c  **** 					{
1180:stk500boot.c  **** 						unsigned char lockBits	=	msgBuffer[4];
1181:stk500boot.c  **** 
1182:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
1183:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
1184:stk500boot.c  **** 						boot_spm_busy_wait();
1185:stk500boot.c  **** 
1186:stk500boot.c  **** 						msgLength		=	3;
1187:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1188:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
1189:stk500boot.c  **** 					}
1190:stk500boot.c  **** 					break;
1191:stk500boot.c  **** 	#endif
1192:stk500boot.c  **** 				case CMD_CHIP_ERASE_ISP:
1193:stk500boot.c  **** 					eraseAddress	=	0;
1194:stk500boot.c  **** 					msgLength		=	2;
1195:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
1196:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
1197:stk500boot.c  **** 					break;
1198:stk500boot.c  **** 
1199:stk500boot.c  **** 				case CMD_LOAD_ADDRESS:
1200:stk500boot.c  **** 	#if defined(RAMPZ)
1201:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
1202:stk500boot.c  **** 	#else
1203:stk500boot.c  **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
1204:stk500boot.c  **** 	#endif
1205:stk500boot.c  **** 					msgLength		=	2;
1206:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
1207:stk500boot.c  **** 					break;
1208:stk500boot.c  **** 
1209:stk500boot.c  **** 				case CMD_PROGRAM_FLASH_ISP:
1210:stk500boot.c  **** 				case CMD_PROGRAM_EEPROM_ISP:
1211:stk500boot.c  **** 					{
1212:stk500boot.c  **** 						// ====== [修改 4] 标记本次会话进行了写入 ======
1213:stk500boot.c  ****                         if (msgBuffer[0] == CMD_PROGRAM_FLASH_ISP) {
1214:stk500boot.c  ****                             gHasFlashed = 1;
1215:stk500boot.c  ****                         }
1216:stk500boot.c  **** 
1217:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1218:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
1219:stk500boot.c  **** 						unsigned int	data;
1220:stk500boot.c  **** 						unsigned char	highByte, lowByte;
1221:stk500boot.c  **** 						address_t		tempaddress	=	address;
1222:stk500boot.c  **** 
1223:stk500boot.c  **** 
1224:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
1225:stk500boot.c  **** 						{
1226:stk500boot.c  **** 							// erase only main section (bootloader protection)
1227:stk500boot.c  **** 							if (eraseAddress < APP_END )
1228:stk500boot.c  **** 							{
1229:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
1230:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
1231:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
1232:stk500boot.c  **** 							}
1233:stk500boot.c  **** 
1234:stk500boot.c  **** 							/* Write FLASH */
1235:stk500boot.c  **** 							do {
1236:stk500boot.c  **** 								lowByte		=	*p++;
1237:stk500boot.c  **** 								highByte 	=	*p++;
1238:stk500boot.c  **** 
1239:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
1240:stk500boot.c  **** 								boot_page_fill(address,data);
1241:stk500boot.c  **** 
1242:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
1243:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
1244:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1245:stk500boot.c  **** 
1246:stk500boot.c  **** 							boot_page_write(tempaddress);
1247:stk500boot.c  **** 							boot_spm_busy_wait();
1248:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
1249:stk500boot.c  **** 						}
1250:stk500boot.c  **** 						else
1251:stk500boot.c  **** 						{
1252:stk500boot.c  **** 							//*	issue 543, this should work, It has not been tested.
1253:stk500boot.c  **** 							uint16_t ii = address >> 1;
1254:stk500boot.c  **** 							/* write EEPROM */
1255:stk500boot.c  **** 							while (size) {
1256:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
1257:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
1258:stk500boot.c  **** 								ii++;
1259:stk500boot.c  **** 								size--;
1260:stk500boot.c  **** 							}
1261:stk500boot.c  **** 						}
1262:stk500boot.c  **** 						msgLength		=	2;
1263:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1264:stk500boot.c  **** 					}
1265:stk500boot.c  **** 					break;
1266:stk500boot.c  **** 
1267:stk500boot.c  **** 				case CMD_READ_FLASH_ISP:
1268:stk500boot.c  **** 				case CMD_READ_EEPROM_ISP:
1269:stk500boot.c  **** 					{
1270:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1271:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
1272:stk500boot.c  **** 						msgLength				=	size+3;
1273:stk500boot.c  **** 
1274:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1275:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
1276:stk500boot.c  **** 						{
1277:stk500boot.c  **** 							unsigned int data;
1278:stk500boot.c  **** 
1279:stk500boot.c  **** 							// Read FLASH
1280:stk500boot.c  **** 							do {
1281:stk500boot.c  **** 						//#if defined(RAMPZ)
1282:stk500boot.c  **** 						#if (FLASHEND > 0x10000)
1283:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
1284:stk500boot.c  **** 						#else
1285:stk500boot.c  **** 								data	=	pgm_read_word_near(address);
1286:stk500boot.c  **** 						#endif
1287:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
1288:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
1289:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
1290:stk500boot.c  **** 								size	-=	2;
1291:stk500boot.c  **** 							}while (size);
1292:stk500boot.c  **** 						}
1293:stk500boot.c  **** 						else
1294:stk500boot.c  **** 						{
1295:stk500boot.c  **** 							/* Read EEPROM */
1296:stk500boot.c  **** 							do {
1297:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1298:stk500boot.c  **** 								EEARH	=	((address >> 8));
1299:stk500boot.c  **** 								address++;					// Select next EEPROM byte
1300:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
1301:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
1302:stk500boot.c  **** 								size--;
1303:stk500boot.c  **** 							} while (size);
1304:stk500boot.c  **** 						}
1305:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1306:stk500boot.c  **** 					}
1307:stk500boot.c  **** 					break;
1308:stk500boot.c  **** 
1309:stk500boot.c  **** 				default:
1310:stk500boot.c  **** 					msgLength		=	2;
1311:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
1312:stk500boot.c  **** 					break;
1313:stk500boot.c  **** 			}
1314:stk500boot.c  **** 
1315:stk500boot.c  **** 			/*
1316:stk500boot.c  **** 			 * Now send answer message back
1317:stk500boot.c  **** 			 */
1318:stk500boot.c  **** 			sendchar(MESSAGE_START);
1319:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1320:stk500boot.c  **** 
1321:stk500boot.c  **** 			sendchar(seqNum);
1322:stk500boot.c  **** 			checksum	^=	seqNum;
1323:stk500boot.c  **** 
1324:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
1325:stk500boot.c  **** 			sendchar(c);
1326:stk500boot.c  **** 			checksum	^=	c;
1327:stk500boot.c  **** 
1328:stk500boot.c  **** 			c			=	msgLength&0x00FF;
1329:stk500boot.c  **** 			sendchar(c);
1330:stk500boot.c  **** 			checksum ^= c;
1331:stk500boot.c  **** 
1332:stk500boot.c  **** 			sendchar(TOKEN);
1333:stk500boot.c  **** 			checksum ^= TOKEN;
1334:stk500boot.c  **** 
1335:stk500boot.c  **** 			p	=	msgBuffer;
1336:stk500boot.c  **** 			while ( msgLength )
1337:stk500boot.c  **** 			{
1338:stk500boot.c  **** 				c	=	*p++;
1339:stk500boot.c  **** 				sendchar(c);
1340:stk500boot.c  **** 				checksum ^=c;
1341:stk500boot.c  **** 				msgLength--;
1342:stk500boot.c  **** 			}
1343:stk500boot.c  **** 			sendchar(checksum);
1344:stk500boot.c  **** 			seqNum++;
1345:stk500boot.c  **** 	
1346:stk500boot.c  **** 		#ifndef REMOVE_BOOTLOADER_LED
1347:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1348:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
1349:stk500boot.c  **** 		#endif
1350:stk500boot.c  **** 
1351:stk500boot.c  **** 		}
1352:stk500boot.c  **** 	}
1353:stk500boot.c  **** 
1354:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
1355:stk500boot.c  **** 	//*	this is for debugging it can be removed
1356:stk500boot.c  **** 	for (ii=0; ii<10; ii++)
1357:stk500boot.c  **** 	{
1358:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1359:stk500boot.c  **** 		delay_ms(200);
1360:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1361:stk500boot.c  **** 		delay_ms(200);
1362:stk500boot.c  **** 	}
1363:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1364:stk500boot.c  **** #endif
1365:stk500boot.c  **** 
1366:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
1367:stk500boot.c  **** 	sendchar('j');
1368:stk500boot.c  **** //	sendchar('u');
1369:stk500boot.c  **** //	sendchar('m');
1370:stk500boot.c  **** //	sendchar('p');
1371:stk500boot.c  **** //	sendchar(' ');
1372:stk500boot.c  **** //	sendchar('u');
1373:stk500boot.c  **** //	sendchar('s');
1374:stk500boot.c  **** //	sendchar('r');
1375:stk500boot.c  **** 	sendchar(0x0d);
1376:stk500boot.c  **** 	sendchar(0x0a);
1377:stk500boot.c  **** 
1378:stk500boot.c  **** 	delay_ms(100);
1379:stk500boot.c  **** #endif
1380:stk500boot.c  **** 
1381:stk500boot.c  **** 
1382:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1383:stk500boot.c  **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
1384:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
1385:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
1386:stk500boot.c  **** 	delay_ms(100);							// delay after exit
1387:stk500boot.c  **** #endif
1388:stk500boot.c  **** 
1389:stk500boot.c  **** 
1390:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
1391:stk500boot.c  **** 
1392:stk500boot.c  **** 	/*
1393:stk500boot.c  **** 	 * Now leave bootloader
1394:stk500boot.c  **** 	 */
1395:stk500boot.c  **** 
1396:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
1397:stk500boot.c  **** 	boot_rww_enable();				// enable application section
1398:stk500boot.c  **** 
1399:stk500boot.c  **** 	if (gInterceptAppJump) {
1400:stk500boot.c  **** 		user_code();
1401:stk500boot.c  **** 	}
1402:stk500boot.c  **** 
1403:stk500boot.c  **** 	asm volatile(
1404:stk500boot.c  **** 			"clr	r30		\n\t"
1405:stk500boot.c  **** 			"clr	r31		\n\t"
1406:stk500boot.c  **** 			"ijmp	\n\t"
1407:stk500boot.c  **** 			);
1408:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1409:stk500boot.c  **** //					"push r1" "\n\t"
1410:stk500boot.c  **** //					"ret"	 "\n\t"
1411:stk500boot.c  **** //					::);
1412:stk500boot.c  **** 
1413:stk500boot.c  **** 	 /*
1414:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1415:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1416:stk500boot.c  **** 	 * understand this
1417:stk500boot.c  **** 	 */
1418:stk500boot.c  **** 	for(;;);
1419:stk500boot.c  **** }
1420:stk500boot.c  **** 
1421:stk500boot.c  **** /*
1422:stk500boot.c  **** base address = f800
1423:stk500boot.c  **** 
1424:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1425:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1426:stk500boot.c  **** avrdude: safemode: hfuse reads as DA
1427:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1428:stk500boot.c  **** avrdude>
1429:stk500boot.c  **** 
1430:stk500boot.c  **** 
1431:stk500boot.c  **** base address = f000
1432:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1433:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1434:stk500boot.c  **** avrdude: safemode: hfuse reads as D8
1435:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1436:stk500boot.c  **** avrdude>
1437:stk500boot.c  **** */
1438:stk500boot.c  **** 
1439:stk500boot.c  **** //************************************************************************
1440:stk500boot.c  **** #ifdef ENABLE_MONITOR
1441:stk500boot.c  **** #include	<math.h>
1442:stk500boot.c  **** 
1443:stk500boot.c  **** unsigned long	gRamIndex;
1444:stk500boot.c  **** unsigned long	gFlashIndex;
1445:stk500boot.c  **** unsigned long	gEepromIndex;
1446:stk500boot.c  **** 
1447:stk500boot.c  **** 
1448:stk500boot.c  **** #define	true	1
1449:stk500boot.c  **** #define	false	0
1450:stk500boot.c  **** 
1451:stk500boot.c  **** #include	"avr_cpunames.h"
1452:stk500boot.c  **** 
1453:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1454:stk500boot.c  **** 	#error cpu name not defined
1455:stk500boot.c  **** #endif
1456:stk500boot.c  **** 
1457:stk500boot.c  **** #ifdef _VECTORS_SIZE
1458:stk500boot.c  **** 	#define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1459:stk500boot.c  **** #else
1460:stk500boot.c  **** 	#define	kInterruptVectorCount 23
1461:stk500boot.c  **** #endif
1462:stk500boot.c  **** 
1463:stk500boot.c  **** 
1464:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt);
1465:stk500boot.c  **** 
1466:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1467:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	_AVR_CPU_NAME_;
1468:stk500boot.c  **** #else
1469:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	"UNKNOWN";
1470:stk500boot.c  **** #endif
1471:stk500boot.c  **** 
1472:stk500boot.c  **** 	const char	gTextMsg_Explorer[]			PROGMEM	=	"Arduino explorer stk500V2 by MLS";
1473:stk500boot.c  **** 	const char	gTextMsg_Prompt[]			PROGMEM	=	"Bootloader>";
1474:stk500boot.c  **** 	const char	gTextMsg_HUH[]				PROGMEM	=	"Huh?";
1475:stk500boot.c  **** 	const char	gTextMsg_COMPILED_ON[]		PROGMEM	=	"Compiled on = ";
1476:stk500boot.c  **** 	const char	gTextMsg_CPU_Type[]			PROGMEM	=	"CPU Type    = ";
1477:stk500boot.c  **** 	const char	gTextMsg_AVR_ARCH[]			PROGMEM	=	"__AVR_ARCH__= ";
1478:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC[]			PROGMEM	=	"AVR LibC Ver= ";
1479:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION[]		PROGMEM	=	"GCC Version = ";
1480:stk500boot.c  **** 	const char	gTextMsg_CPU_SIGNATURE[]	PROGMEM	=	"CPU ID      = ";
1481:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOW[]	PROGMEM	=	"Low fuse    = ";
1482:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_HIGH[]	PROGMEM	=	"High fuse   = ";
1483:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_EXT[]	PROGMEM	=	"Ext fuse    = ";
1484:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOCK[]	PROGMEM	=	"Lock fuse   = ";
1485:stk500boot.c  **** 	const char	gTextMsg_GCC_DATE_STR[]		PROGMEM	=	__DATE__;
1486:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC_VER_STR[]	PROGMEM	=	__AVR_LIBC_VERSION_STRING__;
1487:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION_STR[]	PROGMEM	=	__VERSION__;
1488:stk500boot.c  **** 	const char	gTextMsg_VECTOR_HEADER[]	PROGMEM	=	"V#   ADDR   op code     instruction addr   Interrup
1489:stk500boot.c  **** 	const char	gTextMsg_noVector[]			PROGMEM	=	"no vector";
1490:stk500boot.c  **** 	const char	gTextMsg_rjmp[]				PROGMEM	=	"rjmp  ";
1491:stk500boot.c  **** 	const char	gTextMsg_jmp[]				PROGMEM	=	"jmp ";
1492:stk500boot.c  **** 	const char	gTextMsg_WHAT_PORT[]		PROGMEM	=	"What port:";
1493:stk500boot.c  **** 	const char	gTextMsg_PortNotSupported[]	PROGMEM	=	"Port not supported";
1494:stk500boot.c  **** 	const char	gTextMsg_MustBeLetter[]		PROGMEM	=	"Must be a letter";
1495:stk500boot.c  **** 	const char	gTextMsg_SPACE[]			PROGMEM	=	" ";
1496:stk500boot.c  **** 	const char	gTextMsg_WriteToEEprom[]	PROGMEM	=	"Writting EE";
1497:stk500boot.c  **** 	const char	gTextMsg_ReadingEEprom[]	PROGMEM	=	"Reading EE";
1498:stk500boot.c  **** 	const char	gTextMsg_EEPROMerrorCnt[]	PROGMEM	=	"EE err cnt=";
1499:stk500boot.c  **** 	const char	gTextMsg_PORT[]				PROGMEM	=	"PORT";
1500:stk500boot.c  **** 
1501:stk500boot.c  **** 
1502:stk500boot.c  **** //************************************************************************
1503:stk500boot.c  **** //*	Help messages
1504:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_0[]		PROGMEM	=	"0=Zero addr";
1505:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_QM[]		PROGMEM	=	"?=CPU stats";
1506:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_AT[]		PROGMEM	=	"@=EEPROM test";
1507:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_B[]		PROGMEM	=	"B=Blink LED";
1508:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_E[]		PROGMEM	=	"E=Dump EEPROM";
1509:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_F[]		PROGMEM	=	"F=Dump FLASH";
1510:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_H[]		PROGMEM	=	"H=Help";
1511:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_L[]		PROGMEM	=	"L=List I/O Ports";
1512:stk500boot.c  **** //	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit & jump to user pgm";
1513:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit";
1514:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_R[]		PROGMEM	=	"R=Dump RAM";
1515:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_V[]		PROGMEM	=	"V=show interrupt Vectors";
1516:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Y[]		PROGMEM	=	"Y=Port blink";
1517:stk500boot.c  **** 
1518:stk500boot.c  **** 	const char	gTextMsg_END[]				PROGMEM	=	"*";
1519:stk500boot.c  **** 
1520:stk500boot.c  **** 
1521:stk500boot.c  **** //************************************************************************
1522:stk500boot.c  **** void	PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1523:stk500boot.c  **** {
 443               		.loc 1 1523 0
 444               		.cfi_startproc
 445               	.LVL29:
 446 013c CF93      		push r28
 447               	.LCFI0:
 448               		.cfi_def_cfa_offset 4
 449               		.cfi_offset 28, -3
 450 013e DF93      		push r29
 451               	.LCFI1:
 452               		.cfi_def_cfa_offset 5
 453               		.cfi_offset 29, -4
 454               	/* prologue: function */
 455               	/* frame size = 0 */
 456               	/* stack size = 2 */
 457               	.L__stack_usage = 2
1524:stk500boot.c  **** char	theChar;
1525:stk500boot.c  **** 
1526:stk500boot.c  **** 	dataPtr		+=	offset;
 458               		.loc 1 1526 0
 459 0140 EC01      		movw r28,r24
 460 0142 C60F      		add r28,r22
 461 0144 D11D      		adc r29,__zero_reg__
 462               	.LVL30:
 463               	.L33:
 464               	.LBB125:
1527:stk500boot.c  **** 
1528:stk500boot.c  **** 	do {
1529:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1530:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint16_t)dataPtr++);
 465               		.loc 1 1530 0
 466 0146 CE01      		movw r24,r28
 467 0148 B0E0      		ldi r27,0
 468 014a A0E0      		ldi r26,0
 469               	/* #APP */
 470               	 ;  1530 "stk500boot.c" 1
 471 014c ABBF      		out 59, r26
 472 014e FC01      		movw r30, r24
 473 0150 8791      		elpm r24, Z+
 474               		
 475               	 ;  0 "" 2
 476               	.LVL31:
 477               	/* #NOAPP */
 478               	.LBE125:
1531:stk500boot.c  **** 	#else
1532:stk500boot.c  **** 		theChar	=	pgm_read_byte_near((uint16_t)dataPtr++);
1533:stk500boot.c  **** 	#endif
1534:stk500boot.c  **** 		if (theChar != 0)
 479               		.loc 1 1534 0
 480 0152 8823      		tst r24
 481 0154 01F0      		breq .L31
 482               	.LBB126:
1530:stk500boot.c  **** 	#else
 483               		.loc 1 1530 0
 484 0156 2196      		adiw r28,1
 485               	.LVL32:
 486               	.LBE126:
1535:stk500boot.c  **** 		{
1536:stk500boot.c  **** 			sendchar(theChar);
 487               		.loc 1 1536 0
 488 0158 0E94 0000 		call sendchar
 489               	.LVL33:
 490 015c 00C0      		rjmp .L33
 491               	.LVL34:
 492               	.L31:
 493               	/* epilogue start */
1537:stk500boot.c  **** 		}
1538:stk500boot.c  **** 	} while (theChar != 0);
1539:stk500boot.c  **** }
 494               		.loc 1 1539 0
 495 015e DF91      		pop r29
 496 0160 CF91      		pop r28
 497               	.LVL35:
 498 0162 0895      		ret
 499               		.cfi_endproc
 500               	.LFE28:
 502               	.global	PrintNewLine
 504               	PrintNewLine:
 505               	.LFB29:
1540:stk500boot.c  **** 
1541:stk500boot.c  **** //************************************************************************
1542:stk500boot.c  **** void	PrintNewLine(void)
1543:stk500boot.c  **** {
 506               		.loc 1 1543 0
 507               		.cfi_startproc
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 0 */
 511               	.L__stack_usage = 0
1544:stk500boot.c  **** 	sendchar(0x0d);
 512               		.loc 1 1544 0
 513 0164 8DE0      		ldi r24,lo8(13)
 514 0166 0E94 0000 		call sendchar
 515               	.LVL36:
1545:stk500boot.c  **** 	sendchar(0x0a);
 516               		.loc 1 1545 0
 517 016a 8AE0      		ldi r24,lo8(10)
 518 016c 0C94 0000 		jmp sendchar
 519               	.LVL37:
 520               		.cfi_endproc
 521               	.LFE29:
 523               		.section	.text.unlikely
 525               	PrintAvailablePort:
 526               	.LFB39:
1546:stk500boot.c  **** }
1547:stk500boot.c  **** 
1548:stk500boot.c  **** 
1549:stk500boot.c  **** //************************************************************************
1550:stk500boot.c  **** void	PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1551:stk500boot.c  **** {
1552:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
1553:stk500boot.c  **** 
1554:stk500boot.c  **** 	PrintNewLine();
1555:stk500boot.c  **** }
1556:stk500boot.c  **** 
1557:stk500boot.c  **** 
1558:stk500boot.c  **** //************************************************************************
1559:stk500boot.c  **** void	PrintString(char *textString)
1560:stk500boot.c  **** {
1561:stk500boot.c  **** char	theChar;
1562:stk500boot.c  **** int		ii;
1563:stk500boot.c  **** 
1564:stk500boot.c  **** 	theChar		=	1;
1565:stk500boot.c  **** 	ii			=	0;
1566:stk500boot.c  **** 	while (theChar != 0)
1567:stk500boot.c  **** 	{
1568:stk500boot.c  **** 		theChar	=	textString[ii];
1569:stk500boot.c  **** 		if (theChar != 0)
1570:stk500boot.c  **** 		{
1571:stk500boot.c  **** 			sendchar(theChar);
1572:stk500boot.c  **** 		}
1573:stk500boot.c  **** 		ii++;
1574:stk500boot.c  **** 	}
1575:stk500boot.c  **** }
1576:stk500boot.c  **** 
1577:stk500boot.c  **** //************************************************************************
1578:stk500boot.c  **** void	PrintHexByte(unsigned char theByte)
1579:stk500boot.c  **** {
1580:stk500boot.c  **** char	theChar;
1581:stk500boot.c  **** 
1582:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
1583:stk500boot.c  **** 	if (theChar > 0x39)
1584:stk500boot.c  **** 	{
1585:stk500boot.c  **** 		theChar	+=	7;
1586:stk500boot.c  **** 	}
1587:stk500boot.c  **** 	sendchar(theChar );
1588:stk500boot.c  **** 
1589:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
1590:stk500boot.c  **** 	if (theChar > 0x39)
1591:stk500boot.c  **** 	{
1592:stk500boot.c  **** 		theChar	+=	7;
1593:stk500boot.c  **** 	}
1594:stk500boot.c  **** 	sendchar(theChar );
1595:stk500boot.c  **** }
1596:stk500boot.c  **** 
1597:stk500boot.c  **** //************************************************************************
1598:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt)
1599:stk500boot.c  **** {
1600:stk500boot.c  **** int	theChar;
1601:stk500boot.c  **** int	myNumber;
1602:stk500boot.c  **** 
1603:stk500boot.c  **** 	myNumber	=	theNumber;
1604:stk500boot.c  **** 
1605:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
1606:stk500boot.c  **** 	{
1607:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
1608:stk500boot.c  **** 		sendchar(theChar );
1609:stk500boot.c  **** 	}
1610:stk500boot.c  **** 
1611:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
1612:stk500boot.c  **** 	{
1613:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
1614:stk500boot.c  **** 		sendchar(theChar );
1615:stk500boot.c  **** 	}
1616:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
1617:stk500boot.c  **** 	sendchar(theChar );
1618:stk500boot.c  **** }
1619:stk500boot.c  **** 
1620:stk500boot.c  **** 
1621:stk500boot.c  **** 
1622:stk500boot.c  **** 
1623:stk500boot.c  **** //************************************************************************
1624:stk500boot.c  **** static void	PrintCPUstats(void)
1625:stk500boot.c  **** {
1626:stk500boot.c  **** unsigned char fuseByte;
1627:stk500boot.c  **** 
1628:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
1629:stk500boot.c  **** 
1630:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);
1631:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
1632:stk500boot.c  **** 
1633:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_Type, 0);
1634:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1635:stk500boot.c  **** 
1636:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);
1637:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
1638:stk500boot.c  **** 	PrintNewLine();
1639:stk500boot.c  **** 
1640:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);
1641:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
1642:stk500boot.c  **** 
1643:stk500boot.c  **** 	//*	these can be found in avr/version.h
1644:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);
1645:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
1646:stk500boot.c  **** 
1647:stk500boot.c  **** #if defined(SIGNATURE_0)
1648:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);
1649:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
1650:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
1651:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
1652:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
1653:stk500boot.c  **** 	PrintNewLine();
1654:stk500boot.c  **** #endif
1655:stk500boot.c  **** 
1656:stk500boot.c  **** 
1657:stk500boot.c  **** #if defined(GET_LOW_FUSE_BITS)
1658:stk500boot.c  **** 	//*	fuse settings
1659:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);
1660:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1661:stk500boot.c  **** 	PrintHexByte(fuseByte);
1662:stk500boot.c  **** 	PrintNewLine();
1663:stk500boot.c  **** 
1664:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);
1665:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1666:stk500boot.c  **** 	PrintHexByte(fuseByte);
1667:stk500boot.c  **** 	PrintNewLine();
1668:stk500boot.c  **** 
1669:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);
1670:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
1671:stk500boot.c  **** 	PrintHexByte(fuseByte);
1672:stk500boot.c  **** 	PrintNewLine();
1673:stk500boot.c  **** 
1674:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);
1675:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
1676:stk500boot.c  **** 	PrintHexByte(fuseByte);
1677:stk500boot.c  **** 	PrintNewLine();
1678:stk500boot.c  **** 
1679:stk500boot.c  **** #endif
1680:stk500boot.c  **** 
1681:stk500boot.c  **** }
1682:stk500boot.c  **** 
1683:stk500boot.c  **** 
1684:stk500boot.c  **** //************************************************************************
1685:stk500boot.c  **** static void BlinkLED(void)
1686:stk500boot.c  **** {
1687:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
1688:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
1689:stk500boot.c  **** 
1690:stk500boot.c  **** 	while (!Serial_Available())
1691:stk500boot.c  **** 	{
1692:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1693:stk500boot.c  **** 		delay_ms(100);
1694:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1695:stk500boot.c  **** 		delay_ms(100);
1696:stk500boot.c  **** 	}
1697:stk500boot.c  **** 	recchar();	//	get the char out of the buffer
1698:stk500boot.c  **** }
1699:stk500boot.c  **** 
1700:stk500boot.c  **** enum
1701:stk500boot.c  **** {
1702:stk500boot.c  **** 	kDUMP_FLASH	=	0,
1703:stk500boot.c  **** 	kDUMP_EEPROM,
1704:stk500boot.c  **** 	kDUMP_RAM
1705:stk500boot.c  **** };
1706:stk500boot.c  **** 
1707:stk500boot.c  **** //************************************************************************
1708:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
1709:stk500boot.c  **** {
1710:stk500boot.c  **** unsigned long	myAddressPointer;
1711:stk500boot.c  **** uint8_t			ii;
1712:stk500boot.c  **** unsigned char	theValue;
1713:stk500boot.c  **** char			asciiDump[18];
1714:stk500boot.c  **** unsigned char	*ramPtr;
1715:stk500boot.c  **** 
1716:stk500boot.c  **** 
1717:stk500boot.c  **** 	ramPtr				=	0;
1718:stk500boot.c  **** 	theValue			=	0;
1719:stk500boot.c  **** 	myAddressPointer	=	startAddress;
1720:stk500boot.c  **** 	while (numRows > 0)
1721:stk500boot.c  **** 	{
1722:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
1723:stk500boot.c  **** 		{
1724:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
1725:stk500boot.c  **** 		}
1726:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
1727:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
1728:stk500boot.c  **** 		sendchar(0x20);
1729:stk500boot.c  **** 		sendchar('-');
1730:stk500boot.c  **** 		sendchar(0x20);
1731:stk500boot.c  **** 
1732:stk500boot.c  **** 		asciiDump[0]		=	0;
1733:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
1734:stk500boot.c  **** 		{
1735:stk500boot.c  **** 			switch(dumpWhat)
1736:stk500boot.c  **** 			{
1737:stk500boot.c  **** 				case kDUMP_FLASH:
1738:stk500boot.c  **** 				#if (FLASHEND > 0x10000)
1739:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
1740:stk500boot.c  **** 				#else
1741:stk500boot.c  **** 					theValue	=	pgm_read_byte_near(myAddressPointer);
1742:stk500boot.c  **** 				#endif
1743:stk500boot.c  **** 					break;
1744:stk500boot.c  **** 
1745:stk500boot.c  **** 				case kDUMP_EEPROM:
1746:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
1747:stk500boot.c  **** 					break;
1748:stk500boot.c  **** 
1749:stk500boot.c  **** 				case kDUMP_RAM:
1750:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
1751:stk500boot.c  **** 					break;
1752:stk500boot.c  **** 
1753:stk500boot.c  **** 			}
1754:stk500boot.c  **** 			PrintHexByte(theValue);
1755:stk500boot.c  **** 			sendchar(0x20);
1756:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
1757:stk500boot.c  **** 			{
1758:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
1759:stk500boot.c  **** 			}
1760:stk500boot.c  **** 			else
1761:stk500boot.c  **** 			{
1762:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
1763:stk500boot.c  **** 			}
1764:stk500boot.c  **** 
1765:stk500boot.c  **** 			myAddressPointer++;
1766:stk500boot.c  **** 		}
1767:stk500boot.c  **** 		asciiDump[16]	=	0;
1768:stk500boot.c  **** 		PrintString(asciiDump);
1769:stk500boot.c  **** 		PrintNewLine();
1770:stk500boot.c  **** 
1771:stk500boot.c  **** 		numRows--;
1772:stk500boot.c  **** 	}
1773:stk500boot.c  **** }
1774:stk500boot.c  **** 
1775:stk500boot.c  **** 
1776:stk500boot.c  **** 
1777:stk500boot.c  **** //************************************************************************
1778:stk500boot.c  **** //*	returns amount of extended memory
1779:stk500boot.c  **** static void	EEPROMtest(void)
1780:stk500boot.c  **** {
1781:stk500boot.c  **** int		ii;
1782:stk500boot.c  **** char	theChar;
1783:stk500boot.c  **** char	theEEPROMchar;
1784:stk500boot.c  **** int		errorCount;
1785:stk500boot.c  **** 
1786:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);
1787:stk500boot.c  **** 	PrintNewLine();
1788:stk500boot.c  **** 	ii			=	0;
1789:stk500boot.c  **** #if (FLASHEND > 0x10000)
1790:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1791:stk500boot.c  **** #else
1792:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1793:stk500boot.c  **** #endif
1794:stk500boot.c  **** 	{
1795:stk500boot.c  **** 		eeprom_write_byte((uint8_t *)ii, theChar);
1796:stk500boot.c  **** 		if (theChar == 0)
1797:stk500boot.c  **** 		{
1798:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1799:stk500boot.c  **** 		}
1800:stk500boot.c  **** 		else
1801:stk500boot.c  **** 		{
1802:stk500boot.c  **** 			sendchar(theChar);
1803:stk500boot.c  **** 		}
1804:stk500boot.c  **** 		ii++;
1805:stk500boot.c  **** 	}
1806:stk500boot.c  **** 
1807:stk500boot.c  **** 	//*	no go back through and test
1808:stk500boot.c  **** 	PrintNewLine();
1809:stk500boot.c  **** 	PrintNewLine();
1810:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
1811:stk500boot.c  **** 	PrintNewLine();
1812:stk500boot.c  **** 	errorCount	=	0;
1813:stk500boot.c  **** 	ii			=	0;
1814:stk500boot.c  **** #if (FLASHEND > 0x10000)
1815:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1816:stk500boot.c  **** #else
1817:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1818:stk500boot.c  **** #endif
1819:stk500boot.c  **** 	{
1820:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((uint8_t *)ii);
1821:stk500boot.c  **** 		if (theEEPROMchar == 0)
1822:stk500boot.c  **** 		{
1823:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1824:stk500boot.c  **** 		}
1825:stk500boot.c  **** 		else
1826:stk500boot.c  **** 		{
1827:stk500boot.c  **** 			sendchar(theEEPROMchar);
1828:stk500boot.c  **** 		}
1829:stk500boot.c  **** 		if (theEEPROMchar != theChar)
1830:stk500boot.c  **** 		{
1831:stk500boot.c  **** 			errorCount++;
1832:stk500boot.c  **** 		}
1833:stk500boot.c  **** 		ii++;
1834:stk500boot.c  **** 	}
1835:stk500boot.c  **** 	PrintNewLine();
1836:stk500boot.c  **** 	PrintNewLine();
1837:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
1838:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
1839:stk500boot.c  **** 	PrintNewLine();
1840:stk500boot.c  **** 	PrintNewLine();
1841:stk500boot.c  **** 
1842:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
1843:stk500boot.c  **** 
1844:stk500boot.c  **** }
1845:stk500boot.c  **** 
1846:stk500boot.c  **** 
1847:stk500boot.c  **** 
1848:stk500boot.c  **** #if (FLASHEND > 0x08000)
1849:stk500boot.c  **** //*	this includes the interrupt names for the monitor portion. There is no longer enough 
1850:stk500boot.c  **** //*	memory to include this
1851:stk500boot.c  **** //	#include	"avrinterruptnames.h"
1852:stk500boot.c  **** //	#ifndef _INTERRUPT_NAMES_DEFINED_
1853:stk500boot.c  **** //		#warning Interrupt vectors not defined
1854:stk500boot.c  **** //	#endif
1855:stk500boot.c  **** #endif
1856:stk500boot.c  **** 
1857:stk500boot.c  **** //************************************************************************
1858:stk500boot.c  **** static void	VectorDisplay(void)
1859:stk500boot.c  **** {
1860:stk500boot.c  **** unsigned long	byte1;
1861:stk500boot.c  **** unsigned long	byte2;
1862:stk500boot.c  **** unsigned long	byte3;
1863:stk500boot.c  **** unsigned long	byte4;
1864:stk500boot.c  **** unsigned long	word1;
1865:stk500boot.c  **** unsigned long	word2;
1866:stk500boot.c  **** int				vectorIndex;
1867:stk500boot.c  **** unsigned long	myMemoryPtr;
1868:stk500boot.c  **** unsigned long	wordMemoryAddress;
1869:stk500boot.c  **** unsigned long	realitiveAddr;
1870:stk500boot.c  **** unsigned long	myFullAddress;
1871:stk500boot.c  **** unsigned long	absoluteAddr;
1872:stk500boot.c  **** #if defined(_INTERRUPT_NAMES_DEFINED_)
1873:stk500boot.c  **** 	long		stringPointer;
1874:stk500boot.c  **** #endif
1875:stk500boot.c  **** 
1876:stk500boot.c  **** 	myMemoryPtr		=	0;
1877:stk500boot.c  **** 	vectorIndex		=	0;
1878:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1879:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
1880:stk500boot.c  **** 	//					 V#   ADDR   op code
1881:stk500boot.c  **** 	//					  1 - 0000 = C3 BB 00 00 rjmp 03BB >000776 RESET
1882:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
1883:stk500boot.c  **** 	{
1884:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
1885:stk500boot.c  **** 		//					 01 - 0000 = 12 34
1886:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
1887:stk500boot.c  **** 		sendchar(0x20);
1888:stk500boot.c  **** 		sendchar('-');
1889:stk500boot.c  **** 		sendchar(0x20);
1890:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
1891:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
1892:stk500boot.c  **** 		sendchar(0x20);
1893:stk500boot.c  **** 		sendchar('=');
1894:stk500boot.c  **** 		sendchar(0x20);
1895:stk500boot.c  **** 
1896:stk500boot.c  **** 	
1897:stk500boot.c  **** 		//*	the AVR is LITTLE ENDIAN, swap the byte order
1898:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1899:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
1900:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
1901:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
1902:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
1903:stk500boot.c  **** 	#else
1904:stk500boot.c  **** 		byte1	=	pgm_read_byte_near(myMemoryPtr++);
1905:stk500boot.c  **** 		byte2	=	pgm_read_byte_near(myMemoryPtr++);
1906:stk500boot.c  **** 		byte3	=	pgm_read_byte_near(myMemoryPtr++);
1907:stk500boot.c  **** 		byte4	=	pgm_read_byte_near(myMemoryPtr++);
1908:stk500boot.c  **** 	#endif
1909:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
1910:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
1911:stk500boot.c  **** 
1912:stk500boot.c  **** 
1913:stk500boot.c  **** 		PrintHexByte(byte2);
1914:stk500boot.c  **** 		sendchar(0x20);
1915:stk500boot.c  **** 		PrintHexByte(byte1);
1916:stk500boot.c  **** 		sendchar(0x20);
1917:stk500boot.c  **** 		PrintHexByte(byte4);
1918:stk500boot.c  **** 		sendchar(0x20);
1919:stk500boot.c  **** 		PrintHexByte(byte3);
1920:stk500boot.c  **** 		sendchar(0x20);
1921:stk500boot.c  **** 	
1922:stk500boot.c  **** 		if (word1 == 0xffff)
1923:stk500boot.c  **** 		{
1924:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_noVector, 0);
1925:stk500boot.c  **** 		}
1926:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
1927:stk500boot.c  **** 		{
1928:stk500boot.c  **** 			//*	rjmp instruction
1929:stk500boot.c  **** 			realitiveAddr	=	word1 & 0x3FFF;
1930:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
1931:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
1932:stk500boot.c  **** 
1933:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_rjmp, 0);
1934:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
1935:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
1936:stk500boot.c  **** 			sendchar(0x20);
1937:stk500boot.c  **** 			sendchar('>');
1938:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1939:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1940:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1941:stk500boot.c  **** 	
1942:stk500boot.c  **** 		}
1943:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
1944:stk500boot.c  **** 		{
1945:stk500boot.c  **** 			//*	jmp instruction, this is REALLY complicated, refer to the instruction manual (JMP)
1946:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
1947:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
1948:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
1949:stk500boot.c  **** 								word2;
1950:stk500boot.c  **** 							
1951:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
1952:stk500boot.c  **** 							
1953:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_jmp, 0);
1954:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
1955:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
1956:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
1957:stk500boot.c  **** 			sendchar(0x20);
1958:stk500boot.c  **** 			sendchar('>');
1959:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1960:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1961:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1962:stk500boot.c  **** 		}
1963:stk500boot.c  **** 
1964:stk500boot.c  **** 	#if defined(_INTERRUPT_NAMES_DEFINED_)
1965:stk500boot.c  **** 		sendchar(0x20);
1966:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1967:stk500boot.c  **** 		stringPointer	=	pgm_read_word_far(&(gInterruptNameTable[vectorIndex]));
1968:stk500boot.c  **** 	#else
1969:stk500boot.c  **** 		stringPointer	=	pgm_read_word_near(&(gInterruptNameTable[vectorIndex]));
1970:stk500boot.c  **** 	#endif
1971:stk500boot.c  **** 		PrintFromPROGMEM((char *)stringPointer, 0);
1972:stk500boot.c  **** 	#endif
1973:stk500boot.c  **** 		PrintNewLine();
1974:stk500boot.c  **** 
1975:stk500boot.c  **** 		vectorIndex++;
1976:stk500boot.c  **** 	}
1977:stk500boot.c  **** }
1978:stk500boot.c  **** 
1979:stk500boot.c  **** //************************************************************************
1980:stk500boot.c  **** static void	PrintAvailablePort(char thePortLetter)
1981:stk500boot.c  **** {
 527               		.loc 1 1981 0
 528               		.cfi_startproc
 529               	.LVL38:
 530 000e CF93      		push r28
 531               	.LCFI2:
 532               		.cfi_def_cfa_offset 4
 533               		.cfi_offset 28, -3
 534               	/* prologue: function */
 535               	/* frame size = 0 */
 536               	/* stack size = 1 */
 537               	.L__stack_usage = 1
 538 0010 C82F      		mov r28,r24
1982:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_PORT, 0);
 539               		.loc 1 1982 0
 540 0012 60E0      		ldi r22,0
 541 0014 80E0      		ldi r24,lo8(gTextMsg_PORT)
 542 0016 90E0      		ldi r25,hi8(gTextMsg_PORT)
 543               	.LVL39:
 544 0018 0E94 0000 		call PrintFromPROGMEM
 545               	.LVL40:
1983:stk500boot.c  **** 	sendchar(thePortLetter);
 546               		.loc 1 1983 0
 547 001c 8C2F      		mov r24,r28
 548 001e 0E94 0000 		call sendchar
 549               	.LVL41:
 550               	/* epilogue start */
1984:stk500boot.c  **** 	PrintNewLine();
1985:stk500boot.c  **** }
 551               		.loc 1 1985 0
 552 0022 CF91      		pop r28
 553               	.LVL42:
1984:stk500boot.c  **** 	PrintNewLine();
 554               		.loc 1 1984 0
 555 0024 0C94 0000 		jmp PrintNewLine
 556               	.LVL43:
 557               		.cfi_endproc
 558               	.LFE39:
 560               		.text
 561               	.global	PrintFromPROGMEMln
 563               	PrintFromPROGMEMln:
 564               	.LFB30:
1551:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 565               		.loc 1 1551 0
 566               		.cfi_startproc
 567               	.LVL44:
 568               	/* prologue: function */
 569               	/* frame size = 0 */
 570               	/* stack size = 0 */
 571               	.L__stack_usage = 0
1552:stk500boot.c  **** 
 572               		.loc 1 1552 0
 573 0170 0E94 0000 		call PrintFromPROGMEM
 574               	.LVL45:
1554:stk500boot.c  **** }
 575               		.loc 1 1554 0
 576 0174 0C94 0000 		jmp PrintNewLine
 577               	.LVL46:
 578               		.cfi_endproc
 579               	.LFE30:
 581               	.global	PrintString
 583               	PrintString:
 584               	.LFB31:
1560:stk500boot.c  **** char	theChar;
 585               		.loc 1 1560 0
 586               		.cfi_startproc
 587               	.LVL47:
 588 0178 CF93      		push r28
 589               	.LCFI3:
 590               		.cfi_def_cfa_offset 4
 591               		.cfi_offset 28, -3
 592 017a DF93      		push r29
 593               	.LCFI4:
 594               		.cfi_def_cfa_offset 5
 595               		.cfi_offset 29, -4
 596               	/* prologue: function */
 597               	/* frame size = 0 */
 598               	/* stack size = 2 */
 599               	.L__stack_usage = 2
 600 017c EC01      		movw r28,r24
 601               	.LVL48:
 602               	.L39:
1568:stk500boot.c  **** 		if (theChar != 0)
 603               		.loc 1 1568 0
 604 017e 8991      		ld r24,Y+
 605               	.LVL49:
1569:stk500boot.c  **** 		{
 606               		.loc 1 1569 0
 607 0180 8823      		tst r24
 608 0182 01F0      		breq .L37
1571:stk500boot.c  **** 		}
 609               		.loc 1 1571 0
 610 0184 0E94 0000 		call sendchar
 611               	.LVL50:
 612 0188 00C0      		rjmp .L39
 613               	.LVL51:
 614               	.L37:
 615               	/* epilogue start */
1575:stk500boot.c  **** 
 616               		.loc 1 1575 0
 617 018a DF91      		pop r29
 618 018c CF91      		pop r28
 619               	.LVL52:
 620 018e 0895      		ret
 621               		.cfi_endproc
 622               	.LFE31:
 624               	.global	PrintHexByte
 626               	PrintHexByte:
 627               	.LFB32:
1579:stk500boot.c  **** char	theChar;
 628               		.loc 1 1579 0
 629               		.cfi_startproc
 630               	.LVL53:
 631 0190 CF93      		push r28
 632               	.LCFI5:
 633               		.cfi_def_cfa_offset 4
 634               		.cfi_offset 28, -3
 635               	/* prologue: function */
 636               	/* frame size = 0 */
 637               	/* stack size = 1 */
 638               	.L__stack_usage = 1
 639 0192 C82F      		mov r28,r24
1582:stk500boot.c  **** 	if (theChar > 0x39)
 640               		.loc 1 1582 0
 641 0194 982F      		mov r25,r24
 642 0196 9295      		swap r25
 643 0198 9F70      		andi r25,lo8(15)
 644 019a 80E3      		ldi r24,lo8(48)
 645               	.LVL54:
 646 019c 890F      		add r24,r25
 647               	.LVL55:
1583:stk500boot.c  **** 	{
 648               		.loc 1 1583 0
 649 019e 8A33      		cpi r24,lo8(58)
 650 01a0 00F0      		brlo .L41
1585:stk500boot.c  **** 	}
 651               		.loc 1 1585 0
 652 01a2 87E3      		ldi r24,lo8(55)
 653               	.LVL56:
 654 01a4 890F      		add r24,r25
 655               	.LVL57:
 656               	.L41:
1587:stk500boot.c  **** 
 657               		.loc 1 1587 0
 658 01a6 0E94 0000 		call sendchar
 659               	.LVL58:
1589:stk500boot.c  **** 	if (theChar > 0x39)
 660               		.loc 1 1589 0
 661 01aa CF70      		andi r28,lo8(15)
 662               	.LVL59:
 663 01ac 80E3      		ldi r24,lo8(48)
 664 01ae 8C0F      		add r24,r28
 665               	.LVL60:
1590:stk500boot.c  **** 	{
 666               		.loc 1 1590 0
 667 01b0 8A33      		cpi r24,lo8(58)
 668 01b2 00F0      		brlo .L42
1592:stk500boot.c  **** 	}
 669               		.loc 1 1592 0
 670 01b4 87E3      		ldi r24,lo8(55)
 671               	.LVL61:
 672 01b6 8C0F      		add r24,r28
 673               	.LVL62:
 674               	.L42:
 675               	/* epilogue start */
1595:stk500boot.c  **** 
 676               		.loc 1 1595 0
 677 01b8 CF91      		pop r28
1594:stk500boot.c  **** }
 678               		.loc 1 1594 0
 679 01ba 0C94 0000 		jmp sendchar
 680               	.LVL63:
 681               		.cfi_endproc
 682               	.LFE32:
 684               		.section	.text.unlikely
 686               	DumpHex.constprop.1:
 687               	.LFB45:
1708:stk500boot.c  **** {
 688               		.loc 1 1708 0
 689               		.cfi_startproc
 690               	.LVL64:
 691 0028 2F92      		push r2
 692               	.LCFI6:
 693               		.cfi_def_cfa_offset 4
 694               		.cfi_offset 2, -3
 695 002a 3F92      		push r3
 696               	.LCFI7:
 697               		.cfi_def_cfa_offset 5
 698               		.cfi_offset 3, -4
 699 002c 4F92      		push r4
 700               	.LCFI8:
 701               		.cfi_def_cfa_offset 6
 702               		.cfi_offset 4, -5
 703 002e 5F92      		push r5
 704               	.LCFI9:
 705               		.cfi_def_cfa_offset 7
 706               		.cfi_offset 5, -6
 707 0030 6F92      		push r6
 708               	.LCFI10:
 709               		.cfi_def_cfa_offset 8
 710               		.cfi_offset 6, -7
 711 0032 7F92      		push r7
 712               	.LCFI11:
 713               		.cfi_def_cfa_offset 9
 714               		.cfi_offset 7, -8
 715 0034 8F92      		push r8
 716               	.LCFI12:
 717               		.cfi_def_cfa_offset 10
 718               		.cfi_offset 8, -9
 719 0036 9F92      		push r9
 720               	.LCFI13:
 721               		.cfi_def_cfa_offset 11
 722               		.cfi_offset 9, -10
 723 0038 AF92      		push r10
 724               	.LCFI14:
 725               		.cfi_def_cfa_offset 12
 726               		.cfi_offset 10, -11
 727 003a BF92      		push r11
 728               	.LCFI15:
 729               		.cfi_def_cfa_offset 13
 730               		.cfi_offset 11, -12
 731 003c CF92      		push r12
 732               	.LCFI16:
 733               		.cfi_def_cfa_offset 14
 734               		.cfi_offset 12, -13
 735 003e DF92      		push r13
 736               	.LCFI17:
 737               		.cfi_def_cfa_offset 15
 738               		.cfi_offset 13, -14
 739 0040 EF92      		push r14
 740               	.LCFI18:
 741               		.cfi_def_cfa_offset 16
 742               		.cfi_offset 14, -15
 743 0042 FF92      		push r15
 744               	.LCFI19:
 745               		.cfi_def_cfa_offset 17
 746               		.cfi_offset 15, -16
 747 0044 0F93      		push r16
 748               	.LCFI20:
 749               		.cfi_def_cfa_offset 18
 750               		.cfi_offset 16, -17
 751 0046 1F93      		push r17
 752               	.LCFI21:
 753               		.cfi_def_cfa_offset 19
 754               		.cfi_offset 17, -18
 755 0048 CF93      		push r28
 756               	.LCFI22:
 757               		.cfi_def_cfa_offset 20
 758               		.cfi_offset 28, -19
 759 004a DF93      		push r29
 760               	.LCFI23:
 761               		.cfi_def_cfa_offset 21
 762               		.cfi_offset 29, -20
 763 004c CDB7      		in r28,__SP_L__
 764 004e DEB7      		in r29,__SP_H__
 765               	.LCFI24:
 766               		.cfi_def_cfa_register 28
 767 0050 6397      		sbiw r28,19
 768               	.LCFI25:
 769               		.cfi_def_cfa_offset 40
 770 0052 0FB6      		in __tmp_reg__,__SREG__
 771 0054 F894      		cli
 772 0056 DEBF      		out __SP_H__,r29
 773 0058 0FBE      		out __SREG__,__tmp_reg__
 774 005a CDBF      		out __SP_L__,r28
 775               	/* prologue: function */
 776               	/* frame size = 19 */
 777               	/* stack size = 37 */
 778               	.L__stack_usage = 37
 779 005c 8B8B      		std Y+19,r24
 780 005e 6A01      		movw r12,r20
 781 0060 7B01      		movw r14,r22
 782               	.LVL65:
1708:stk500boot.c  **** {
 783               		.loc 1 1708 0
 784 0062 80E1      		ldi r24,lo8(16)
 785 0064 A82E      		mov r10,r24
 786               	.LVL66:
 787 0066 4E01      		movw r8,r28
 788 0068 81E1      		ldi r24,17
 789 006a 880E      		add r8,r24
 790 006c 911C      		adc r9,__zero_reg__
 791               	.LVL67:
 792               	.L52:
1722:stk500boot.c  **** 		{
 793               		.loc 1 1722 0
 794 006e E1E0      		ldi r30,1
 795 0070 CE16      		cp r12,r30
 796 0072 D104      		cpc r13,__zero_reg__
 797 0074 EE06      		cpc r14,r30
 798 0076 F104      		cpc r15,__zero_reg__
 799 0078 00F0      		brlo .L44
1724:stk500boot.c  **** 		}
 800               		.loc 1 1724 0
 801 007a 8E2D      		mov r24,r14
 802 007c 0E94 0000 		call PrintHexByte
 803               	.LVL68:
 804               	.L44:
1726:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
 805               		.loc 1 1726 0
 806 0080 8D2D      		mov r24,r13
 807 0082 0E94 0000 		call PrintHexByte
 808               	.LVL69:
1727:stk500boot.c  **** 		sendchar(0x20);
 809               		.loc 1 1727 0
 810 0086 8C2D      		mov r24,r12
 811 0088 0E94 0000 		call PrintHexByte
 812               	.LVL70:
1728:stk500boot.c  **** 		sendchar('-');
 813               		.loc 1 1728 0
 814 008c 80E2      		ldi r24,lo8(32)
 815 008e 0E94 0000 		call sendchar
 816               	.LVL71:
1729:stk500boot.c  **** 		sendchar(0x20);
 817               		.loc 1 1729 0
 818 0092 8DE2      		ldi r24,lo8(45)
 819 0094 0E94 0000 		call sendchar
 820               	.LVL72:
1730:stk500boot.c  **** 
 821               		.loc 1 1730 0
 822 0098 80E2      		ldi r24,lo8(32)
 823 009a 0E94 0000 		call sendchar
 824               	.LVL73:
1732:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
 825               		.loc 1 1732 0
 826 009e 1982      		std Y+1,__zero_reg__
 827               	.LVL74:
 828 00a0 8E01      		movw r16,r28
 829 00a2 0F5F      		subi r16,-1
 830 00a4 1F4F      		sbci r17,-1
 831 00a6 2601      		movw r4,r12
 832 00a8 3701      		movw r6,r14
 833 00aa 1801      		movw r2,r16
 834               	.LVL75:
 835               	.L51:
1735:stk500boot.c  **** 			{
 836               		.loc 1 1735 0
 837 00ac FB89      		ldd r31,Y+19
 838 00ae F130      		cpi r31,lo8(1)
 839 00b0 01F4      		brne .+2
 840 00b2 00C0      		rjmp .L46
 841 00b4 F230      		cpi r31,lo8(2)
 842 00b6 01F4      		brne .+2
 843 00b8 00C0      		rjmp .L47
 844               	.LVL76:
 845               	.LBB127:
1739:stk500boot.c  **** 				#else
 846               		.loc 1 1739 0
 847               	/* #APP */
 848               	 ;  1739 "stk500boot.c" 1
 849 00ba 6BBE      		out 59, r6
 850 00bc F201      		movw r30, r4
 851 00be B790      		elpm r11, Z+
 852               		
 853               	 ;  0 "" 2
 854               	.LVL77:
 855               	/* #NOAPP */
 856               	.L48:
 857               	.LBE127:
1754:stk500boot.c  **** 			sendchar(0x20);
 858               		.loc 1 1754 0
 859 00c0 8B2D      		mov r24,r11
 860 00c2 0E94 0000 		call PrintHexByte
 861               	.LVL78:
1755:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
 862               		.loc 1 1755 0
 863 00c6 80E2      		ldi r24,lo8(32)
 864 00c8 0E94 0000 		call sendchar
 865               	.LVL79:
1756:stk500boot.c  **** 			{
 866               		.loc 1 1756 0
 867 00cc 80EE      		ldi r24,lo8(-32)
 868 00ce 8B0D      		add r24,r11
 869 00d0 8F35      		cpi r24,lo8(95)
 870 00d2 00F4      		brsh .L49
1758:stk500boot.c  **** 			}
 871               		.loc 1 1758 0
 872 00d4 F801      		movw r30,r16
 873 00d6 B082      		st Z,r11
 874               	.L50:
1765:stk500boot.c  **** 		}
 875               		.loc 1 1765 0
 876 00d8 EFEF      		ldi r30,-1
 877 00da 4E1A      		sub r4,r30
 878 00dc 5E0A      		sbc r5,r30
 879 00de 6E0A      		sbc r6,r30
 880 00e0 7E0A      		sbc r7,r30
 881               	.LVL80:
 882 00e2 0F5F      		subi r16,-1
 883 00e4 1F4F      		sbci r17,-1
1733:stk500boot.c  **** 		{
 884               		.loc 1 1733 0
 885 00e6 0815      		cp r16,r8
 886 00e8 1905      		cpc r17,r9
 887 00ea 01F4      		brne .L51
 888 00ec F0E1      		ldi r31,16
 889 00ee CF0E      		add r12,r31
 890 00f0 D11C      		adc r13,__zero_reg__
 891 00f2 E11C      		adc r14,__zero_reg__
 892 00f4 F11C      		adc r15,__zero_reg__
1767:stk500boot.c  **** 		PrintString(asciiDump);
 893               		.loc 1 1767 0
 894 00f6 198A      		std Y+17,__zero_reg__
1768:stk500boot.c  **** 		PrintNewLine();
 895               		.loc 1 1768 0
 896 00f8 C101      		movw r24,r2
 897 00fa 0E94 0000 		call PrintString
 898               	.LVL81:
1769:stk500boot.c  **** 
 899               		.loc 1 1769 0
 900 00fe 0E94 0000 		call PrintNewLine
 901               	.LVL82:
 902 0102 AA94      		dec r10
 903               	.LVL83:
1720:stk500boot.c  **** 	{
 904               		.loc 1 1720 0
 905 0104 A110      		cpse r10,__zero_reg__
 906 0106 00C0      		rjmp .L52
 907               	/* epilogue start */
1773:stk500boot.c  **** 
 908               		.loc 1 1773 0
 909 0108 6396      		adiw r28,19
 910               	.LVL84:
 911 010a 0FB6      		in __tmp_reg__,__SREG__
 912 010c F894      		cli
 913 010e DEBF      		out __SP_H__,r29
 914 0110 0FBE      		out __SREG__,__tmp_reg__
 915 0112 CDBF      		out __SP_L__,r28
 916 0114 DF91      		pop r29
 917 0116 CF91      		pop r28
 918               	.LVL85:
 919 0118 1F91      		pop r17
 920 011a 0F91      		pop r16
 921 011c FF90      		pop r15
 922 011e EF90      		pop r14
 923 0120 DF90      		pop r13
 924 0122 CF90      		pop r12
 925               	.LVL86:
 926 0124 BF90      		pop r11
 927 0126 AF90      		pop r10
 928               	.LVL87:
 929 0128 9F90      		pop r9
 930 012a 8F90      		pop r8
 931 012c 7F90      		pop r7
 932 012e 6F90      		pop r6
 933 0130 5F90      		pop r5
 934 0132 4F90      		pop r4
 935 0134 3F90      		pop r3
 936 0136 2F90      		pop r2
 937 0138 0895      		ret
 938               	.LVL88:
 939               	.L46:
1746:stk500boot.c  **** 					break;
 940               		.loc 1 1746 0
 941 013a C201      		movw r24,r4
 942 013c 0E94 0000 		call eeprom_read_byte
 943               	.LVL89:
 944 0140 B82E      		mov r11,r24
 945               	.LVL90:
 946 0142 00C0      		rjmp .L48
 947               	.LVL91:
 948               	.L47:
1750:stk500boot.c  **** 					break;
 949               		.loc 1 1750 0
 950 0144 F201      		movw r30,r4
 951 0146 B080      		ld r11,Z
 952               	.LVL92:
 953 0148 00C0      		rjmp .L48
 954               	.L49:
1762:stk500boot.c  **** 			}
 955               		.loc 1 1762 0
 956 014a 8EE2      		ldi r24,lo8(46)
 957 014c F801      		movw r30,r16
 958 014e 8083      		st Z,r24
 959 0150 00C0      		rjmp .L50
 960               		.cfi_endproc
 961               	.LFE45:
 963               		.text
 964               	.global	PrintDecInt
 966               	PrintDecInt:
 967               	.LFB33:
1599:stk500boot.c  **** int	theChar;
 968               		.loc 1 1599 0
 969               		.cfi_startproc
 970               	.LVL93:
 971 01be 0F93      		push r16
 972               	.LCFI26:
 973               		.cfi_def_cfa_offset 4
 974               		.cfi_offset 16, -3
 975 01c0 1F93      		push r17
 976               	.LCFI27:
 977               		.cfi_def_cfa_offset 5
 978               		.cfi_offset 17, -4
 979 01c2 CF93      		push r28
 980               	.LCFI28:
 981               		.cfi_def_cfa_offset 6
 982               		.cfi_offset 28, -5
 983 01c4 DF93      		push r29
 984               	.LCFI29:
 985               		.cfi_def_cfa_offset 7
 986               		.cfi_offset 29, -6
 987               	/* prologue: function */
 988               	/* frame size = 0 */
 989               	/* stack size = 4 */
 990               	.L__stack_usage = 4
 991 01c6 EC01      		movw r28,r24
 992 01c8 8B01      		movw r16,r22
 993               	.LVL94:
1605:stk500boot.c  **** 	{
 994               		.loc 1 1605 0
 995 01ca 8536      		cpi r24,101
 996 01cc 9105      		cpc r25,__zero_reg__
 997 01ce 04F4      		brge .L56
1605:stk500boot.c  **** 	{
 998               		.loc 1 1605 0 is_stmt 0 discriminator 1
 999 01d0 6330      		cpi r22,3
 1000 01d2 7105      		cpc r23,__zero_reg__
 1001 01d4 04F0      		brlt .L57
 1002               	.L56:
 1003               	.LVL95:
1607:stk500boot.c  **** 		sendchar(theChar );
 1004               		.loc 1 1607 0 is_stmt 1
 1005 01d6 CE01      		movw r24,r28
 1006               	.LVL96:
 1007 01d8 64E6      		ldi r22,lo8(100)
 1008 01da 70E0      		ldi r23,0
 1009               	.LVL97:
 1010 01dc 0E94 0000 		call __divmodhi4
 1011               	.LVL98:
1608:stk500boot.c  **** 	}
 1012               		.loc 1 1608 0
 1013 01e0 80E3      		ldi r24,lo8(48)
 1014 01e2 860F      		add r24,r22
 1015 01e4 0E94 0000 		call sendchar
 1016               	.LVL99:
 1017               	.L57:
1611:stk500boot.c  **** 	{
 1018               		.loc 1 1611 0
 1019 01e8 CB30      		cpi r28,11
 1020 01ea D105      		cpc r29,__zero_reg__
 1021 01ec 04F4      		brge .L58
1611:stk500boot.c  **** 	{
 1022               		.loc 1 1611 0 is_stmt 0 discriminator 1
 1023 01ee 0230      		cpi r16,2
 1024 01f0 1105      		cpc r17,__zero_reg__
 1025 01f2 04F0      		brlt .L59
 1026               	.L58:
 1027               	.LVL100:
1613:stk500boot.c  **** 		sendchar(theChar );
 1028               		.loc 1 1613 0 is_stmt 1
 1029 01f4 CE01      		movw r24,r28
 1030 01f6 64E6      		ldi r22,lo8(100)
 1031 01f8 70E0      		ldi r23,0
 1032 01fa 0E94 0000 		call __divmodhi4
 1033 01fe 6AE0      		ldi r22,lo8(10)
 1034 0200 70E0      		ldi r23,0
 1035 0202 0E94 0000 		call __divmodhi4
1614:stk500boot.c  **** 	}
 1036               		.loc 1 1614 0
 1037 0206 80E3      		ldi r24,lo8(48)
 1038 0208 860F      		add r24,r22
 1039 020a 0E94 0000 		call sendchar
 1040               	.LVL101:
 1041               	.L59:
1616:stk500boot.c  **** 	sendchar(theChar );
 1042               		.loc 1 1616 0
 1043 020e CE01      		movw r24,r28
 1044 0210 6AE0      		ldi r22,lo8(10)
 1045 0212 70E0      		ldi r23,0
 1046 0214 0E94 0000 		call __divmodhi4
1617:stk500boot.c  **** }
 1047               		.loc 1 1617 0
 1048 0218 805D      		subi r24,lo8(-(48))
 1049               	/* epilogue start */
1618:stk500boot.c  **** 
 1050               		.loc 1 1618 0
 1051 021a DF91      		pop r29
 1052 021c CF91      		pop r28
 1053               	.LVL102:
 1054 021e 1F91      		pop r17
 1055 0220 0F91      		pop r16
 1056               	.LVL103:
1617:stk500boot.c  **** }
 1057               		.loc 1 1617 0
 1058 0222 0C94 0000 		jmp sendchar
 1059               	.LVL104:
 1060               		.cfi_endproc
 1061               	.LFE33:
 1063               		.section	.text.startup,"ax",@progbits
 1064               	.global	main
 1066               	main:
 1067               	.LFB27:
 731:stk500boot.c  **** 	address_t		address			=	0;
 1068               		.loc 1 731 0
 1069               		.cfi_startproc
 1070 0000 CF93      		push r28
 1071               	.LCFI30:
 1072               		.cfi_def_cfa_offset 4
 1073               		.cfi_offset 28, -3
 1074 0002 DF93      		push r29
 1075               	.LCFI31:
 1076               		.cfi_def_cfa_offset 5
 1077               		.cfi_offset 29, -4
 1078 0004 CDB7      		in r28,__SP_L__
 1079 0006 DEB7      		in r29,__SP_H__
 1080               	.LCFI32:
 1081               		.cfi_def_cfa_register 28
 1082 0008 C653      		subi r28,54
 1083 000a D140      		sbci r29,1
 1084               	.LCFI33:
 1085               		.cfi_def_cfa_offset 315
 1086 000c 0FB6      		in __tmp_reg__,__SREG__
 1087 000e F894      		cli
 1088 0010 DEBF      		out __SP_H__,r29
 1089 0012 0FBE      		out __SREG__,__tmp_reg__
 1090 0014 CDBF      		out __SP_L__,r28
 1091               	/* prologue: function */
 1092               	/* frame size = 310 */
 1093               	/* stack size = 312 */
 1094               	.L__stack_usage = 312
 1095               	.LVL105:
 752:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 1096               		.loc 1 752 0
 1097               	/* #APP */
 1098               	 ;  752 "stk500boot.c" 1
 1099               		.set __stack, 8703
 1100               	 ;  0 "" 2
 753:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 1101               		.loc 1 753 0
 1102               	 ;  753 "stk500boot.c" 1
 1103 0016 01E2      		ldi	16, 33
 1104               	 ;  0 "" 2
 754:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 1105               		.loc 1 754 0
 1106               	 ;  754 "stk500boot.c" 1
 1107 0018 0EBF      		out 62,16
 1108               	 ;  0 "" 2
 755:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 1109               		.loc 1 755 0
 1110               	 ;  755 "stk500boot.c" 1
 1111 001a 0FEF      		ldi	16, 255
 1112               	 ;  0 "" 2
 756:stk500boot.c  **** 
 1113               		.loc 1 756 0
 1114               	 ;  756 "stk500boot.c" 1
 1115 001c 0DBF      		out 61,16
 1116               	 ;  0 "" 2
 763:stk500boot.c  **** 
 1117               		.loc 1 763 0
 1118               	/* #NOAPP */
 1119 001e 94B7      		in r25,0x34
 1120               	.LVL106:
 765:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 1121               		.loc 1 765 0
 1122               	/* #APP */
 1123               	 ;  765 "stk500boot.c" 1
 1124 0020 F894      		cli
 1125               	 ;  0 "" 2
 766:stk500boot.c  **** 	MCUSR	=	0;
 1126               		.loc 1 766 0
 1127               	 ;  766 "stk500boot.c" 1
 1128 0022 A895      		wdr
 1129               	 ;  0 "" 2
 767:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 1130               		.loc 1 767 0
 1131               	/* #NOAPP */
 1132 0024 14BE      		out 0x34,__zero_reg__
 768:stk500boot.c  **** 	WDTCSR	=	0;
 1133               		.loc 1 768 0
 1134 0026 8091 6000 		lds r24,96
 1135 002a 8861      		ori r24,lo8(24)
 1136 002c 8093 6000 		sts 96,r24
 769:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 1137               		.loc 1 769 0
 1138 0030 1092 6000 		sts 96,__zero_reg__
 770:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 1139               		.loc 1 770 0
 1140               	/* #APP */
 1141               	 ;  770 "stk500boot.c" 1
 1142 0034 7894      		sei
 1143               	 ;  0 "" 2
 772:stk500boot.c  **** 	{
 1144               		.loc 1 772 0
 1145               	/* #NOAPP */
 1146 0036 93FF      		sbrs r25,3
 1147 0038 00C0      		rjmp .L61
 774:stk500boot.c  **** 	}
 1148               		.loc 1 774 0
 1149 003a E091 0000 		lds r30,app_start
 1150 003e F091 0000 		lds r31,app_start+1
 1151 0042 1995      		eicall
 1152               	.LVL107:
 1153               	.L61:
 796:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 1154               		.loc 1 796 0
 1155 0044 279A      		sbi 0x4,7
 798:stk500boot.c  **** 
 1156               		.loc 1 798 0
 1157 0046 2F9A      		sbi 0x5,7
 816:stk500boot.c  **** #endif
 1158               		.loc 1 816 0
 1159 0048 8091 C000 		lds r24,192
 1160 004c 8260      		ori r24,lo8(2)
 1161 004e 8093 C000 		sts 192,r24
 818:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 1162               		.loc 1 818 0
 1163 0052 80E1      		ldi r24,lo8(16)
 1164 0054 8093 C400 		sts 196,r24
 819:stk500boot.c  **** 
 1165               		.loc 1 819 0
 1166 0058 88E1      		ldi r24,lo8(24)
 1167 005a 8093 C100 		sts 193,r24
 821:stk500boot.c  **** 	
 1168               		.loc 1 821 0
 1169               	/* #APP */
 1170               	 ;  821 "stk500boot.c" 1
 1171 005e 0000      		nop
 1172               	 ;  0 "" 2
 823:stk500boot.c  **** 	corebeep_off();
 1173               		.loc 1 823 0
 1174               	/* #NOAPP */
 1175 0060 0E94 0000 		call corebeep_init
 1176               	.LVL108:
 1177               	.LBB211:
 1178               	.LBB212:
 646:stk500boot.c  **** }
 1179               		.loc 1 646 0
 1180 0064 2C98      		cbi 0x5,4
 1181               	.LBE212:
 1182               	.LBE211:
 825:stk500boot.c  **** 	beep_off();
 1183               		.loc 1 825 0
 1184 0066 0E94 0000 		call beep_init
 1185               	.LVL109:
 1186               	.LBB213:
 1187               	.LBB214:
 662:stk500boot.c  **** }
 1188               		.loc 1 662 0
 1189 006a 8091 0201 		lds r24,258
 1190 006e 8F7B      		andi r24,lo8(-65)
 1191 0070 8093 0201 		sts 258,r24
 1192               	.LBE214:
 1193               	.LBE213:
 828:stk500boot.c  **** 	if (current_boot_count == 0xFF) {
 1194               		.loc 1 828 0
 1195 0074 84E0      		ldi r24,lo8(4)
 1196 0076 90E0      		ldi r25,0
 1197 0078 0E94 0000 		call eeprom_read_byte
 1198               	.LVL110:
 1199 007c 8093 0000 		sts current_boot_count,r24
 829:stk500boot.c  **** 		current_boot_count = 0;
 1200               		.loc 1 829 0
 1201 0080 8F3F      		cpi r24,lo8(-1)
 1202 0082 01F4      		brne .L62
 830:stk500boot.c  **** 		eeprom_write_byte(EEPROM_COUNTER_ADDR, 0);
 1203               		.loc 1 830 0
 1204 0084 1092 0000 		sts current_boot_count,__zero_reg__
 831:stk500boot.c  **** 	}
 1205               		.loc 1 831 0
 1206 0088 60E0      		ldi r22,0
 1207 008a 84E0      		ldi r24,lo8(4)
 1208 008c 90E0      		ldi r25,0
 1209 008e 0E94 0000 		call eeprom_write_byte
 1210               	.LVL111:
 1211               	.L62:
 834:stk500boot.c  **** 	{
 1212               		.loc 1 834 0
 1213 0092 8091 0000 		lds r24,current_boot_count
 1214 0096 8530      		cpi r24,lo8(5)
 1215 0098 00F0      		brlo .L63
 836:stk500boot.c  **** 	}
 1216               		.loc 1 836 0
 1217 009a 81E0      		ldi r24,lo8(1)
 1218 009c 8093 0000 		sts gInterceptAppJump,r24
 1219               	.L63:
 731:stk500boot.c  **** 	address_t		address			=	0;
 1220               		.loc 1 731 0
 1221 00a0 10E0      		ldi r17,0
 1222 00a2 00E0      		ldi r16,0
 1223 00a4 C12C      		mov r12,__zero_reg__
 1224 00a6 D12C      		mov r13,__zero_reg__
 1225 00a8 7601      		movw r14,r12
 867:stk500boot.c  **** 			{
 1226               		.loc 1 867 0
 1227 00aa F7EC      		ldi r31,lo8(-57)
 1228 00ac 8F2E      		mov r8,r31
 1229 00ae FBE1      		ldi r31,lo8(27)
 1230 00b0 9F2E      		mov r9,r31
 1231 00b2 A12C      		mov r10,__zero_reg__
 1232 00b4 B12C      		mov r11,__zero_reg__
 1233 00b6 00C0      		rjmp .L66
 1234               	.LVL112:
 1235               	.L68:
 1236               	.LBB215:
 1237               	.LBB216:
 1238               		.loc 2 187 0
 1239 00b8 25E0      		ldi r18,lo8(5)
 1240 00ba 2A95      	1:	dec r18
 1241 00bc 01F4      		brne 1b
 1242 00be 0000      		nop
 1243               	.LVL113:
 1244               	.LBE216:
 1245               	.LBE215:
 861:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 1246               		.loc 1 861 0
 1247 00c0 3FEF      		ldi r19,-1
 1248 00c2 C31A      		sub r12,r19
 1249 00c4 D30A      		sbc r13,r19
 1250 00c6 E30A      		sbc r14,r19
 1251 00c8 F30A      		sbc r15,r19
 1252               	.LVL114:
 862:stk500boot.c  **** 			{
 1253               		.loc 1 862 0
 1254 00ca 91E0      		ldi r25,lo8(1)
 1255 00cc 80E0      		ldi r24,0
 1256 00ce 41E2      		ldi r20,33
 1257 00d0 C416      		cp r12,r20
 1258 00d2 4EE4      		ldi r20,78
 1259 00d4 D406      		cpc r13,r20
 1260 00d6 E104      		cpc r14,__zero_reg__
 1261 00d8 F104      		cpc r15,__zero_reg__
 1262 00da 00F4      		brsh .L64
 1263 00dc 90E0      		ldi r25,0
 1264               	.L64:
 864:stk500boot.c  **** 			}
 1265               		.loc 1 864 0
 1266 00de 092F      		mov r16,r25
 1267               	.LVL115:
 1268 00e0 182F      		mov r17,r24
 867:stk500boot.c  **** 			{
 1269               		.loc 1 867 0
 1270 00e2 C701      		movw r24,r14
 1271 00e4 B601      		movw r22,r12
 1272 00e6 A501      		movw r20,r10
 1273 00e8 9401      		movw r18,r8
 1274 00ea 0E94 0000 		call __udivmodsi4
 1275 00ee 672B      		or r22,r23
 1276 00f0 682B      		or r22,r24
 1277 00f2 692B      		or r22,r25
 1278 00f4 01F4      		brne .L66
 870:stk500boot.c  **** 			}
 1279               		.loc 1 870 0
 1280 00f6 85B1      		in r24,0x5
 1281 00f8 8058      		subi r24,lo8(-(-128))
 1282 00fa 85B9      		out 0x5,r24
 1283               	.LVL116:
 1284               	.L66:
 1285               	.LBB217:
 1286               	.LBB218:
 476:stk500boot.c  **** }
 1287               		.loc 1 476 0
 1288 00fc 8091 C000 		lds r24,192
 1289               	.LBE218:
 1290               	.LBE217:
 858:stk500boot.c  **** 		{
 1291               		.loc 1 858 0
 1292 0100 87FD      		sbrc r24,7
 1293 0102 00C0      		rjmp .L67
 858:stk500boot.c  **** 		{
 1294               		.loc 1 858 0 is_stmt 0 discriminator 1
 1295 0104 0115      		cp r16,__zero_reg__
 1296 0106 1105      		cpc r17,__zero_reg__
 1297 0108 01F0      		breq .L68
 1298               	.L67:
 1299               	.LVL117:
 878:stk500boot.c  **** 	{
 1300               		.loc 1 878 0 is_stmt 1
 1301 010a 012B      		or r16,r17
 1302 010c 01F0      		breq .+2
 1303 010e 00C0      		rjmp .L70
 748:stk500boot.c  **** #endif
 1304               		.loc 1 748 0
 1305 0110 C55D      		subi r28,lo8(-299)
 1306 0112 DE4F      		sbci r29,hi8(-299)
 1307 0114 1982      		std Y+1,__zero_reg__
 1308 0116 1882      		st Y,__zero_reg__
 1309 0118 CB52      		subi r28,lo8(299)
 1310 011a D140      		sbci r29,hi8(299)
 747:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 1311               		.loc 1 747 0
 1312 011c F12C      		mov r15,__zero_reg__
 1313 011e E12C      		mov r14,__zero_reg__
 735:stk500boot.c  **** 	unsigned char	checksum		=	0;
 1314               		.loc 1 735 0
 1315 0120 C75D      		subi r28,lo8(-297)
 1316 0122 DE4F      		sbci r29,hi8(-297)
 1317 0124 1982      		std Y+1,__zero_reg__
 1318 0126 1882      		st Y,__zero_reg__
 1319 0128 C952      		subi r28,lo8(297)
 1320 012a D140      		sbci r29,hi8(297)
 733:stk500boot.c  **** 	unsigned char	msgParseState;
 1321               		.loc 1 733 0
 1322 012c CB5D      		subi r28,lo8(-293)
 1323 012e DE4F      		sbci r29,hi8(-293)
 1324 0130 1882      		st Y,__zero_reg__
 1325 0132 1982      		std Y+1,__zero_reg__
 1326 0134 1A82      		std Y+2,__zero_reg__
 1327 0136 1B82      		std Y+3,__zero_reg__
 1328 0138 C552      		subi r28,lo8(293)
 1329 013a D140      		sbci r29,hi8(293)
 732:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 1330               		.loc 1 732 0
 1331 013c 212C      		mov r2,__zero_reg__
 1332 013e 312C      		mov r3,__zero_reg__
 1333 0140 2101      		movw r4,r2
 1334 0142 41E0      		ldi r20,lo8(1)
 1335 0144 50E0      		ldi r21,0
 737:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 1336               		.loc 1 737 0
 1337 0146 CC5D      		subi r28,lo8(-292)
 1338 0148 DE4F      		sbci r29,hi8(-292)
 1339 014a 1882      		st Y,__zero_reg__
 1340 014c C452      		subi r28,lo8(292)
 1341 014e D140      		sbci r29,hi8(292)
 736:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 1342               		.loc 1 736 0
 1343 0150 C12C      		mov r12,__zero_reg__
 977:stk500boot.c  **** 						checksum		^=	c;
 1344               		.loc 1 977 0
 1345 0152 FE01      		movw r30,r28
 1346 0154 3196      		adiw r30,1
 1347 0156 C25E      		subi r28,lo8(-286)
 1348 0158 DE4F      		sbci r29,hi8(-286)
 1349 015a F983      		std Y+1,r31
 1350 015c E883      		st Y,r30
 1351 015e CE51      		subi r28,lo8(286)
 1352 0160 D140      		sbci r29,hi8(286)
 1353               	.LVL118:
 1354               	.L69:
 731:stk500boot.c  **** 	address_t		address			=	0;
 1355               		.loc 1 731 0
 1356 0162 30E0      		ldi r19,0
 1357 0164 20E0      		ldi r18,0
 1358 0166 80E0      		ldi r24,0
 1359 0168 00C0      		rjmp .L217
 1360               	.LVL119:
 1361               	.L75:
 1362 016a 4150      		subi r20,1
 1363 016c 5109      		sbc r21,__zero_reg__
 1364 016e 6109      		sbc r22,__zero_reg__
 1365 0170 7109      		sbc r23,__zero_reg__
 1366               	.LVL120:
 1367               	.LBB219:
 1368               	.LBB220:
 503:stk500boot.c  **** 		{
 1369               		.loc 1 503 0
 1370 0172 01F4      		brne .L73
 1371               	.LVL121:
 1372               	.LBB221:
 1373               	.LBB222:
 507:stk500boot.c  **** 		#else
 1374               		.loc 1 507 0
 1375               	/* #APP */
 1376               	 ;  507 "stk500boot.c" 1
 1377 0174 6BBF      		out 59, r22
 1378 0176 FA01      		movw r30, r20
 1379 0178 4791      		elpm r20, Z+
 1380 017a 5691      		elpm r21, Z
 1381               		
 1382               	 ;  0 "" 2
 1383               	.LVL122:
 1384               	/* #NOAPP */
 1385               	.LBE222:
 511:stk500boot.c  **** 			{
 1386               		.loc 1 511 0
 1387 017c 4F3F      		cpi r20,-1
 1388 017e 5F4F      		sbci r21,-1
 1389 0180 01F0      		breq .L74
 513:stk500boot.c  **** 						"clr	r30		\n\t"
 1390               		.loc 1 513 0
 1391               	/* #APP */
 1392               	 ;  513 "stk500boot.c" 1
 1393 0182 EE27      		clr	r30		
 1394 0184 FF27      		clr	r31		
 1395 0186 0994      		ijmp	
 1396               		
 1397               	 ;  0 "" 2
 1398               	.LVL123:
 1399               	/* #NOAPP */
 1400               	.L74:
 1401               	.LBE221:
 1402               	.LBE220:
 1403               	.LBE219:
 731:stk500boot.c  **** 	address_t		address			=	0;
 1404               		.loc 1 731 0
 1405 0188 41E0      		ldi r20,lo8(1)
 1406 018a 52E1      		ldi r21,lo8(18)
 1407 018c 6AE7      		ldi r22,lo8(122)
 1408 018e 70E0      		ldi r23,0
 1409               	.L73:
 1410               	.LVL124:
 1411               	.LBB225:
 1412               	.LBB223:
 499:stk500boot.c  **** 	{
 1413               		.loc 1 499 0
 1414 0190 9091 C000 		lds r25,192
 1415 0194 97FF      		sbrs r25,7
 1416 0196 00C0      		rjmp .L75
 1417 0198 00C0      		rjmp .L295
 1418               	.LVL125:
 1419               	.L86:
 1420               	.LBE223:
 1421               	.LBE225:
 1422               	.LBB226:
 1423               	.LBB227:
1986:stk500boot.c  **** 
1987:stk500boot.c  **** //************************************************************************
1988:stk500boot.c  **** static void	ListAvailablePorts(void)
1989:stk500boot.c  **** {
1990:stk500boot.c  **** 
1991:stk500boot.c  **** #ifdef DDRA
1992:stk500boot.c  **** 	PrintAvailablePort('A');
1993:stk500boot.c  **** #endif
1994:stk500boot.c  **** 
1995:stk500boot.c  **** #ifdef DDRB
1996:stk500boot.c  **** 	PrintAvailablePort('B');
1997:stk500boot.c  **** #endif
1998:stk500boot.c  **** 
1999:stk500boot.c  **** #ifdef DDRC
2000:stk500boot.c  **** 	PrintAvailablePort('C');
2001:stk500boot.c  **** #endif
2002:stk500boot.c  **** 
2003:stk500boot.c  **** #ifdef DDRD
2004:stk500boot.c  **** 	PrintAvailablePort('D');
2005:stk500boot.c  **** #endif
2006:stk500boot.c  **** 
2007:stk500boot.c  **** #ifdef DDRE
2008:stk500boot.c  **** 	PrintAvailablePort('E');
2009:stk500boot.c  **** #endif
2010:stk500boot.c  **** 
2011:stk500boot.c  **** #ifdef DDRF
2012:stk500boot.c  **** 	PrintAvailablePort('F');
2013:stk500boot.c  **** #endif
2014:stk500boot.c  **** 
2015:stk500boot.c  **** #ifdef DDRG
2016:stk500boot.c  **** 	PrintAvailablePort('G');
2017:stk500boot.c  **** #endif
2018:stk500boot.c  **** 
2019:stk500boot.c  **** #ifdef DDRH
2020:stk500boot.c  **** 	PrintAvailablePort('H');
2021:stk500boot.c  **** #endif
2022:stk500boot.c  **** 
2023:stk500boot.c  **** #ifdef DDRI
2024:stk500boot.c  **** 	PrintAvailablePort('I');
2025:stk500boot.c  **** #endif
2026:stk500boot.c  **** 
2027:stk500boot.c  **** #ifdef DDRJ
2028:stk500boot.c  **** 	PrintAvailablePort('J');
2029:stk500boot.c  **** #endif
2030:stk500boot.c  **** 
2031:stk500boot.c  **** #ifdef DDRK
2032:stk500boot.c  **** 	PrintAvailablePort('K');
2033:stk500boot.c  **** #endif
2034:stk500boot.c  **** 
2035:stk500boot.c  **** #ifdef DDRL
2036:stk500boot.c  **** 	PrintAvailablePort('L');
2037:stk500boot.c  **** #endif
2038:stk500boot.c  **** 
2039:stk500boot.c  **** }
2040:stk500boot.c  **** 
2041:stk500boot.c  **** //************************************************************************
2042:stk500boot.c  **** static void	AVR_PortOutput(void)
2043:stk500boot.c  **** {
2044:stk500boot.c  **** char	portLetter;
2045:stk500boot.c  **** char	getCharFlag;
2046:stk500boot.c  **** 
2047:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);
2048:stk500boot.c  **** 
2049:stk500boot.c  **** 	portLetter	=	recchar();
2050:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
2051:stk500boot.c  **** 	sendchar(portLetter);
2052:stk500boot.c  **** 	PrintNewLine();
2053:stk500boot.c  **** 
2054:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
2055:stk500boot.c  **** 	{
2056:stk500boot.c  **** 		getCharFlag	=	true;
2057:stk500boot.c  **** 		switch(portLetter)
2058:stk500boot.c  **** 		{
2059:stk500boot.c  **** 		#ifdef DDRA
2060:stk500boot.c  **** 			case 'A':
2061:stk500boot.c  **** 				DDRA	=	0xff;
2062:stk500boot.c  **** 				while (!Serial_Available())
2063:stk500boot.c  **** 				{
2064:stk500boot.c  **** 					PORTA	^=	0xff;
2065:stk500boot.c  **** 					delay_ms(200);
2066:stk500boot.c  **** 				}
2067:stk500boot.c  **** 				PORTA	=	0;
2068:stk500boot.c  **** 				break;
2069:stk500boot.c  **** 		#endif
2070:stk500boot.c  **** 
2071:stk500boot.c  **** 		#ifdef DDRB
2072:stk500boot.c  **** 			case 'B':
2073:stk500boot.c  **** 				DDRB	=	0xff;
2074:stk500boot.c  **** 				while (!Serial_Available())
2075:stk500boot.c  **** 				{
2076:stk500boot.c  **** 					PORTB	^=	0xff;
2077:stk500boot.c  **** 					delay_ms(200);
2078:stk500boot.c  **** 				}
2079:stk500boot.c  **** 				PORTB	=	0;
2080:stk500boot.c  **** 				break;
2081:stk500boot.c  **** 		#endif
2082:stk500boot.c  **** 
2083:stk500boot.c  **** 		#ifdef DDRC
2084:stk500boot.c  **** 			case 'C':
2085:stk500boot.c  **** 				DDRC	=	0xff;
2086:stk500boot.c  **** 				while (!Serial_Available())
2087:stk500boot.c  **** 				{
2088:stk500boot.c  **** 					PORTC	^=	0xff;
2089:stk500boot.c  **** 					delay_ms(200);
2090:stk500boot.c  **** 				}
2091:stk500boot.c  **** 				PORTC	=	0;
2092:stk500boot.c  **** 				break;
2093:stk500boot.c  **** 		#endif
2094:stk500boot.c  **** 
2095:stk500boot.c  **** 		#ifdef DDRD
2096:stk500boot.c  **** 			case 'D':
2097:stk500boot.c  **** 				DDRD	=	0xff;
2098:stk500boot.c  **** 				while (!Serial_Available())
2099:stk500boot.c  **** 				{
2100:stk500boot.c  **** 					PORTD	^=	0xff;
2101:stk500boot.c  **** 					delay_ms(200);
2102:stk500boot.c  **** 				}
2103:stk500boot.c  **** 				PORTD	=	0;
2104:stk500boot.c  **** 				break;
2105:stk500boot.c  **** 		#endif
2106:stk500boot.c  **** 
2107:stk500boot.c  **** 		#ifdef DDRE
2108:stk500boot.c  **** 			case 'E':
2109:stk500boot.c  **** 				DDRE	=	0xff;
2110:stk500boot.c  **** 				while (!Serial_Available())
2111:stk500boot.c  **** 				{
2112:stk500boot.c  **** 					PORTE	^=	0xff;
2113:stk500boot.c  **** 					delay_ms(200);
2114:stk500boot.c  **** 				}
2115:stk500boot.c  **** 				PORTE	=	0;
2116:stk500boot.c  **** 				break;
2117:stk500boot.c  **** 		#endif
2118:stk500boot.c  **** 
2119:stk500boot.c  **** 		#ifdef DDRF
2120:stk500boot.c  **** 			case 'F':
2121:stk500boot.c  **** 				DDRF	=	0xff;
2122:stk500boot.c  **** 				while (!Serial_Available())
2123:stk500boot.c  **** 				{
2124:stk500boot.c  **** 					PORTF	^=	0xff;
2125:stk500boot.c  **** 					delay_ms(200);
2126:stk500boot.c  **** 				}
2127:stk500boot.c  **** 				PORTF	=	0;
2128:stk500boot.c  **** 				break;
2129:stk500boot.c  **** 		#endif
2130:stk500boot.c  **** 
2131:stk500boot.c  **** 		#ifdef DDRG
2132:stk500boot.c  **** 			case 'G':
2133:stk500boot.c  **** 				DDRG	=	0xff;
2134:stk500boot.c  **** 				while (!Serial_Available())
2135:stk500boot.c  **** 				{
2136:stk500boot.c  **** 					PORTG	^=	0xff;
2137:stk500boot.c  **** 					delay_ms(200);
2138:stk500boot.c  **** 				}
2139:stk500boot.c  **** 				PORTG	=	0;
2140:stk500boot.c  **** 				break;
2141:stk500boot.c  **** 		#endif
2142:stk500boot.c  **** 
2143:stk500boot.c  **** 		#ifdef DDRH
2144:stk500boot.c  **** 			case 'H':
2145:stk500boot.c  **** 				DDRH	=	0xff;
2146:stk500boot.c  **** 				while (!Serial_Available())
2147:stk500boot.c  **** 				{
2148:stk500boot.c  **** 					PORTH	^=	0xff;
2149:stk500boot.c  **** 					delay_ms(200);
2150:stk500boot.c  **** 				}
2151:stk500boot.c  **** 				PORTH	=	0;
2152:stk500boot.c  **** 				break;
2153:stk500boot.c  **** 		#endif
2154:stk500boot.c  **** 
2155:stk500boot.c  **** 		#ifdef DDRI
2156:stk500boot.c  **** 			case 'I':
2157:stk500boot.c  **** 				DDRI	=	0xff;
2158:stk500boot.c  **** 				while (!Serial_Available())
2159:stk500boot.c  **** 				{
2160:stk500boot.c  **** 					PORTI	^=	0xff;
2161:stk500boot.c  **** 					delay_ms(200);
2162:stk500boot.c  **** 				}
2163:stk500boot.c  **** 				PORTI	=	0;
2164:stk500boot.c  **** 				break;
2165:stk500boot.c  **** 		#endif
2166:stk500boot.c  **** 
2167:stk500boot.c  **** 		#ifdef DDRJ
2168:stk500boot.c  **** 			case 'J':
2169:stk500boot.c  **** 				DDRJ	=	0xff;
2170:stk500boot.c  **** 				while (!Serial_Available())
2171:stk500boot.c  **** 				{
2172:stk500boot.c  **** 					PORTJ	^=	0xff;
2173:stk500boot.c  **** 					delay_ms(200);
2174:stk500boot.c  **** 				}
2175:stk500boot.c  **** 				PORTJ	=	0;
2176:stk500boot.c  **** 				break;
2177:stk500boot.c  **** 		#endif
2178:stk500boot.c  **** 
2179:stk500boot.c  **** 		#ifdef DDRK
2180:stk500boot.c  **** 			case 'K':
2181:stk500boot.c  **** 				DDRK	=	0xff;
2182:stk500boot.c  **** 				while (!Serial_Available())
2183:stk500boot.c  **** 				{
2184:stk500boot.c  **** 					PORTK	^=	0xff;
2185:stk500boot.c  **** 					delay_ms(200);
2186:stk500boot.c  **** 				}
2187:stk500boot.c  **** 				PORTK	=	0;
2188:stk500boot.c  **** 				break;
2189:stk500boot.c  **** 		#endif
2190:stk500boot.c  **** 
2191:stk500boot.c  **** 		#ifdef DDRL
2192:stk500boot.c  **** 			case 'L':
2193:stk500boot.c  **** 				DDRL	=	0xff;
2194:stk500boot.c  **** 				while (!Serial_Available())
2195:stk500boot.c  **** 				{
2196:stk500boot.c  **** 					PORTL	^=	0xff;
2197:stk500boot.c  **** 					delay_ms(200);
2198:stk500boot.c  **** 				}
2199:stk500boot.c  **** 				PORTL	=	0;
2200:stk500boot.c  **** 				break;
2201:stk500boot.c  **** 		#endif
2202:stk500boot.c  **** 
2203:stk500boot.c  **** 			default:
2204:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);
2205:stk500boot.c  **** 				getCharFlag	=	false;
2206:stk500boot.c  **** 				break;
2207:stk500boot.c  **** 		}
2208:stk500boot.c  **** 		if (getCharFlag)
2209:stk500boot.c  **** 		{
2210:stk500boot.c  **** 			recchar();
2211:stk500boot.c  **** 		}
2212:stk500boot.c  **** 	}
2213:stk500boot.c  **** 	else
2214:stk500boot.c  **** 	{
2215:stk500boot.c  **** 		PrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);
2216:stk500boot.c  **** 	}
2217:stk500boot.c  **** }
2218:stk500boot.c  **** 
2219:stk500boot.c  **** 
2220:stk500boot.c  **** //*******************************************************************
2221:stk500boot.c  **** static void PrintHelp(void)
2222:stk500boot.c  **** {
2223:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 0);
2224:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
2225:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
2226:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
2227:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
2228:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
2229:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
2230:stk500boot.c  **** 
2231:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 0);
2232:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
2233:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
2234:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
2235:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
2236:stk500boot.c  **** }
2237:stk500boot.c  **** 
2238:stk500boot.c  **** //************************************************************************
2239:stk500boot.c  **** static void	RunMonitor(void)
2240:stk500boot.c  **** {
2241:stk500boot.c  **** char			keepGoing;
2242:stk500boot.c  **** unsigned char	theChar;
2243:stk500boot.c  **** int				ii, jj;
2244:stk500boot.c  **** 
2245:stk500boot.c  **** 	for (ii=0; ii<5; ii++)
2246:stk500boot.c  **** 	{
2247:stk500boot.c  **** 		for (jj=0; jj<25; jj++)
2248:stk500boot.c  **** 		{
2249:stk500boot.c  **** 			sendchar('!');
2250:stk500boot.c  **** 		}
2251:stk500boot.c  **** 		PrintNewLine();
2252:stk500boot.c  **** 	}
2253:stk500boot.c  **** 
2254:stk500boot.c  **** 	gRamIndex			=	0;
2255:stk500boot.c  **** 	gFlashIndex			=	0;
2256:stk500boot.c  **** 	gEepromIndex		=	0;
2257:stk500boot.c  **** 
2258:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
2259:stk500boot.c  **** 
2260:stk500boot.c  **** 	keepGoing	=	1;
2261:stk500boot.c  **** 	while (keepGoing)
2262:stk500boot.c  **** 	{
2263:stk500boot.c  **** 		PrintFromPROGMEM(gTextMsg_Prompt, 0);
2264:stk500boot.c  **** 		theChar	=	recchar();
2265:stk500boot.c  **** 		if (theChar >= 0x60)
2266:stk500boot.c  **** 		{
2267:stk500boot.c  **** 			theChar	=	theChar & 0x5F;
2268:stk500boot.c  **** 		}
2269:stk500boot.c  **** 
2270:stk500boot.c  **** 		if (theChar >= 0x20)
2271:stk500boot.c  **** 		{
2272:stk500boot.c  **** 			sendchar(theChar);
2273:stk500boot.c  **** 			sendchar(0x20);
2274:stk500boot.c  **** 		}
2275:stk500boot.c  **** 
2276:stk500boot.c  **** 		switch(theChar)
 1424               		.loc 1 2276 0
 1425 019a 1234      		cpi r17,lo8(66)
 1426 019c 01F4      		brne .+2
 1427 019e 00C0      		rjmp .L89
 1428 01a0 1534      		cpi r17,lo8(69)
 1429 01a2 01F0      		breq .+2
 1430 01a4 00C0      		rjmp .L82
2277:stk500boot.c  **** 		{
2278:stk500boot.c  **** 			case '0':
2279:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 2);
2280:stk500boot.c  **** 				gFlashIndex		=	0;
2281:stk500boot.c  **** 				gRamIndex		=	0;
2282:stk500boot.c  **** 				gEepromIndex	=	0;
2283:stk500boot.c  **** 				break;
2284:stk500boot.c  **** 
2285:stk500boot.c  **** 			case '?':
2286:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 2);
2287:stk500boot.c  **** 				PrintCPUstats();
2288:stk500boot.c  **** 				break;
2289:stk500boot.c  **** 
2290:stk500boot.c  **** 			case '@':
2291:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 2);
2292:stk500boot.c  **** 				EEPROMtest();
2293:stk500boot.c  **** 				break;
2294:stk500boot.c  **** 
2295:stk500boot.c  **** 			case 'B':
2296:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 2);
2297:stk500boot.c  **** 				BlinkLED();
2298:stk500boot.c  **** 				break;
2299:stk500boot.c  **** 
2300:stk500boot.c  **** 			case 'E':
2301:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 2);
 1431               		.loc 1 2301 0
 1432 01a6 62E0      		ldi r22,lo8(2)
 1433 01a8 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1434 01aa 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1435 01ac 0E94 0000 		call PrintFromPROGMEMln
 1436               	.LVL126:
2302:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
 1437               		.loc 1 2302 0
 1438 01b0 4091 0000 		lds r20,gEepromIndex
 1439 01b4 5091 0000 		lds r21,gEepromIndex+1
 1440 01b8 6091 0000 		lds r22,gEepromIndex+2
 1441 01bc 7091 0000 		lds r23,gEepromIndex+3
 1442 01c0 81E0      		ldi r24,lo8(1)
 1443 01c2 0E94 0000 		call DumpHex.constprop.1
 1444               	.LVL127:
2303:stk500boot.c  **** 				gEepromIndex	+=	256;
 1445               		.loc 1 2303 0
 1446 01c6 8091 0000 		lds r24,gEepromIndex
 1447 01ca 9091 0000 		lds r25,gEepromIndex+1
 1448 01ce A091 0000 		lds r26,gEepromIndex+2
 1449 01d2 B091 0000 		lds r27,gEepromIndex+3
 1450 01d6 9F5F      		subi r25,-1
 1451 01d8 AF4F      		sbci r26,-1
 1452 01da BF4F      		sbci r27,-1
 1453 01dc 8093 0000 		sts gEepromIndex,r24
 1454 01e0 9093 0000 		sts gEepromIndex+1,r25
 1455 01e4 A093 0000 		sts gEepromIndex+2,r26
 1456 01e8 B093 0000 		sts gEepromIndex+3,r27
2304:stk500boot.c  **** 				if (gEepromIndex > E2END)
 1457               		.loc 1 2304 0
 1458 01ec 8115      		cp r24,__zero_reg__
 1459 01ee 9041      		sbci r25,16
 1460 01f0 A105      		cpc r26,__zero_reg__
 1461 01f2 B105      		cpc r27,__zero_reg__
 1462 01f4 00F4      		brsh .+2
 1463 01f6 00C0      		rjmp .L81
 1464 01f8 00C0      		rjmp .L298
 1465               	.L84:
2276:stk500boot.c  **** 		{
 1466               		.loc 1 2276 0
 1467 01fa 1135      		cpi r17,lo8(81)
 1468 01fc 01F4      		brne .+2
 1469 01fe 00C0      		rjmp .L91
 1470 0200 00F4      		brsh .L92
 1471 0202 1834      		cpi r17,lo8(72)
 1472 0204 01F4      		brne .+2
 1473 0206 00C0      		rjmp .L93
 1474 0208 1C34      		cpi r17,lo8(76)
 1475 020a 01F0      		breq .+2
 1476 020c 00C0      		rjmp .L82
2305:stk500boot.c  **** 				{
2306:stk500boot.c  **** 					gEepromIndex	=	0;
2307:stk500boot.c  **** 				}
2308:stk500boot.c  **** 				break;
2309:stk500boot.c  **** 		
2310:stk500boot.c  **** 			case 'F':
2311:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 2);
2312:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
2313:stk500boot.c  **** 				gFlashIndex	+=	256;
2314:stk500boot.c  **** 				break;
2315:stk500boot.c  **** 
2316:stk500boot.c  **** 			case 'H':
2317:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 2);
2318:stk500boot.c  **** 				PrintHelp();
2319:stk500boot.c  **** 				break;
2320:stk500boot.c  **** 
2321:stk500boot.c  **** 			case 'L':
2322:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 2);
 1477               		.loc 1 2322 0
 1478 020e 62E0      		ldi r22,lo8(2)
 1479 0210 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1480 0212 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1481 0214 0E94 0000 		call PrintFromPROGMEMln
 1482               	.LVL128:
 1483               	.LBB228:
 1484               	.LBB229:
1992:stk500boot.c  **** #endif
 1485               		.loc 1 1992 0
 1486 0218 81E4      		ldi r24,lo8(65)
 1487 021a 0E94 0000 		call PrintAvailablePort
 1488               	.LVL129:
1996:stk500boot.c  **** #endif
 1489               		.loc 1 1996 0
 1490 021e 82E4      		ldi r24,lo8(66)
 1491 0220 0E94 0000 		call PrintAvailablePort
 1492               	.LVL130:
2000:stk500boot.c  **** #endif
 1493               		.loc 1 2000 0
 1494 0224 83E4      		ldi r24,lo8(67)
 1495 0226 0E94 0000 		call PrintAvailablePort
 1496               	.LVL131:
2004:stk500boot.c  **** #endif
 1497               		.loc 1 2004 0
 1498 022a 84E4      		ldi r24,lo8(68)
 1499 022c 0E94 0000 		call PrintAvailablePort
 1500               	.LVL132:
2008:stk500boot.c  **** #endif
 1501               		.loc 1 2008 0
 1502 0230 85E4      		ldi r24,lo8(69)
 1503 0232 0E94 0000 		call PrintAvailablePort
 1504               	.LVL133:
2012:stk500boot.c  **** #endif
 1505               		.loc 1 2012 0
 1506 0236 86E4      		ldi r24,lo8(70)
 1507 0238 0E94 0000 		call PrintAvailablePort
 1508               	.LVL134:
2016:stk500boot.c  **** #endif
 1509               		.loc 1 2016 0
 1510 023c 87E4      		ldi r24,lo8(71)
 1511 023e 0E94 0000 		call PrintAvailablePort
 1512               	.LVL135:
2020:stk500boot.c  **** #endif
 1513               		.loc 1 2020 0
 1514 0242 88E4      		ldi r24,lo8(72)
 1515 0244 0E94 0000 		call PrintAvailablePort
 1516               	.LVL136:
2028:stk500boot.c  **** #endif
 1517               		.loc 1 2028 0
 1518 0248 8AE4      		ldi r24,lo8(74)
 1519 024a 0E94 0000 		call PrintAvailablePort
 1520               	.LVL137:
2032:stk500boot.c  **** #endif
 1521               		.loc 1 2032 0
 1522 024e 8BE4      		ldi r24,lo8(75)
 1523 0250 0E94 0000 		call PrintAvailablePort
 1524               	.LVL138:
2036:stk500boot.c  **** #endif
 1525               		.loc 1 2036 0
 1526 0254 8CE4      		ldi r24,lo8(76)
 1527 0256 0E94 0000 		call PrintAvailablePort
 1528               	.LVL139:
 1529 025a 00C0      		rjmp .L81
 1530               	.L92:
 1531               	.LBE229:
 1532               	.LBE228:
2276:stk500boot.c  **** 		{
 1533               		.loc 1 2276 0
 1534 025c 1635      		cpi r17,lo8(86)
 1535 025e 01F4      		brne .+2
 1536 0260 00C0      		rjmp .L95
 1537 0262 1935      		cpi r17,lo8(89)
 1538 0264 01F4      		brne .+2
 1539 0266 00C0      		rjmp .L96
 1540 0268 1235      		cpi r17,lo8(82)
 1541 026a 01F0      		breq .+2
 1542 026c 00C0      		rjmp .L82
2323:stk500boot.c  **** 				ListAvailablePorts();
2324:stk500boot.c  **** 				break;
2325:stk500boot.c  **** 
2326:stk500boot.c  **** 			case 'Q':
2327:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 2);
2328:stk500boot.c  **** 				keepGoing	=	false;
2329:stk500boot.c  **** 				break;
2330:stk500boot.c  **** 
2331:stk500boot.c  **** 			case 'R':
2332:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 2);
 1543               		.loc 1 2332 0
 1544 026e 62E0      		ldi r22,lo8(2)
 1545 0270 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1546 0272 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1547 0274 0E94 0000 		call PrintFromPROGMEMln
 1548               	.LVL140:
2333:stk500boot.c  **** 				DumpHex(kDUMP_RAM, gRamIndex, 16);
 1549               		.loc 1 2333 0
 1550 0278 4091 0000 		lds r20,gRamIndex
 1551 027c 5091 0000 		lds r21,gRamIndex+1
 1552 0280 6091 0000 		lds r22,gRamIndex+2
 1553 0284 7091 0000 		lds r23,gRamIndex+3
 1554 0288 82E0      		ldi r24,lo8(2)
 1555 028a 0E94 0000 		call DumpHex.constprop.1
 1556               	.LVL141:
2334:stk500boot.c  **** 				gRamIndex	+=	256;
 1557               		.loc 1 2334 0
 1558 028e 8091 0000 		lds r24,gRamIndex
 1559 0292 9091 0000 		lds r25,gRamIndex+1
 1560 0296 A091 0000 		lds r26,gRamIndex+2
 1561 029a B091 0000 		lds r27,gRamIndex+3
 1562 029e 9F5F      		subi r25,-1
 1563 02a0 AF4F      		sbci r26,-1
 1564 02a2 BF4F      		sbci r27,-1
 1565 02a4 8093 0000 		sts gRamIndex,r24
 1566 02a8 9093 0000 		sts gRamIndex+1,r25
 1567 02ac A093 0000 		sts gRamIndex+2,r26
 1568 02b0 B093 0000 		sts gRamIndex+3,r27
 1569 02b4 00C0      		rjmp .L81
 1570               	.L87:
2279:stk500boot.c  **** 				gFlashIndex		=	0;
 1571               		.loc 1 2279 0
 1572 02b6 62E0      		ldi r22,lo8(2)
 1573 02b8 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1574 02ba 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1575 02bc 0E94 0000 		call PrintFromPROGMEMln
 1576               	.LVL142:
2280:stk500boot.c  **** 				gRamIndex		=	0;
 1577               		.loc 1 2280 0
 1578 02c0 1092 0000 		sts gFlashIndex,__zero_reg__
 1579 02c4 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1580 02c8 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1581 02cc 1092 0000 		sts gFlashIndex+3,__zero_reg__
2281:stk500boot.c  **** 				gEepromIndex	=	0;
 1582               		.loc 1 2281 0
 1583 02d0 1092 0000 		sts gRamIndex,__zero_reg__
 1584 02d4 1092 0000 		sts gRamIndex+1,__zero_reg__
 1585 02d8 1092 0000 		sts gRamIndex+2,__zero_reg__
 1586 02dc 1092 0000 		sts gRamIndex+3,__zero_reg__
 1587               	.LVL143:
 1588               	.L298:
 1589               	.LBB230:
 1590               	.LBB231:
1842:stk500boot.c  **** 
 1591               		.loc 1 1842 0
 1592 02e0 1092 0000 		sts gEepromIndex,__zero_reg__
 1593 02e4 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1594 02e8 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1595 02ec 1092 0000 		sts gEepromIndex+3,__zero_reg__
 1596 02f0 00C0      		rjmp .L81
 1597               	.LVL144:
 1598               	.L88:
 1599               	.LBE231:
 1600               	.LBE230:
2286:stk500boot.c  **** 				PrintCPUstats();
 1601               		.loc 1 2286 0
 1602 02f2 62E0      		ldi r22,lo8(2)
 1603 02f4 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1604 02f6 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1605 02f8 0E94 0000 		call PrintFromPROGMEMln
 1606               	.LVL145:
 1607               	.LBB235:
 1608               	.LBB236:
1628:stk500boot.c  **** 
 1609               		.loc 1 1628 0
 1610 02fc 60E0      		ldi r22,0
 1611 02fe 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1612 0300 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1613 0302 0E94 0000 		call PrintFromPROGMEMln
 1614               	.LVL146:
1630:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
 1615               		.loc 1 1630 0
 1616 0306 60E0      		ldi r22,0
 1617 0308 80E0      		ldi r24,lo8(gTextMsg_COMPILED_ON)
 1618 030a 90E0      		ldi r25,hi8(gTextMsg_COMPILED_ON)
 1619 030c 0E94 0000 		call PrintFromPROGMEM
 1620               	.LVL147:
1631:stk500boot.c  **** 
 1621               		.loc 1 1631 0
 1622 0310 60E0      		ldi r22,0
 1623 0312 80E0      		ldi r24,lo8(gTextMsg_GCC_DATE_STR)
 1624 0314 90E0      		ldi r25,hi8(gTextMsg_GCC_DATE_STR)
 1625 0316 0E94 0000 		call PrintFromPROGMEMln
 1626               	.LVL148:
1633:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1627               		.loc 1 1633 0
 1628 031a 60E0      		ldi r22,0
 1629 031c 80E0      		ldi r24,lo8(gTextMsg_CPU_Type)
 1630 031e 90E0      		ldi r25,hi8(gTextMsg_CPU_Type)
 1631 0320 0E94 0000 		call PrintFromPROGMEM
 1632               	.LVL149:
1634:stk500boot.c  **** 
 1633               		.loc 1 1634 0
 1634 0324 60E0      		ldi r22,0
 1635 0326 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1636 0328 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1637 032a 0E94 0000 		call PrintFromPROGMEMln
 1638               	.LVL150:
1636:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
 1639               		.loc 1 1636 0
 1640 032e 60E0      		ldi r22,0
 1641 0330 80E0      		ldi r24,lo8(gTextMsg_AVR_ARCH)
 1642 0332 90E0      		ldi r25,hi8(gTextMsg_AVR_ARCH)
 1643 0334 0E94 0000 		call PrintFromPROGMEM
 1644               	.LVL151:
 1645               	.LBB237:
 1646               	.LBB238:
1617:stk500boot.c  **** }
 1647               		.loc 1 1617 0
 1648 0338 86E3      		ldi r24,lo8(54)
 1649 033a 0E94 0000 		call sendchar
 1650               	.LVL152:
 1651               	.LBE238:
 1652               	.LBE237:
1638:stk500boot.c  **** 
 1653               		.loc 1 1638 0
 1654 033e 0E94 0000 		call PrintNewLine
 1655               	.LVL153:
1640:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
 1656               		.loc 1 1640 0
 1657 0342 60E0      		ldi r22,0
 1658 0344 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION)
 1659 0346 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION)
 1660 0348 0E94 0000 		call PrintFromPROGMEM
 1661               	.LVL154:
1641:stk500boot.c  **** 
 1662               		.loc 1 1641 0
 1663 034c 60E0      		ldi r22,0
 1664 034e 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION_STR)
 1665 0350 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION_STR)
 1666 0352 0E94 0000 		call PrintFromPROGMEMln
 1667               	.LVL155:
1644:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
 1668               		.loc 1 1644 0
 1669 0356 60E0      		ldi r22,0
 1670 0358 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC)
 1671 035a 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC)
 1672 035c 0E94 0000 		call PrintFromPROGMEM
 1673               	.LVL156:
1645:stk500boot.c  **** 
 1674               		.loc 1 1645 0
 1675 0360 60E0      		ldi r22,0
 1676 0362 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC_VER_STR)
 1677 0364 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC_VER_STR)
 1678 0366 0E94 0000 		call PrintFromPROGMEMln
 1679               	.LVL157:
1648:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
 1680               		.loc 1 1648 0
 1681 036a 60E0      		ldi r22,0
 1682 036c 80E0      		ldi r24,lo8(gTextMsg_CPU_SIGNATURE)
 1683 036e 90E0      		ldi r25,hi8(gTextMsg_CPU_SIGNATURE)
 1684 0370 0E94 0000 		call PrintFromPROGMEM
 1685               	.LVL158:
1650:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
 1686               		.loc 1 1650 0
 1687 0374 8EE1      		ldi r24,lo8(30)
 1688 0376 0E94 0000 		call PrintHexByte
 1689               	.LVL159:
1651:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
 1690               		.loc 1 1651 0
 1691 037a 88E9      		ldi r24,lo8(-104)
 1692 037c 0E94 0000 		call PrintHexByte
 1693               	.LVL160:
1652:stk500boot.c  **** 	PrintNewLine();
 1694               		.loc 1 1652 0
 1695 0380 81E0      		ldi r24,lo8(1)
 1696 0382 0E94 0000 		call PrintHexByte
 1697               	.LVL161:
1653:stk500boot.c  **** #endif
 1698               		.loc 1 1653 0
 1699 0386 0E94 0000 		call PrintNewLine
 1700               	.LVL162:
1659:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1701               		.loc 1 1659 0
 1702 038a 60E0      		ldi r22,0
 1703 038c 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOW)
 1704 038e 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOW)
 1705 0390 0E94 0000 		call PrintFromPROGMEM
 1706               	.LVL163:
 1707               	.LBB239:
1660:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1708               		.loc 1 1660 0
 1709 0394 29E0      		ldi r18,lo8(9)
 1710 0396 F0E0      		ldi r31,0
 1711 0398 E0E0      		ldi r30,0
 1712               	/* #APP */
 1713               	 ;  1660 "stk500boot.c" 1
 1714 039a 2093 5700 		sts 87, r18
 1715 039e 8491      		lpm r24, Z
 1716               		
 1717               	 ;  0 "" 2
 1718               	.LVL164:
 1719               	/* #NOAPP */
 1720               	.LBE239:
1661:stk500boot.c  **** 	PrintNewLine();
 1721               		.loc 1 1661 0
 1722 03a0 0E94 0000 		call PrintHexByte
 1723               	.LVL165:
1662:stk500boot.c  **** 
 1724               		.loc 1 1662 0
 1725 03a4 0E94 0000 		call PrintNewLine
 1726               	.LVL166:
1664:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1727               		.loc 1 1664 0
 1728 03a8 60E0      		ldi r22,0
 1729 03aa 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_HIGH)
 1730 03ac 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_HIGH)
 1731 03ae 0E94 0000 		call PrintFromPROGMEM
 1732               	.LVL167:
 1733               	.LBB240:
1665:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1734               		.loc 1 1665 0
 1735 03b2 29E0      		ldi r18,lo8(9)
 1736 03b4 E3E0      		ldi r30,lo8(3)
 1737 03b6 F0E0      		ldi r31,0
 1738               	/* #APP */
 1739               	 ;  1665 "stk500boot.c" 1
 1740 03b8 2093 5700 		sts 87, r18
 1741 03bc 8491      		lpm r24, Z
 1742               		
 1743               	 ;  0 "" 2
 1744               	.LVL168:
 1745               	/* #NOAPP */
 1746               	.LBE240:
1666:stk500boot.c  **** 	PrintNewLine();
 1747               		.loc 1 1666 0
 1748 03be 0E94 0000 		call PrintHexByte
 1749               	.LVL169:
1667:stk500boot.c  **** 
 1750               		.loc 1 1667 0
 1751 03c2 0E94 0000 		call PrintNewLine
 1752               	.LVL170:
1669:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 1753               		.loc 1 1669 0
 1754 03c6 60E0      		ldi r22,0
 1755 03c8 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_EXT)
 1756 03ca 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_EXT)
 1757 03cc 0E94 0000 		call PrintFromPROGMEM
 1758               	.LVL171:
 1759               	.LBB241:
1670:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1760               		.loc 1 1670 0
 1761 03d0 E2E0      		ldi r30,lo8(2)
 1762 03d2 F0E0      		ldi r31,0
 1763 03d4 39E0      		ldi r19,lo8(9)
 1764               	/* #APP */
 1765               	 ;  1670 "stk500boot.c" 1
 1766 03d6 3093 5700 		sts 87, r19
 1767 03da 8491      		lpm r24, Z
 1768               		
 1769               	 ;  0 "" 2
 1770               	.LVL172:
 1771               	/* #NOAPP */
 1772               	.LBE241:
1671:stk500boot.c  **** 	PrintNewLine();
 1773               		.loc 1 1671 0
 1774 03dc 0E94 0000 		call PrintHexByte
 1775               	.LVL173:
1672:stk500boot.c  **** 
 1776               		.loc 1 1672 0
 1777 03e0 0E94 0000 		call PrintNewLine
 1778               	.LVL174:
1674:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
 1779               		.loc 1 1674 0
 1780 03e4 60E0      		ldi r22,0
 1781 03e6 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOCK)
 1782 03e8 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOCK)
 1783 03ea 0E94 0000 		call PrintFromPROGMEM
 1784               	.LVL175:
 1785               	.LBB242:
1675:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1786               		.loc 1 1675 0
 1787 03ee E1E0      		ldi r30,lo8(1)
 1788 03f0 F0E0      		ldi r31,0
 1789 03f2 49E0      		ldi r20,lo8(9)
 1790               	/* #APP */
 1791               	 ;  1675 "stk500boot.c" 1
 1792 03f4 4093 5700 		sts 87, r20
 1793 03f8 8491      		lpm r24, Z
 1794               		
 1795               	 ;  0 "" 2
 1796               	.LVL176:
 1797               	/* #NOAPP */
 1798               	.LBE242:
1676:stk500boot.c  **** 	PrintNewLine();
 1799               		.loc 1 1676 0
 1800 03fa 0E94 0000 		call PrintHexByte
 1801               	.LVL177:
1677:stk500boot.c  **** 
 1802               		.loc 1 1677 0
 1803 03fe 0E94 0000 		call PrintNewLine
 1804               	.LVL178:
 1805 0402 00C0      		rjmp .L81
 1806               	.LVL179:
 1807               	.L85:
 1808               	.LBE236:
 1809               	.LBE235:
2291:stk500boot.c  **** 				EEPROMtest();
 1810               		.loc 1 2291 0
 1811 0404 62E0      		ldi r22,lo8(2)
 1812 0406 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1813 0408 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1814 040a 0E94 0000 		call PrintFromPROGMEMln
 1815               	.LVL180:
 1816               	.LBB243:
 1817               	.LBB234:
1786:stk500boot.c  **** 	PrintNewLine();
 1818               		.loc 1 1786 0
 1819 040e 60E0      		ldi r22,0
 1820 0410 80E0      		ldi r24,lo8(gTextMsg_WriteToEEprom)
 1821 0412 90E0      		ldi r25,hi8(gTextMsg_WriteToEEprom)
 1822 0414 0E94 0000 		call PrintFromPROGMEMln
 1823               	.LVL181:
1787:stk500boot.c  **** 	ii			=	0;
 1824               		.loc 1 1787 0
 1825 0418 0E94 0000 		call PrintNewLine
 1826               	.LVL182:
1788:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1827               		.loc 1 1788 0
 1828 041c F12C      		mov r15,__zero_reg__
 1829 041e E12C      		mov r14,__zero_reg__
 1830               	.LVL183:
 1831               	.L99:
 1832               	.LBB232:
1790:stk500boot.c  **** #else
 1833               		.loc 1 1790 0
 1834 0420 C701      		movw r24,r14
 1835 0422 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1836 0424 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1837 0426 B0E0      		ldi r27,0
 1838 0428 A0E0      		ldi r26,0
 1839               	/* #APP */
 1840               	 ;  1790 "stk500boot.c" 1
 1841 042a ABBF      		out 59, r26
 1842 042c FC01      		movw r30, r24
 1843 042e 1791      		elpm r17, Z+
 1844               		
 1845               	 ;  0 "" 2
 1846               	.LVL184:
 1847               	/* #NOAPP */
 1848               	.LBE232:
 1849 0430 1A32      		cpi r17,lo8(42)
 1850 0432 01F0      		breq .L102
 1851 0434 E114      		cp r14,__zero_reg__
 1852 0436 62E0      		ldi r22,2
 1853 0438 F606      		cpc r15,r22
 1854 043a 01F4      		brne .L103
 1855               	.L102:
1808:stk500boot.c  **** 	PrintNewLine();
 1856               		.loc 1 1808 0
 1857 043c 0E94 0000 		call PrintNewLine
 1858               	.LVL185:
1809:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
 1859               		.loc 1 1809 0
 1860 0440 0E94 0000 		call PrintNewLine
 1861               	.LVL186:
1810:stk500boot.c  **** 	PrintNewLine();
 1862               		.loc 1 1810 0
 1863 0444 60E0      		ldi r22,0
 1864 0446 80E0      		ldi r24,lo8(gTextMsg_ReadingEEprom)
 1865 0448 90E0      		ldi r25,hi8(gTextMsg_ReadingEEprom)
 1866 044a 0E94 0000 		call PrintFromPROGMEMln
 1867               	.LVL187:
1811:stk500boot.c  **** 	errorCount	=	0;
 1868               		.loc 1 1811 0
 1869 044e 0E94 0000 		call PrintNewLine
 1870               	.LVL188:
1812:stk500boot.c  **** 	ii			=	0;
 1871               		.loc 1 1812 0
 1872 0452 D12C      		mov r13,__zero_reg__
 1873 0454 C12C      		mov r12,__zero_reg__
1813:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1874               		.loc 1 1813 0
 1875 0456 F12C      		mov r15,__zero_reg__
 1876 0458 E12C      		mov r14,__zero_reg__
 1877               	.LVL189:
 1878               	.L104:
 1879               	.LBB233:
1815:stk500boot.c  **** #else
 1880               		.loc 1 1815 0
 1881 045a C701      		movw r24,r14
 1882 045c 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1883 045e 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1884 0460 B0E0      		ldi r27,0
 1885 0462 A0E0      		ldi r26,0
 1886               	/* #APP */
 1887               	 ;  1815 "stk500boot.c" 1
 1888 0464 ABBF      		out 59, r26
 1889 0466 FC01      		movw r30, r24
 1890 0468 1791      		elpm r17, Z+
 1891               		
 1892               	 ;  0 "" 2
 1893               	.LVL190:
 1894               	/* #NOAPP */
 1895               	.LBE233:
 1896 046a 1A32      		cpi r17,lo8(42)
 1897 046c 01F0      		breq .L108
 1898 046e E114      		cp r14,__zero_reg__
 1899 0470 92E0      		ldi r25,2
 1900 0472 F906      		cpc r15,r25
 1901 0474 01F4      		brne .L109
 1902               	.L108:
1835:stk500boot.c  **** 	PrintNewLine();
 1903               		.loc 1 1835 0
 1904 0476 0E94 0000 		call PrintNewLine
 1905               	.LVL191:
1836:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
 1906               		.loc 1 1836 0
 1907 047a 0E94 0000 		call PrintNewLine
 1908               	.LVL192:
1837:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
 1909               		.loc 1 1837 0
 1910 047e 60E0      		ldi r22,0
 1911 0480 80E0      		ldi r24,lo8(gTextMsg_EEPROMerrorCnt)
 1912 0482 90E0      		ldi r25,hi8(gTextMsg_EEPROMerrorCnt)
 1913 0484 0E94 0000 		call PrintFromPROGMEM
 1914               	.LVL193:
1838:stk500boot.c  **** 	PrintNewLine();
 1915               		.loc 1 1838 0
 1916 0488 61E0      		ldi r22,lo8(1)
 1917 048a 70E0      		ldi r23,0
 1918 048c C601      		movw r24,r12
 1919 048e 0E94 0000 		call PrintDecInt
 1920               	.LVL194:
1839:stk500boot.c  **** 	PrintNewLine();
 1921               		.loc 1 1839 0
 1922 0492 0E94 0000 		call PrintNewLine
 1923               	.LVL195:
1840:stk500boot.c  **** 
 1924               		.loc 1 1840 0
 1925 0496 0E94 0000 		call PrintNewLine
 1926               	.LVL196:
 1927 049a 00C0      		rjmp .L298
 1928               	.LVL197:
 1929               	.L103:
1795:stk500boot.c  **** 		if (theChar == 0)
 1930               		.loc 1 1795 0
 1931 049c 612F      		mov r22,r17
 1932 049e C701      		movw r24,r14
 1933 04a0 0E94 0000 		call eeprom_write_byte
 1934               	.LVL198:
1796:stk500boot.c  **** 		{
 1935               		.loc 1 1796 0
 1936 04a4 1111      		cpse r17,__zero_reg__
 1937 04a6 00C0      		rjmp .L100
1798:stk500boot.c  **** 		}
 1938               		.loc 1 1798 0
 1939 04a8 60E0      		ldi r22,0
 1940 04aa 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1941 04ac 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1942 04ae 0E94 0000 		call PrintFromPROGMEM
 1943               	.LVL199:
 1944               	.L101:
1804:stk500boot.c  **** 	}
 1945               		.loc 1 1804 0
 1946 04b2 5FEF      		ldi r21,-1
 1947 04b4 E51A      		sub r14,r21
 1948 04b6 F50A      		sbc r15,r21
 1949               	.LVL200:
 1950 04b8 00C0      		rjmp .L99
 1951               	.LVL201:
 1952               	.L100:
1802:stk500boot.c  **** 		}
 1953               		.loc 1 1802 0
 1954 04ba 812F      		mov r24,r17
 1955 04bc 0E94 0000 		call sendchar
 1956               	.LVL202:
 1957 04c0 00C0      		rjmp .L101
 1958               	.LVL203:
 1959               	.L109:
1820:stk500boot.c  **** 		if (theEEPROMchar == 0)
 1960               		.loc 1 1820 0
 1961 04c2 C701      		movw r24,r14
 1962 04c4 0E94 0000 		call eeprom_read_byte
 1963               	.LVL204:
 1964 04c8 B82E      		mov r11,r24
 1965               	.LVL205:
1821:stk500boot.c  **** 		{
 1966               		.loc 1 1821 0
 1967 04ca 8111      		cpse r24,__zero_reg__
 1968 04cc 00C0      		rjmp .L105
1823:stk500boot.c  **** 		}
 1969               		.loc 1 1823 0
 1970 04ce 60E0      		ldi r22,0
 1971 04d0 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1972 04d2 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1973 04d4 0E94 0000 		call PrintFromPROGMEM
 1974               	.LVL206:
 1975               	.L106:
1829:stk500boot.c  **** 		{
 1976               		.loc 1 1829 0
 1977 04d8 B116      		cp r11,r17
 1978 04da 01F0      		breq .L107
1831:stk500boot.c  **** 		}
 1979               		.loc 1 1831 0
 1980 04dc 7FEF      		ldi r23,-1
 1981 04de C71A      		sub r12,r23
 1982 04e0 D70A      		sbc r13,r23
 1983               	.LVL207:
 1984               	.L107:
1833:stk500boot.c  **** 	}
 1985               		.loc 1 1833 0
 1986 04e2 8FEF      		ldi r24,-1
 1987 04e4 E81A      		sub r14,r24
 1988 04e6 F80A      		sbc r15,r24
 1989               	.LVL208:
 1990 04e8 00C0      		rjmp .L104
 1991               	.LVL209:
 1992               	.L105:
1827:stk500boot.c  **** 		}
 1993               		.loc 1 1827 0
 1994 04ea 0E94 0000 		call sendchar
 1995               	.LVL210:
 1996 04ee 00C0      		rjmp .L106
 1997               	.LVL211:
 1998               	.L89:
 1999               	.LBE234:
 2000               	.LBE243:
2296:stk500boot.c  **** 				BlinkLED();
 2001               		.loc 1 2296 0
 2002 04f0 62E0      		ldi r22,lo8(2)
 2003 04f2 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 2004 04f4 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 2005 04f6 0E94 0000 		call PrintFromPROGMEMln
 2006               	.LVL212:
 2007               	.LBB244:
 2008               	.LBB245:
1687:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 2009               		.loc 1 1687 0
 2010 04fa 279A      		sbi 0x4,7
1688:stk500boot.c  **** 
 2011               		.loc 1 1688 0
 2012 04fc 2F9A      		sbi 0x5,7
 2013               	.L110:
 2014               	.LBB246:
 2015               	.LBB247:
 476:stk500boot.c  **** }
 2016               		.loc 1 476 0
 2017 04fe 8091 C000 		lds r24,192
 2018               	.LBE247:
 2019               	.LBE246:
1690:stk500boot.c  **** 	{
 2020               		.loc 1 1690 0
 2021 0502 87FF      		sbrs r24,7
 2022 0504 00C0      		rjmp .L111
 2023               	.LVL213:
 2024               	.L137:
1697:stk500boot.c  **** }
 2025               		.loc 1 1697 0
 2026 0506 0E94 0000 		call recchar
 2027               	.LVL214:
 2028 050a 00C0      		rjmp .L81
 2029               	.LVL215:
 2030               	.L111:
1692:stk500boot.c  **** 		delay_ms(100);
 2031               		.loc 1 1692 0
 2032 050c 2F98      		cbi 0x5,7
1693:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 2033               		.loc 1 1693 0
 2034 050e 84E6      		ldi r24,lo8(100)
 2035 0510 90E0      		ldi r25,0
 2036 0512 0E94 0000 		call delay_ms
 2037               	.LVL216:
1694:stk500boot.c  **** 		delay_ms(100);
 2038               		.loc 1 1694 0
 2039 0516 2F9A      		sbi 0x5,7
1695:stk500boot.c  **** 	}
 2040               		.loc 1 1695 0
 2041 0518 84E6      		ldi r24,lo8(100)
 2042 051a 90E0      		ldi r25,0
 2043 051c 0E94 0000 		call delay_ms
 2044               	.LVL217:
 2045 0520 00C0      		rjmp .L110
 2046               	.L83:
 2047               	.LBE245:
 2048               	.LBE244:
2311:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
 2049               		.loc 1 2311 0
 2050 0522 62E0      		ldi r22,lo8(2)
 2051 0524 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 2052 0526 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 2053 0528 0E94 0000 		call PrintFromPROGMEMln
 2054               	.LVL218:
2312:stk500boot.c  **** 				gFlashIndex	+=	256;
 2055               		.loc 1 2312 0
 2056 052c 4091 0000 		lds r20,gFlashIndex
 2057 0530 5091 0000 		lds r21,gFlashIndex+1
 2058 0534 6091 0000 		lds r22,gFlashIndex+2
 2059 0538 7091 0000 		lds r23,gFlashIndex+3
 2060 053c 80E0      		ldi r24,0
 2061 053e 0E94 0000 		call DumpHex.constprop.1
 2062               	.LVL219:
2313:stk500boot.c  **** 				break;
 2063               		.loc 1 2313 0
 2064 0542 8091 0000 		lds r24,gFlashIndex
 2065 0546 9091 0000 		lds r25,gFlashIndex+1
 2066 054a A091 0000 		lds r26,gFlashIndex+2
 2067 054e B091 0000 		lds r27,gFlashIndex+3
 2068 0552 9F5F      		subi r25,-1
 2069 0554 AF4F      		sbci r26,-1
 2070 0556 BF4F      		sbci r27,-1
 2071 0558 8093 0000 		sts gFlashIndex,r24
 2072 055c 9093 0000 		sts gFlashIndex+1,r25
 2073 0560 A093 0000 		sts gFlashIndex+2,r26
 2074 0564 B093 0000 		sts gFlashIndex+3,r27
 2075 0568 00C0      		rjmp .L81
 2076               	.L93:
2317:stk500boot.c  **** 				PrintHelp();
 2077               		.loc 1 2317 0
 2078 056a 62E0      		ldi r22,lo8(2)
 2079 056c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 2080 056e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 2081 0570 0E94 0000 		call PrintFromPROGMEMln
 2082               	.LVL220:
 2083               	.LBB248:
 2084               	.LBB249:
2223:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
 2085               		.loc 1 2223 0
 2086 0574 60E0      		ldi r22,0
 2087 0576 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 2088 0578 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 2089 057a 0E94 0000 		call PrintFromPROGMEMln
 2090               	.LVL221:
2224:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
 2091               		.loc 1 2224 0
 2092 057e 60E0      		ldi r22,0
 2093 0580 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 2094 0582 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 2095 0584 0E94 0000 		call PrintFromPROGMEMln
 2096               	.LVL222:
2225:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
 2097               		.loc 1 2225 0
 2098 0588 60E0      		ldi r22,0
 2099 058a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 2100 058c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 2101 058e 0E94 0000 		call PrintFromPROGMEMln
 2102               	.LVL223:
2226:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
 2103               		.loc 1 2226 0
 2104 0592 60E0      		ldi r22,0
 2105 0594 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 2106 0596 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 2107 0598 0E94 0000 		call PrintFromPROGMEMln
 2108               	.LVL224:
2227:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
 2109               		.loc 1 2227 0
 2110 059c 60E0      		ldi r22,0
 2111 059e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 2112 05a0 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 2113 05a2 0E94 0000 		call PrintFromPROGMEMln
 2114               	.LVL225:
2228:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
 2115               		.loc 1 2228 0
 2116 05a6 60E0      		ldi r22,0
 2117 05a8 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 2118 05aa 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 2119 05ac 0E94 0000 		call PrintFromPROGMEMln
 2120               	.LVL226:
2229:stk500boot.c  **** 
 2121               		.loc 1 2229 0
 2122 05b0 60E0      		ldi r22,0
 2123 05b2 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 2124 05b4 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 2125 05b6 0E94 0000 		call PrintFromPROGMEMln
 2126               	.LVL227:
2231:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
 2127               		.loc 1 2231 0
 2128 05ba 60E0      		ldi r22,0
 2129 05bc 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 2130 05be 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 2131 05c0 0E94 0000 		call PrintFromPROGMEMln
 2132               	.LVL228:
2232:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
 2133               		.loc 1 2232 0
 2134 05c4 60E0      		ldi r22,0
 2135 05c6 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 2136 05c8 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 2137 05ca 0E94 0000 		call PrintFromPROGMEMln
 2138               	.LVL229:
2233:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
 2139               		.loc 1 2233 0
 2140 05ce 60E0      		ldi r22,0
 2141 05d0 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 2142 05d2 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 2143 05d4 0E94 0000 		call PrintFromPROGMEMln
 2144               	.LVL230:
2234:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
 2145               		.loc 1 2234 0
 2146 05d8 60E0      		ldi r22,0
 2147 05da 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 2148 05dc 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 2149 05de 0E94 0000 		call PrintFromPROGMEMln
 2150               	.LVL231:
2235:stk500boot.c  **** }
 2151               		.loc 1 2235 0
 2152 05e2 60E0      		ldi r22,0
 2153 05e4 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 2154 05e6 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 2155               	.LVL232:
 2156               	.L297:
 2157               	.LBE249:
 2158               	.LBE248:
2335:stk500boot.c  **** 				break;
2336:stk500boot.c  **** 
2337:stk500boot.c  **** 			case 'V':
2338:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 2);
2339:stk500boot.c  **** 				VectorDisplay();
2340:stk500boot.c  **** 				break;
2341:stk500boot.c  **** 
2342:stk500boot.c  **** 			case 'Y':
2343:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 2);
2344:stk500boot.c  **** 				AVR_PortOutput();
2345:stk500boot.c  **** 				break;
2346:stk500boot.c  **** 			
2347:stk500boot.c  **** 			default:
2348:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HUH, 0);
 2159               		.loc 1 2348 0
 2160 05e8 0E94 0000 		call PrintFromPROGMEMln
 2161               	.LVL233:
 2162 05ec 00C0      		rjmp .L81
 2163               	.LVL234:
 2164               	.L91:
2327:stk500boot.c  **** 				keepGoing	=	false;
 2165               		.loc 1 2327 0
 2166 05ee 62E0      		ldi r22,lo8(2)
 2167 05f0 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 2168 05f2 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 2169 05f4 0E94 0000 		call PrintFromPROGMEMln
 2170               	.LVL235:
 2171               	.LBE227:
 2172               	.LBE226:
 910:stk500boot.c  **** 						isLeave			=	1;
 2173               		.loc 1 910 0
 2174 05f8 F12C      		mov r15,__zero_reg__
 2175 05fa E12C      		mov r14,__zero_reg__
 911:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 2176               		.loc 1 911 0
 2177 05fc DD24      		clr r13
 2178 05fe D394      		inc r13
 2179               	.LVL236:
 2180               	.L113:
1002:stk500boot.c  **** 			{
 2181               		.loc 1 1002 0
 2182 0600 2981      		ldd r18,Y+1
 2183 0602 2331      		cpi r18,lo8(19)
 2184 0604 01F4      		brne .+2
 2185 0606 00C0      		rjmp .L257
 2186 0608 00F0      		brlo .+2
 2187 060a 00C0      		rjmp .L173
 2188 060c 2630      		cpi r18,lo8(6)
 2189 060e 01F4      		brne .+2
 2190 0610 00C0      		rjmp .L174
 2191 0612 00F0      		brlo .+2
 2192 0614 00C0      		rjmp .L175
 2193 0616 2230      		cpi r18,lo8(2)
 2194 0618 01F4      		brne .+2
 2195 061a 00C0      		rjmp .L305
 2196 061c 2330      		cpi r18,lo8(3)
 2197 061e 01F4      		brne .+2
 2198 0620 00C0      		rjmp .L177
 2199 0622 2130      		cpi r18,lo8(1)
 2200 0624 01F0      		breq .+2
 2201 0626 00C0      		rjmp .L171
 2202               	.LVL237:
1066:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 2203               		.loc 1 1066 0
 2204 0628 1A82      		std Y+2,__zero_reg__
1067:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 2205               		.loc 1 1067 0
 2206 062a 88E0      		ldi r24,lo8(8)
 2207 062c 8B83      		std Y+3,r24
1068:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 2208               		.loc 1 1068 0
 2209 062e 81E4      		ldi r24,lo8(65)
 2210 0630 8C83      		std Y+4,r24
1069:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 2211               		.loc 1 1069 0
 2212 0632 86E5      		ldi r24,lo8(86)
 2213 0634 8D83      		std Y+5,r24
1070:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 2214               		.loc 1 1070 0
 2215 0636 82E5      		ldi r24,lo8(82)
 2216 0638 8E83      		std Y+6,r24
1071:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 2217               		.loc 1 1071 0
 2218 063a 89E4      		ldi r24,lo8(73)
 2219 063c 8F83      		std Y+7,r24
1072:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 2220               		.loc 1 1072 0
 2221 063e 83E5      		ldi r24,lo8(83)
 2222 0640 8887      		std Y+8,r24
1073:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 2223               		.loc 1 1073 0
 2224 0642 80E5      		ldi r24,lo8(80)
 2225 0644 8987      		std Y+9,r24
1074:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 2226               		.loc 1 1074 0
 2227 0646 8FE5      		ldi r24,lo8(95)
 2228 0648 8A87      		std Y+10,r24
1075:stk500boot.c  **** 					break;
 2229               		.loc 1 1075 0
 2230 064a 82E3      		ldi r24,lo8(50)
 2231 064c 8B87      		std Y+11,r24
1065:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 2232               		.loc 1 1065 0
 2233 064e 0BE0      		ldi r16,lo8(11)
 2234 0650 10E0      		ldi r17,0
1076:stk500boot.c  **** 
 2235               		.loc 1 1076 0
 2236 0652 00C0      		rjmp .L191
 2237               	.LVL238:
 2238               	.L95:
 2239               	.LBB286:
 2240               	.LBB284:
2338:stk500boot.c  **** 				VectorDisplay();
 2241               		.loc 1 2338 0
 2242 0654 62E0      		ldi r22,lo8(2)
 2243 0656 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 2244 0658 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 2245 065a 0E94 0000 		call PrintFromPROGMEMln
 2246               	.LVL239:
 2247               	.LBB250:
 2248               	.LBB251:
1878:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
 2249               		.loc 1 1878 0
 2250 065e 60E0      		ldi r22,0
 2251 0660 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 2252 0662 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 2253 0664 0E94 0000 		call PrintFromPROGMEMln
 2254               	.LVL240:
1879:stk500boot.c  **** 	//					 V#   ADDR   op code
 2255               		.loc 1 1879 0
 2256 0668 60E0      		ldi r22,0
 2257 066a 80E0      		ldi r24,lo8(gTextMsg_VECTOR_HEADER)
 2258 066c 90E0      		ldi r25,hi8(gTextMsg_VECTOR_HEADER)
 2259 066e 0E94 0000 		call PrintFromPROGMEMln
 2260               	.LVL241:
1877:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 2261               		.loc 1 1877 0
 2262 0672 712C      		mov r7,__zero_reg__
 2263 0674 612C      		mov r6,__zero_reg__
1876:stk500boot.c  **** 	vectorIndex		=	0;
 2264               		.loc 1 1876 0
 2265 0676 C05E      		subi r28,lo8(-288)
 2266 0678 DE4F      		sbci r29,hi8(-288)
 2267 067a 1882      		st Y,__zero_reg__
 2268 067c 1982      		std Y+1,__zero_reg__
 2269 067e 1A82      		std Y+2,__zero_reg__
 2270 0680 1B82      		std Y+3,__zero_reg__
 2271 0682 C052      		subi r28,lo8(288)
 2272 0684 D140      		sbci r29,hi8(288)
 2273               	.LVL242:
 2274               	.L117:
1884:stk500boot.c  **** 		//					 01 - 0000 = 12 34
 2275               		.loc 1 1884 0
 2276 0686 C05E      		subi r28,lo8(-288)
 2277 0688 DE4F      		sbci r29,hi8(-288)
 2278 068a 2881      		ld r18,Y
 2279 068c 3981      		ldd r19,Y+1
 2280 068e 4A81      		ldd r20,Y+2
 2281 0690 5B81      		ldd r21,Y+3
 2282 0692 C052      		subi r28,lo8(288)
 2283 0694 D140      		sbci r29,hi8(288)
 2284 0696 5695      		lsr r21
 2285 0698 4795      		ror r20
 2286 069a 3795      		ror r19
 2287 069c 2795      		ror r18
 2288 069e C35D      		subi r28,lo8(-301)
 2289 06a0 DE4F      		sbci r29,hi8(-301)
 2290 06a2 2883      		st Y,r18
 2291 06a4 3983      		std Y+1,r19
 2292 06a6 4A83      		std Y+2,r20
 2293 06a8 5B83      		std Y+3,r21
 2294 06aa CD52      		subi r28,lo8(301)
 2295 06ac D140      		sbci r29,hi8(301)
 2296               	.LVL243:
1886:stk500boot.c  **** 		sendchar(0x20);
 2297               		.loc 1 1886 0
 2298 06ae 3FEF      		ldi r19,-1
 2299 06b0 631A      		sub r6,r19
 2300 06b2 730A      		sbc r7,r19
 2301               	.LVL244:
 2302 06b4 62E0      		ldi r22,lo8(2)
 2303 06b6 70E0      		ldi r23,0
 2304 06b8 C301      		movw r24,r6
 2305 06ba 0E94 0000 		call PrintDecInt
 2306               	.LVL245:
1887:stk500boot.c  **** 		sendchar('-');
 2307               		.loc 1 1887 0
 2308 06be 80E2      		ldi r24,lo8(32)
 2309 06c0 0E94 0000 		call sendchar
 2310               	.LVL246:
1888:stk500boot.c  **** 		sendchar(0x20);
 2311               		.loc 1 1888 0
 2312 06c4 8DE2      		ldi r24,lo8(45)
 2313 06c6 0E94 0000 		call sendchar
 2314               	.LVL247:
1889:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
 2315               		.loc 1 1889 0
 2316 06ca 80E2      		ldi r24,lo8(32)
 2317 06cc 0E94 0000 		call sendchar
 2318               	.LVL248:
1890:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
 2319               		.loc 1 1890 0
 2320 06d0 80E0      		ldi r24,0
 2321 06d2 0E94 0000 		call PrintHexByte
 2322               	.LVL249:
1891:stk500boot.c  **** 		sendchar(0x20);
 2323               		.loc 1 1891 0
 2324 06d6 C35D      		subi r28,lo8(-301)
 2325 06d8 DE4F      		sbci r29,hi8(-301)
 2326 06da 8881      		ld r24,Y
 2327 06dc CD52      		subi r28,lo8(301)
 2328 06de D140      		sbci r29,hi8(301)
 2329 06e0 0E94 0000 		call PrintHexByte
 2330               	.LVL250:
1892:stk500boot.c  **** 		sendchar('=');
 2331               		.loc 1 1892 0
 2332 06e4 80E2      		ldi r24,lo8(32)
 2333 06e6 0E94 0000 		call sendchar
 2334               	.LVL251:
1893:stk500boot.c  **** 		sendchar(0x20);
 2335               		.loc 1 1893 0
 2336 06ea 8DE3      		ldi r24,lo8(61)
 2337 06ec 0E94 0000 		call sendchar
 2338               	.LVL252:
1894:stk500boot.c  **** 
 2339               		.loc 1 1894 0
 2340 06f0 80E2      		ldi r24,lo8(32)
 2341 06f2 0E94 0000 		call sendchar
 2342               	.LVL253:
 2343               	.LBB252:
1899:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 2344               		.loc 1 1899 0
 2345 06f6 C05E      		subi r28,lo8(-288)
 2346 06f8 DE4F      		sbci r29,hi8(-288)
 2347 06fa 4881      		ld r20,Y
 2348 06fc 5981      		ldd r21,Y+1
 2349 06fe 6A81      		ldd r22,Y+2
 2350 0700 7B81      		ldd r23,Y+3
 2351 0702 C052      		subi r28,lo8(288)
 2352 0704 D140      		sbci r29,hi8(288)
 2353               	/* #APP */
 2354               	 ;  1899 "stk500boot.c" 1
 2355 0706 6BBF      		out 59, r22
 2356 0708 FA01      		movw r30, r20
 2357 070a 5791      		elpm r21, Z+
 2358               		
 2359               	 ;  0 "" 2
 2360               	/* #NOAPP */
 2361 070c CB5C      		subi r28,lo8(-309)
 2362 070e DE4F      		sbci r29,hi8(-309)
 2363 0710 5883      		st Y,r21
 2364 0712 C553      		subi r28,lo8(309)
 2365 0714 D140      		sbci r29,hi8(309)
 2366               	.LVL254:
 2367               	.LBE252:
 2368 0716 C52E      		mov r12,r21
 2369 0718 D12C      		mov r13,__zero_reg__
 2370 071a F12C      		mov r15,__zero_reg__
 2371 071c E12C      		mov r14,__zero_reg__
 2372               	.LVL255:
 2373               	.LBB253:
 2374 071e C05E      		subi r28,lo8(-288)
 2375 0720 DE4F      		sbci r29,hi8(-288)
 2376 0722 8881      		ld r24,Y
 2377 0724 9981      		ldd r25,Y+1
 2378 0726 AA81      		ldd r26,Y+2
 2379 0728 BB81      		ldd r27,Y+3
 2380 072a C052      		subi r28,lo8(288)
 2381 072c D140      		sbci r29,hi8(288)
 2382 072e 0196      		adiw r24,1
 2383 0730 A11D      		adc r26,__zero_reg__
 2384 0732 B11D      		adc r27,__zero_reg__
 2385               	.LVL256:
 2386               	.LBE253:
 2387               	.LBB254:
1900:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2388               		.loc 1 1900 0
 2389               	/* #APP */
 2390               	 ;  1900 "stk500boot.c" 1
 2391 0734 ABBF      		out 59, r26
 2392 0736 FC01      		movw r30, r24
 2393 0738 8791      		elpm r24, Z+
 2394               		
 2395               	 ;  0 "" 2
 2396               	.LVL257:
 2397               	/* #NOAPP */
 2398               	.LBE254:
 2399 073a 282F      		mov r18,r24
 2400 073c 30E0      		ldi r19,0
 2401 073e 50E0      		ldi r21,0
 2402               	.LVL258:
 2403 0740 40E0      		ldi r20,0
 2404 0742 CF5C      		subi r28,lo8(-305)
 2405 0744 DE4F      		sbci r29,hi8(-305)
 2406 0746 2883      		st Y,r18
 2407 0748 3983      		std Y+1,r19
 2408 074a 4A83      		std Y+2,r20
 2409 074c 5B83      		std Y+3,r21
 2410 074e C153      		subi r28,lo8(305)
 2411 0750 D140      		sbci r29,hi8(305)
 2412               	.LVL259:
 2413               	.LBB255:
 2414 0752 C05E      		subi r28,lo8(-288)
 2415 0754 DE4F      		sbci r29,hi8(-288)
 2416 0756 4881      		ld r20,Y
 2417 0758 5981      		ldd r21,Y+1
 2418 075a 6A81      		ldd r22,Y+2
 2419 075c 7B81      		ldd r23,Y+3
 2420 075e C052      		subi r28,lo8(288)
 2421 0760 D140      		sbci r29,hi8(288)
 2422 0762 4E5F      		subi r20,-2
 2423 0764 5F4F      		sbci r21,-1
 2424 0766 6F4F      		sbci r22,-1
 2425 0768 7F4F      		sbci r23,-1
 2426               	.LVL260:
 2427               	.LBE255:
 2428               	.LBB256:
1901:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 2429               		.loc 1 1901 0
 2430               	/* #APP */
 2431               	 ;  1901 "stk500boot.c" 1
 2432 076a 6BBF      		out 59, r22
 2433 076c FA01      		movw r30, r20
 2434 076e 3791      		elpm r19, Z+
 2435               		
 2436               	 ;  0 "" 2
 2437               	/* #NOAPP */
 2438 0770 CA5C      		subi r28,lo8(-310)
 2439 0772 DE4F      		sbci r29,hi8(-310)
 2440 0774 3883      		st Y,r19
 2441 0776 C653      		subi r28,lo8(310)
 2442 0778 D140      		sbci r29,hi8(310)
 2443               	.LVL261:
 2444               	.LBE256:
 2445               	.LBB257:
1902:stk500boot.c  **** 	#else
 2446               		.loc 1 1902 0
 2447 077a C05E      		subi r28,lo8(-288)
 2448 077c DE4F      		sbci r29,hi8(-288)
 2449 077e 4881      		ld r20,Y
 2450 0780 5981      		ldd r21,Y+1
 2451 0782 6A81      		ldd r22,Y+2
 2452 0784 7B81      		ldd r23,Y+3
 2453 0786 C052      		subi r28,lo8(288)
 2454 0788 D140      		sbci r29,hi8(288)
 2455               	.LVL262:
 2456 078a 4D5F      		subi r20,-3
 2457 078c 5F4F      		sbci r21,-1
 2458 078e 6F4F      		sbci r22,-1
 2459 0790 7F4F      		sbci r23,-1
 2460               	/* #APP */
 2461               	 ;  1902 "stk500boot.c" 1
 2462 0792 6BBF      		out 59, r22
 2463 0794 FA01      		movw r30, r20
 2464 0796 1791      		elpm r17, Z+
 2465               		
 2466               	 ;  0 "" 2
 2467               	/* #NOAPP */
 2468 0798 C05E      		subi r28,lo8(-288)
 2469 079a DE4F      		sbci r29,hi8(-288)
 2470 079c 4881      		ld r20,Y
 2471 079e 5981      		ldd r21,Y+1
 2472 07a0 6A81      		ldd r22,Y+2
 2473 07a2 7B81      		ldd r23,Y+3
 2474 07a4 C052      		subi r28,lo8(288)
 2475 07a6 D140      		sbci r29,hi8(288)
 2476 07a8 4C5F      		subi r20,-4
 2477 07aa 5F4F      		sbci r21,-1
 2478 07ac 6F4F      		sbci r22,-1
 2479 07ae 7F4F      		sbci r23,-1
 2480 07b0 C05E      		subi r28,lo8(-288)
 2481 07b2 DE4F      		sbci r29,hi8(-288)
 2482 07b4 4883      		st Y,r20
 2483 07b6 5983      		std Y+1,r21
 2484 07b8 6A83      		std Y+2,r22
 2485 07ba 7B83      		std Y+3,r23
 2486 07bc C052      		subi r28,lo8(288)
 2487 07be D140      		sbci r29,hi8(288)
 2488               	.LVL263:
 2489               	.LBE257:
1909:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
 2490               		.loc 1 1909 0
 2491 07c0 CF5C      		subi r28,lo8(-305)
 2492 07c2 DE4F      		sbci r29,hi8(-305)
 2493 07c4 2881      		ld r18,Y
 2494 07c6 3981      		ldd r19,Y+1
 2495 07c8 4A81      		ldd r20,Y+2
 2496 07ca 5B81      		ldd r21,Y+3
 2497 07cc C153      		subi r28,lo8(305)
 2498 07ce D140      		sbci r29,hi8(305)
 2499 07d0 8824      		clr r8
 2500 07d2 922E      		mov r9,r18
 2501 07d4 A32E      		mov r10,r19
 2502 07d6 B42E      		mov r11,r20
 2503 07d8 8C0C      		add r8,r12
 2504 07da 9D1C      		adc r9,r13
 2505 07dc AE1C      		adc r10,r14
 2506 07de BF1C      		adc r11,r15
 2507               	.LVL264:
1913:stk500boot.c  **** 		sendchar(0x20);
 2508               		.loc 1 1913 0
 2509 07e0 0E94 0000 		call PrintHexByte
 2510               	.LVL265:
1914:stk500boot.c  **** 		PrintHexByte(byte1);
 2511               		.loc 1 1914 0
 2512 07e4 80E2      		ldi r24,lo8(32)
 2513 07e6 0E94 0000 		call sendchar
 2514               	.LVL266:
1915:stk500boot.c  **** 		sendchar(0x20);
 2515               		.loc 1 1915 0
 2516 07ea CB5C      		subi r28,lo8(-309)
 2517 07ec DE4F      		sbci r29,hi8(-309)
 2518 07ee 8881      		ld r24,Y
 2519 07f0 C553      		subi r28,lo8(309)
 2520 07f2 D140      		sbci r29,hi8(309)
 2521 07f4 0E94 0000 		call PrintHexByte
 2522               	.LVL267:
1916:stk500boot.c  **** 		PrintHexByte(byte4);
 2523               		.loc 1 1916 0
 2524 07f8 80E2      		ldi r24,lo8(32)
 2525 07fa 0E94 0000 		call sendchar
 2526               	.LVL268:
1917:stk500boot.c  **** 		sendchar(0x20);
 2527               		.loc 1 1917 0
 2528 07fe 812F      		mov r24,r17
 2529 0800 0E94 0000 		call PrintHexByte
 2530               	.LVL269:
1918:stk500boot.c  **** 		PrintHexByte(byte3);
 2531               		.loc 1 1918 0
 2532 0804 80E2      		ldi r24,lo8(32)
 2533 0806 0E94 0000 		call sendchar
 2534               	.LVL270:
1919:stk500boot.c  **** 		sendchar(0x20);
 2535               		.loc 1 1919 0
 2536 080a CA5C      		subi r28,lo8(-310)
 2537 080c DE4F      		sbci r29,hi8(-310)
 2538 080e 8881      		ld r24,Y
 2539 0810 C653      		subi r28,lo8(310)
 2540 0812 D140      		sbci r29,hi8(310)
 2541 0814 0E94 0000 		call PrintHexByte
 2542               	.LVL271:
1920:stk500boot.c  **** 	
 2543               		.loc 1 1920 0
 2544 0818 80E2      		ldi r24,lo8(32)
 2545 081a 0E94 0000 		call sendchar
 2546               	.LVL272:
1922:stk500boot.c  **** 		{
 2547               		.loc 1 1922 0
 2548 081e 3FEF      		ldi r19,-1
 2549 0820 8316      		cp r8,r19
 2550 0822 9306      		cpc r9,r19
 2551 0824 A104      		cpc r10,__zero_reg__
 2552 0826 B104      		cpc r11,__zero_reg__
 2553 0828 01F4      		brne .L114
1924:stk500boot.c  **** 		}
 2554               		.loc 1 1924 0
 2555 082a 60E0      		ldi r22,0
 2556 082c 80E0      		ldi r24,lo8(gTextMsg_noVector)
 2557 082e 90E0      		ldi r25,hi8(gTextMsg_noVector)
 2558 0830 0E94 0000 		call PrintFromPROGMEM
 2559               	.LVL273:
 2560               	.L115:
1973:stk500boot.c  **** 
 2561               		.loc 1 1973 0
 2562 0834 0E94 0000 		call PrintNewLine
 2563               	.LVL274:
1882:stk500boot.c  **** 	{
 2564               		.loc 1 1882 0
 2565 0838 29E3      		ldi r18,57
 2566 083a 6216      		cp r6,r18
 2567 083c 7104      		cpc r7,__zero_reg__
 2568 083e 01F0      		breq .+2
 2569 0840 00C0      		rjmp .L117
 2570 0842 00C0      		rjmp .L81
 2571               	.LVL275:
 2572               	.L114:
1926:stk500boot.c  **** 		{
 2573               		.loc 1 1926 0
 2574 0844 D501      		movw r26,r10
 2575 0846 C401      		movw r24,r8
 2576 0848 8827      		clr r24
 2577 084a 907C      		andi r25,192
 2578 084c AA27      		clr r26
 2579 084e BB27      		clr r27
 2580 0850 8115      		cp r24,__zero_reg__
 2581 0852 904C      		sbci r25,-64
 2582 0854 A105      		cpc r26,__zero_reg__
 2583 0856 B105      		cpc r27,__zero_reg__
 2584 0858 01F4      		brne .L116
1929:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
 2585               		.loc 1 1929 0
 2586 085a 5FE3      		ldi r21,63
 2587 085c 9522      		and r9,r21
 2588 085e AA24      		clr r10
 2589 0860 BB24      		clr r11
 2590               	.LVL276:
1930:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
 2591               		.loc 1 1930 0
 2592 0862 C35D      		subi r28,lo8(-301)
 2593 0864 DE4F      		sbci r29,hi8(-301)
 2594 0866 C880      		ld r12,Y
 2595 0868 D980      		ldd r13,Y+1
 2596 086a EA80      		ldd r14,Y+2
 2597 086c FB80      		ldd r15,Y+3
 2598 086e CD52      		subi r28,lo8(301)
 2599 0870 D140      		sbci r29,hi8(301)
 2600               	.LVL277:
 2601 0872 C80C      		add r12,r8
 2602 0874 D91C      		adc r13,r9
 2603 0876 EA1C      		adc r14,r10
 2604 0878 FB1C      		adc r15,r11
 2605               	.LVL278:
1931:stk500boot.c  **** 
 2606               		.loc 1 1931 0
 2607 087a CC0C      		lsl r12
 2608 087c DD1C      		rol r13
 2609 087e EE1C      		rol r14
 2610 0880 FF1C      		rol r15
 2611               	.LVL279:
1933:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
 2612               		.loc 1 1933 0
 2613 0882 60E0      		ldi r22,0
 2614 0884 80E0      		ldi r24,lo8(gTextMsg_rjmp)
 2615 0886 90E0      		ldi r25,hi8(gTextMsg_rjmp)
 2616 0888 0E94 0000 		call PrintFromPROGMEM
 2617               	.LVL280:
1934:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
 2618               		.loc 1 1934 0
 2619 088c 892D      		mov r24,r9
 2620 088e 0E94 0000 		call PrintHexByte
 2621               	.LVL281:
1935:stk500boot.c  **** 			sendchar(0x20);
 2622               		.loc 1 1935 0
 2623 0892 882D      		mov r24,r8
 2624 0894 0E94 0000 		call PrintHexByte
 2625               	.LVL282:
1936:stk500boot.c  **** 			sendchar('>');
 2626               		.loc 1 1936 0
 2627 0898 80E2      		ldi r24,lo8(32)
 2628 089a 0E94 0000 		call sendchar
 2629               	.LVL283:
1937:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2630               		.loc 1 1937 0
 2631 089e 8EE3      		ldi r24,lo8(62)
 2632 08a0 0E94 0000 		call sendchar
 2633               	.LVL284:
1938:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2634               		.loc 1 1938 0
 2635 08a4 80E0      		ldi r24,0
 2636 08a6 0E94 0000 		call PrintHexByte
 2637               	.LVL285:
1939:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2638               		.loc 1 1939 0
 2639 08aa 8D2D      		mov r24,r13
 2640 08ac 0E94 0000 		call PrintHexByte
 2641               	.LVL286:
1940:stk500boot.c  **** 	
 2642               		.loc 1 1940 0
 2643 08b0 8C2D      		mov r24,r12
 2644               	.LVL287:
 2645               	.L296:
1961:stk500boot.c  **** 		}
 2646               		.loc 1 1961 0
 2647 08b2 0E94 0000 		call PrintHexByte
 2648               	.LVL288:
 2649 08b6 00C0      		rjmp .L115
 2650               	.LVL289:
 2651               	.L116:
1943:stk500boot.c  **** 		{
 2652               		.loc 1 1943 0
 2653 08b8 6EE0      		ldi r22,14
 2654 08ba 8622      		and r8,r22
 2655 08bc E894      		clt
 2656 08be 90F8      		bld r9,0
 2657 08c0 AA24      		clr r10
 2658 08c2 BB24      		clr r11
 2659               	.LVL290:
 2660 08c4 7CE0      		ldi r23,12
 2661 08c6 8716      		cp r8,r23
 2662 08c8 74E9      		ldi r23,-108
 2663 08ca 9706      		cpc r9,r23
 2664 08cc A104      		cpc r10,__zero_reg__
 2665 08ce B104      		cpc r11,__zero_reg__
 2666 08d0 01F0      		breq .+2
 2667 08d2 00C0      		rjmp .L115
1902:stk500boot.c  **** 	#else
 2668               		.loc 1 1902 0
 2669 08d4 812F      		mov r24,r17
 2670 08d6 90E0      		ldi r25,0
 2671 08d8 B0E0      		ldi r27,0
 2672 08da A0E0      		ldi r26,0
1910:stk500boot.c  **** 
 2673               		.loc 1 1910 0
 2674 08dc BA2F      		mov r27,r26
 2675 08de A92F      		mov r26,r25
 2676 08e0 982F      		mov r25,r24
 2677 08e2 8827      		clr r24
 2678 08e4 CA5C      		subi r28,lo8(-310)
 2679 08e6 DE4F      		sbci r29,hi8(-310)
 2680 08e8 E881      		ld r30,Y
 2681 08ea C653      		subi r28,lo8(310)
 2682 08ec D140      		sbci r29,hi8(310)
 2683 08ee 8E0F      		add r24,r30
 2684 08f0 911D      		adc r25,__zero_reg__
 2685 08f2 A11D      		adc r26,__zero_reg__
 2686 08f4 B11D      		adc r27,__zero_reg__
1948:stk500boot.c  **** 								word2;
 2687               		.loc 1 1948 0
 2688 08f6 CF5C      		subi r28,lo8(-305)
 2689 08f8 DE4F      		sbci r29,hi8(-305)
 2690 08fa 4881      		ld r20,Y
 2691 08fc 5981      		ldd r21,Y+1
 2692 08fe 6A81      		ldd r22,Y+2
 2693 0900 7B81      		ldd r23,Y+3
 2694 0902 C153      		subi r28,lo8(305)
 2695 0904 D140      		sbci r29,hi8(305)
 2696 0906 E5E1      		ldi r30,21
 2697               		1:
 2698 0908 440F      		lsl r20
 2699 090a 551F      		rol r21
 2700 090c 661F      		rol r22
 2701 090e 771F      		rol r23
 2702 0910 EA95      		dec r30
 2703 0912 01F4      		brne 1b
 2704 0914 4427      		clr r20
 2705 0916 5527      		clr r21
 2706 0918 6072      		andi r22,32
 2707 091a 7727      		clr r23
1946:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2708               		.loc 1 1946 0
 2709 091c 840F      		add r24,r20
 2710 091e 951F      		adc r25,r21
 2711 0920 A61F      		adc r26,r22
 2712 0922 B71F      		adc r27,r23
 2713 0924 B601      		movw r22,r12
 2714 0926 5527      		clr r21
 2715 0928 4427      		clr r20
 2716 092a 4427      		clr r20
 2717 092c 5527      		clr r21
 2718 092e 6170      		andi r22,1
 2719 0930 7727      		clr r23
1947:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
 2720               		.loc 1 1947 0
 2721 0932 11E1      		ldi r17,17
 2722               		1:
 2723 0934 CC0C      		lsl r12
 2724 0936 DD1C      		rol r13
 2725 0938 EE1C      		rol r14
 2726 093a FF1C      		rol r15
 2727 093c 1A95      		dec r17
 2728 093e 01F4      		brne 1b
 2729               	.LVL291:
 2730 0940 CC24      		clr r12
 2731 0942 DD24      		clr r13
 2732 0944 F0EE      		ldi r31,224
 2733 0946 EF22      		and r14,r31
 2734 0948 F1E0      		ldi r31,1
 2735 094a FF22      		and r15,r31
1946:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2736               		.loc 1 1946 0
 2737 094c C42A      		or r12,r20
 2738 094e D52A      		or r13,r21
 2739 0950 E62A      		or r14,r22
 2740 0952 F72A      		or r15,r23
 2741 0954 C80E      		add r12,r24
 2742 0956 D91E      		adc r13,r25
 2743 0958 EA1E      		adc r14,r26
 2744 095a FB1E      		adc r15,r27
 2745               	.LVL292:
1951:stk500boot.c  **** 							
 2746               		.loc 1 1951 0
 2747 095c 4601      		movw r8,r12
 2748 095e 5701      		movw r10,r14
 2749 0960 880C      		lsl r8
 2750 0962 991C      		rol r9
 2751 0964 AA1C      		rol r10
 2752 0966 BB1C      		rol r11
1953:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
 2753               		.loc 1 1953 0
 2754 0968 60E0      		ldi r22,0
 2755 096a 80E0      		ldi r24,lo8(gTextMsg_jmp)
 2756 096c 90E0      		ldi r25,hi8(gTextMsg_jmp)
 2757 096e 0E94 0000 		call PrintFromPROGMEM
 2758               	.LVL293:
1954:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
 2759               		.loc 1 1954 0
 2760 0972 8E2D      		mov r24,r14
 2761 0974 0E94 0000 		call PrintHexByte
 2762               	.LVL294:
1955:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
 2763               		.loc 1 1955 0
 2764 0978 8D2D      		mov r24,r13
 2765 097a 0E94 0000 		call PrintHexByte
 2766               	.LVL295:
1956:stk500boot.c  **** 			sendchar(0x20);
 2767               		.loc 1 1956 0
 2768 097e 8C2D      		mov r24,r12
 2769 0980 0E94 0000 		call PrintHexByte
 2770               	.LVL296:
1957:stk500boot.c  **** 			sendchar('>');
 2771               		.loc 1 1957 0
 2772 0984 80E2      		ldi r24,lo8(32)
 2773 0986 0E94 0000 		call sendchar
 2774               	.LVL297:
1958:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2775               		.loc 1 1958 0
 2776 098a 8EE3      		ldi r24,lo8(62)
 2777 098c 0E94 0000 		call sendchar
 2778               	.LVL298:
1959:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2779               		.loc 1 1959 0
 2780 0990 8A2D      		mov r24,r10
 2781 0992 0E94 0000 		call PrintHexByte
 2782               	.LVL299:
1960:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2783               		.loc 1 1960 0
 2784 0996 892D      		mov r24,r9
 2785 0998 0E94 0000 		call PrintHexByte
 2786               	.LVL300:
1961:stk500boot.c  **** 		}
 2787               		.loc 1 1961 0
 2788 099c 882D      		mov r24,r8
 2789 099e 00C0      		rjmp .L296
 2790               	.LVL301:
 2791               	.L96:
 2792               	.LBE251:
 2793               	.LBE250:
2343:stk500boot.c  **** 				AVR_PortOutput();
 2794               		.loc 1 2343 0
 2795 09a0 62E0      		ldi r22,lo8(2)
 2796 09a2 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 2797 09a4 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 2798 09a6 0E94 0000 		call PrintFromPROGMEMln
 2799               	.LVL302:
 2800               	.LBB258:
 2801               	.LBB259:
2047:stk500boot.c  **** 
 2802               		.loc 1 2047 0
 2803 09aa 60E0      		ldi r22,0
 2804 09ac 80E0      		ldi r24,lo8(gTextMsg_WHAT_PORT)
 2805 09ae 90E0      		ldi r25,hi8(gTextMsg_WHAT_PORT)
 2806 09b0 0E94 0000 		call PrintFromPROGMEM
 2807               	.LVL303:
2049:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
 2808               		.loc 1 2049 0
 2809 09b4 0E94 0000 		call recchar
 2810               	.LVL304:
2050:stk500boot.c  **** 	sendchar(portLetter);
 2811               		.loc 1 2050 0
 2812 09b8 182F      		mov r17,r24
 2813               	.LVL305:
 2814 09ba 1F75      		andi r17,lo8(95)
 2815               	.LVL306:
2051:stk500boot.c  **** 	PrintNewLine();
 2816               		.loc 1 2051 0
 2817 09bc 812F      		mov r24,r17
 2818 09be 0E94 0000 		call sendchar
 2819               	.LVL307:
2052:stk500boot.c  **** 
 2820               		.loc 1 2052 0
 2821 09c2 0E94 0000 		call PrintNewLine
 2822               	.LVL308:
2054:stk500boot.c  **** 	{
 2823               		.loc 1 2054 0
 2824 09c6 8FEB      		ldi r24,lo8(-65)
 2825 09c8 810F      		add r24,r17
 2826 09ca 8A31      		cpi r24,lo8(26)
 2827 09cc 00F0      		brlo .+2
 2828 09ce 00C0      		rjmp .L119
 2829               	.LVL309:
2057:stk500boot.c  **** 		{
 2830               		.loc 1 2057 0
 2831 09d0 1634      		cpi r17,lo8(70)
 2832 09d2 01F4      		brne .+2
 2833 09d4 00C0      		rjmp .L121
 2834 09d6 00F4      		brsh .L122
 2835 09d8 1334      		cpi r17,lo8(67)
 2836 09da 01F4      		brne .+2
 2837 09dc 00C0      		rjmp .L123
 2838 09de 00F4      		brsh .L124
 2839 09e0 1134      		cpi r17,lo8(65)
 2840 09e2 01F0      		breq .L125
 2841 09e4 1234      		cpi r17,lo8(66)
 2842 09e6 01F4      		brne .+2
 2843 09e8 00C0      		rjmp .L126
 2844               	.L120:
2204:stk500boot.c  **** 				getCharFlag	=	false;
 2845               		.loc 1 2204 0
 2846 09ea 60E0      		ldi r22,0
 2847 09ec 80E0      		ldi r24,lo8(gTextMsg_PortNotSupported)
 2848 09ee 90E0      		ldi r25,hi8(gTextMsg_PortNotSupported)
 2849 09f0 00C0      		rjmp .L297
 2850               	.L124:
2057:stk500boot.c  **** 		{
 2851               		.loc 1 2057 0
 2852 09f2 1434      		cpi r17,lo8(68)
 2853 09f4 01F4      		brne .+2
 2854 09f6 00C0      		rjmp .L127
 2855 09f8 1534      		cpi r17,lo8(69)
 2856 09fa 01F4      		brne .L120
2109:stk500boot.c  **** 				while (!Serial_Available())
 2857               		.loc 1 2109 0
 2858 09fc 0DB9      		out 0xd,r16
 2859               	.L144:
 2860               	.LBB260:
 2861               	.LBB261:
 476:stk500boot.c  **** }
 2862               		.loc 1 476 0
 2863 09fe 8091 C000 		lds r24,192
 2864               	.LBE261:
 2865               	.LBE260:
2110:stk500boot.c  **** 				{
 2866               		.loc 1 2110 0
 2867 0a02 87FF      		sbrs r24,7
 2868 0a04 00C0      		rjmp .L145
2115:stk500boot.c  **** 				break;
 2869               		.loc 1 2115 0
 2870 0a06 1EB8      		out 0xe,__zero_reg__
 2871 0a08 00C0      		rjmp .L137
 2872               	.L122:
2057:stk500boot.c  **** 		{
 2873               		.loc 1 2057 0
 2874 0a0a 1A34      		cpi r17,lo8(74)
 2875 0a0c 01F4      		brne .+2
 2876 0a0e 00C0      		rjmp .L129
 2877 0a10 00F4      		brsh .L130
 2878 0a12 1734      		cpi r17,lo8(71)
 2879 0a14 01F4      		brne .+2
 2880 0a16 00C0      		rjmp .L131
 2881 0a18 1834      		cpi r17,lo8(72)
 2882 0a1a 01F4      		brne .L120
2145:stk500boot.c  **** 				while (!Serial_Available())
 2883               		.loc 1 2145 0
 2884 0a1c 0093 0101 		sts 257,r16
 2885               	.L150:
 2886               	.LBB262:
 2887               	.LBB263:
 476:stk500boot.c  **** }
 2888               		.loc 1 476 0
 2889 0a20 8091 C000 		lds r24,192
 2890               	.LBE263:
 2891               	.LBE262:
2146:stk500boot.c  **** 				{
 2892               		.loc 1 2146 0
 2893 0a24 87FF      		sbrs r24,7
 2894 0a26 00C0      		rjmp .L151
2151:stk500boot.c  **** 				break;
 2895               		.loc 1 2151 0
 2896 0a28 1092 0201 		sts 258,__zero_reg__
 2897 0a2c 00C0      		rjmp .L137
 2898               	.L130:
2057:stk500boot.c  **** 		{
 2899               		.loc 1 2057 0
 2900 0a2e 1B34      		cpi r17,lo8(75)
 2901 0a30 01F4      		brne .+2
 2902 0a32 00C0      		rjmp .L133
 2903 0a34 1C34      		cpi r17,lo8(76)
 2904 0a36 01F4      		brne .L120
2193:stk500boot.c  **** 				while (!Serial_Available())
 2905               		.loc 1 2193 0
 2906 0a38 0093 0A01 		sts 266,r16
 2907               	.L156:
 2908               	.LBB264:
 2909               	.LBB265:
 476:stk500boot.c  **** }
 2910               		.loc 1 476 0
 2911 0a3c 8091 C000 		lds r24,192
 2912               	.LBE265:
 2913               	.LBE264:
2194:stk500boot.c  **** 				{
 2914               		.loc 1 2194 0
 2915 0a40 87FF      		sbrs r24,7
 2916 0a42 00C0      		rjmp .L157
2199:stk500boot.c  **** 				break;
 2917               		.loc 1 2199 0
 2918 0a44 1092 0B01 		sts 267,__zero_reg__
 2919 0a48 00C0      		rjmp .L137
 2920               	.L125:
2061:stk500boot.c  **** 				while (!Serial_Available())
 2921               		.loc 1 2061 0
 2922 0a4a 01B9      		out 0x1,r16
 2923               	.L135:
 2924               	.LBB266:
 2925               	.LBB267:
 476:stk500boot.c  **** }
 2926               		.loc 1 476 0
 2927 0a4c 8091 C000 		lds r24,192
 2928               	.LBE267:
 2929               	.LBE266:
2062:stk500boot.c  **** 				{
 2930               		.loc 1 2062 0
 2931 0a50 87FF      		sbrs r24,7
 2932 0a52 00C0      		rjmp .L136
2067:stk500boot.c  **** 				break;
 2933               		.loc 1 2067 0
 2934 0a54 12B8      		out 0x2,__zero_reg__
 2935 0a56 00C0      		rjmp .L137
 2936               	.L136:
2064:stk500boot.c  **** 					delay_ms(200);
 2937               		.loc 1 2064 0
 2938 0a58 82B1      		in r24,0x2
 2939 0a5a 8095      		com r24
 2940 0a5c 82B9      		out 0x2,r24
2065:stk500boot.c  **** 				}
 2941               		.loc 1 2065 0
 2942 0a5e 88EC      		ldi r24,lo8(-56)
 2943 0a60 90E0      		ldi r25,0
 2944 0a62 0E94 0000 		call delay_ms
 2945               	.LVL310:
 2946 0a66 00C0      		rjmp .L135
 2947               	.L126:
2073:stk500boot.c  **** 				while (!Serial_Available())
 2948               		.loc 1 2073 0
 2949 0a68 04B9      		out 0x4,r16
 2950               	.L138:
 2951               	.LBB268:
 2952               	.LBB269:
 476:stk500boot.c  **** }
 2953               		.loc 1 476 0
 2954 0a6a 8091 C000 		lds r24,192
 2955               	.LBE269:
 2956               	.LBE268:
2074:stk500boot.c  **** 				{
 2957               		.loc 1 2074 0
 2958 0a6e 87FF      		sbrs r24,7
 2959 0a70 00C0      		rjmp .L139
2079:stk500boot.c  **** 				break;
 2960               		.loc 1 2079 0
 2961 0a72 15B8      		out 0x5,__zero_reg__
 2962 0a74 00C0      		rjmp .L137
 2963               	.L139:
2076:stk500boot.c  **** 					delay_ms(200);
 2964               		.loc 1 2076 0
 2965 0a76 85B1      		in r24,0x5
 2966 0a78 8095      		com r24
 2967 0a7a 85B9      		out 0x5,r24
2077:stk500boot.c  **** 				}
 2968               		.loc 1 2077 0
 2969 0a7c 88EC      		ldi r24,lo8(-56)
 2970 0a7e 90E0      		ldi r25,0
 2971 0a80 0E94 0000 		call delay_ms
 2972               	.LVL311:
 2973 0a84 00C0      		rjmp .L138
 2974               	.L123:
2085:stk500boot.c  **** 				while (!Serial_Available())
 2975               		.loc 1 2085 0
 2976 0a86 07B9      		out 0x7,r16
 2977               	.L140:
 2978               	.LBB270:
 2979               	.LBB271:
 476:stk500boot.c  **** }
 2980               		.loc 1 476 0
 2981 0a88 8091 C000 		lds r24,192
 2982               	.LBE271:
 2983               	.LBE270:
2086:stk500boot.c  **** 				{
 2984               		.loc 1 2086 0
 2985 0a8c 87FF      		sbrs r24,7
 2986 0a8e 00C0      		rjmp .L141
2091:stk500boot.c  **** 				break;
 2987               		.loc 1 2091 0
 2988 0a90 18B8      		out 0x8,__zero_reg__
 2989 0a92 00C0      		rjmp .L137
 2990               	.L141:
2088:stk500boot.c  **** 					delay_ms(200);
 2991               		.loc 1 2088 0
 2992 0a94 88B1      		in r24,0x8
 2993 0a96 8095      		com r24
 2994 0a98 88B9      		out 0x8,r24
2089:stk500boot.c  **** 				}
 2995               		.loc 1 2089 0
 2996 0a9a 88EC      		ldi r24,lo8(-56)
 2997 0a9c 90E0      		ldi r25,0
 2998 0a9e 0E94 0000 		call delay_ms
 2999               	.LVL312:
 3000 0aa2 00C0      		rjmp .L140
 3001               	.L127:
2097:stk500boot.c  **** 				while (!Serial_Available())
 3002               		.loc 1 2097 0
 3003 0aa4 0AB9      		out 0xa,r16
 3004               	.L142:
 3005               	.LBB272:
 3006               	.LBB273:
 476:stk500boot.c  **** }
 3007               		.loc 1 476 0
 3008 0aa6 8091 C000 		lds r24,192
 3009               	.LBE273:
 3010               	.LBE272:
2098:stk500boot.c  **** 				{
 3011               		.loc 1 2098 0
 3012 0aaa 87FF      		sbrs r24,7
 3013 0aac 00C0      		rjmp .L143
2103:stk500boot.c  **** 				break;
 3014               		.loc 1 2103 0
 3015 0aae 1BB8      		out 0xb,__zero_reg__
 3016 0ab0 00C0      		rjmp .L137
 3017               	.L143:
2100:stk500boot.c  **** 					delay_ms(200);
 3018               		.loc 1 2100 0
 3019 0ab2 8BB1      		in r24,0xb
 3020 0ab4 8095      		com r24
 3021 0ab6 8BB9      		out 0xb,r24
2101:stk500boot.c  **** 				}
 3022               		.loc 1 2101 0
 3023 0ab8 88EC      		ldi r24,lo8(-56)
 3024 0aba 90E0      		ldi r25,0
 3025 0abc 0E94 0000 		call delay_ms
 3026               	.LVL313:
 3027 0ac0 00C0      		rjmp .L142
 3028               	.L145:
2112:stk500boot.c  **** 					delay_ms(200);
 3029               		.loc 1 2112 0
 3030 0ac2 8EB1      		in r24,0xe
 3031 0ac4 8095      		com r24
 3032 0ac6 8EB9      		out 0xe,r24
2113:stk500boot.c  **** 				}
 3033               		.loc 1 2113 0
 3034 0ac8 88EC      		ldi r24,lo8(-56)
 3035 0aca 90E0      		ldi r25,0
 3036 0acc 0E94 0000 		call delay_ms
 3037               	.LVL314:
 3038 0ad0 00C0      		rjmp .L144
 3039               	.L121:
2121:stk500boot.c  **** 				while (!Serial_Available())
 3040               		.loc 1 2121 0
 3041 0ad2 00BB      		out 0x10,r16
 3042               	.L146:
 3043               	.LBB274:
 3044               	.LBB275:
 476:stk500boot.c  **** }
 3045               		.loc 1 476 0
 3046 0ad4 8091 C000 		lds r24,192
 3047               	.LBE275:
 3048               	.LBE274:
2122:stk500boot.c  **** 				{
 3049               		.loc 1 2122 0
 3050 0ad8 87FF      		sbrs r24,7
 3051 0ada 00C0      		rjmp .L147
2127:stk500boot.c  **** 				break;
 3052               		.loc 1 2127 0
 3053 0adc 11BA      		out 0x11,__zero_reg__
 3054 0ade 00C0      		rjmp .L137
 3055               	.L147:
2124:stk500boot.c  **** 					delay_ms(200);
 3056               		.loc 1 2124 0
 3057 0ae0 81B3      		in r24,0x11
 3058 0ae2 8095      		com r24
 3059 0ae4 81BB      		out 0x11,r24
2125:stk500boot.c  **** 				}
 3060               		.loc 1 2125 0
 3061 0ae6 88EC      		ldi r24,lo8(-56)
 3062 0ae8 90E0      		ldi r25,0
 3063 0aea 0E94 0000 		call delay_ms
 3064               	.LVL315:
 3065 0aee 00C0      		rjmp .L146
 3066               	.L131:
2133:stk500boot.c  **** 				while (!Serial_Available())
 3067               		.loc 1 2133 0
 3068 0af0 03BB      		out 0x13,r16
 3069               	.L148:
 3070               	.LBB276:
 3071               	.LBB277:
 476:stk500boot.c  **** }
 3072               		.loc 1 476 0
 3073 0af2 8091 C000 		lds r24,192
 3074               	.LBE277:
 3075               	.LBE276:
2134:stk500boot.c  **** 				{
 3076               		.loc 1 2134 0
 3077 0af6 87FF      		sbrs r24,7
 3078 0af8 00C0      		rjmp .L149
2139:stk500boot.c  **** 				break;
 3079               		.loc 1 2139 0
 3080 0afa 14BA      		out 0x14,__zero_reg__
 3081 0afc 00C0      		rjmp .L137
 3082               	.L149:
2136:stk500boot.c  **** 					delay_ms(200);
 3083               		.loc 1 2136 0
 3084 0afe 84B3      		in r24,0x14
 3085 0b00 8095      		com r24
 3086 0b02 84BB      		out 0x14,r24
2137:stk500boot.c  **** 				}
 3087               		.loc 1 2137 0
 3088 0b04 88EC      		ldi r24,lo8(-56)
 3089 0b06 90E0      		ldi r25,0
 3090 0b08 0E94 0000 		call delay_ms
 3091               	.LVL316:
 3092 0b0c 00C0      		rjmp .L148
 3093               	.L151:
2148:stk500boot.c  **** 					delay_ms(200);
 3094               		.loc 1 2148 0
 3095 0b0e 8091 0201 		lds r24,258
 3096 0b12 8095      		com r24
 3097 0b14 8093 0201 		sts 258,r24
2149:stk500boot.c  **** 				}
 3098               		.loc 1 2149 0
 3099 0b18 88EC      		ldi r24,lo8(-56)
 3100 0b1a 90E0      		ldi r25,0
 3101 0b1c 0E94 0000 		call delay_ms
 3102               	.LVL317:
 3103 0b20 00C0      		rjmp .L150
 3104               	.L129:
2169:stk500boot.c  **** 				while (!Serial_Available())
 3105               		.loc 1 2169 0
 3106 0b22 0093 0401 		sts 260,r16
 3107               	.L152:
 3108               	.LBB278:
 3109               	.LBB279:
 476:stk500boot.c  **** }
 3110               		.loc 1 476 0
 3111 0b26 8091 C000 		lds r24,192
 3112               	.LBE279:
 3113               	.LBE278:
2170:stk500boot.c  **** 				{
 3114               		.loc 1 2170 0
 3115 0b2a 87FF      		sbrs r24,7
 3116 0b2c 00C0      		rjmp .L153
2175:stk500boot.c  **** 				break;
 3117               		.loc 1 2175 0
 3118 0b2e 1092 0501 		sts 261,__zero_reg__
 3119 0b32 00C0      		rjmp .L137
 3120               	.L153:
2172:stk500boot.c  **** 					delay_ms(200);
 3121               		.loc 1 2172 0
 3122 0b34 8091 0501 		lds r24,261
 3123 0b38 8095      		com r24
 3124 0b3a 8093 0501 		sts 261,r24
2173:stk500boot.c  **** 				}
 3125               		.loc 1 2173 0
 3126 0b3e 88EC      		ldi r24,lo8(-56)
 3127 0b40 90E0      		ldi r25,0
 3128 0b42 0E94 0000 		call delay_ms
 3129               	.LVL318:
 3130 0b46 00C0      		rjmp .L152
 3131               	.L133:
2181:stk500boot.c  **** 				while (!Serial_Available())
 3132               		.loc 1 2181 0
 3133 0b48 0093 0701 		sts 263,r16
 3134               	.L154:
 3135               	.LBB280:
 3136               	.LBB281:
 476:stk500boot.c  **** }
 3137               		.loc 1 476 0
 3138 0b4c 8091 C000 		lds r24,192
 3139               	.LBE281:
 3140               	.LBE280:
2182:stk500boot.c  **** 				{
 3141               		.loc 1 2182 0
 3142 0b50 87FF      		sbrs r24,7
 3143 0b52 00C0      		rjmp .L155
2187:stk500boot.c  **** 				break;
 3144               		.loc 1 2187 0
 3145 0b54 1092 0801 		sts 264,__zero_reg__
 3146 0b58 00C0      		rjmp .L137
 3147               	.L155:
2184:stk500boot.c  **** 					delay_ms(200);
 3148               		.loc 1 2184 0
 3149 0b5a 8091 0801 		lds r24,264
 3150 0b5e 8095      		com r24
 3151 0b60 8093 0801 		sts 264,r24
2185:stk500boot.c  **** 				}
 3152               		.loc 1 2185 0
 3153 0b64 88EC      		ldi r24,lo8(-56)
 3154 0b66 90E0      		ldi r25,0
 3155 0b68 0E94 0000 		call delay_ms
 3156               	.LVL319:
 3157 0b6c 00C0      		rjmp .L154
 3158               	.L157:
2196:stk500boot.c  **** 					delay_ms(200);
 3159               		.loc 1 2196 0
 3160 0b6e 8091 0B01 		lds r24,267
 3161 0b72 8095      		com r24
 3162 0b74 8093 0B01 		sts 267,r24
2197:stk500boot.c  **** 				}
 3163               		.loc 1 2197 0
 3164 0b78 88EC      		ldi r24,lo8(-56)
 3165 0b7a 90E0      		ldi r25,0
 3166 0b7c 0E94 0000 		call delay_ms
 3167               	.LVL320:
 3168 0b80 00C0      		rjmp .L156
 3169               	.LVL321:
 3170               	.L119:
2215:stk500boot.c  **** 	}
 3171               		.loc 1 2215 0
 3172 0b82 60E0      		ldi r22,0
 3173 0b84 80E0      		ldi r24,lo8(gTextMsg_MustBeLetter)
 3174 0b86 90E0      		ldi r25,hi8(gTextMsg_MustBeLetter)
 3175 0b88 00C0      		rjmp .L297
 3176               	.LVL322:
 3177               	.L76:
 3178               	.LBE259:
 3179               	.LBE258:
 3180               	.LBE284:
 3181               	.LBE286:
 922:stk500boot.c  **** 				{
 3182               		.loc 1 922 0
 3183 0b8a 8330      		cpi r24,lo8(3)
 3184 0b8c 01F4      		brne .+2
 3185 0b8e 00C0      		rjmp .L225
 3186 0b90 00F4      		brsh .L162
 3187 0b92 8130      		cpi r24,lo8(1)
 3188 0b94 01F4      		brne .+2
 3189 0b96 00C0      		rjmp .L223
 3190 0b98 00F0      		brlo .L292
 918:stk500boot.c  **** 				}
 3191               		.loc 1 918 0
 3192 0b9a F12C      		mov r15,__zero_reg__
 3193 0b9c E12C      		mov r14,__zero_reg__
 3194               	.LVL323:
 3195               	.L164:
 952:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 3196               		.loc 1 952 0
 3197 0b9e 292F      		mov r18,r25
 3198               	.LVL324:
 3199 0ba0 30E0      		ldi r19,0
 3200 0ba2 322F      		mov r19,r18
 3201 0ba4 2227      		clr r18
 3202               	.LVL325:
 954:stk500boot.c  **** 						break;
 3203               		.loc 1 954 0
 3204 0ba6 C926      		eor r12,r25
 3205               	.LVL326:
 953:stk500boot.c  **** 						checksum		^=	c;
 3206               		.loc 1 953 0
 3207 0ba8 83E0      		ldi r24,lo8(3)
 955:stk500boot.c  **** 
 3208               		.loc 1 955 0
 3209 0baa 00C0      		rjmp .L170
 3210               	.LVL327:
 3211               	.L162:
 922:stk500boot.c  **** 				{
 3212               		.loc 1 922 0
 3213 0bac 8530      		cpi r24,lo8(5)
 3214 0bae 01F4      		brne .+2
 3215 0bb0 00C0      		rjmp .L227
 3216 0bb2 00F4      		brsh .+2
 3217 0bb4 00C0      		rjmp .L226
 918:stk500boot.c  **** 				}
 3218               		.loc 1 918 0
 3219 0bb6 F12C      		mov r15,__zero_reg__
 3220 0bb8 E12C      		mov r14,__zero_reg__
 922:stk500boot.c  **** 				{
 3221               		.loc 1 922 0
 3222 0bba 8630      		cpi r24,lo8(6)
 3223 0bbc 01F4      		brne .+2
 3224 0bbe 00C0      		rjmp .L168
 918:stk500boot.c  **** 				}
 3225               		.loc 1 918 0
 3226 0bc0 F12C      		mov r15,__zero_reg__
 3227 0bc2 E12C      		mov r14,__zero_reg__
 3228               	.LVL328:
 3229               	.L160:
 887:stk500boot.c  **** 			{
 3230               		.loc 1 887 0
 3231 0bc4 8730      		cpi r24,lo8(7)
 3232 0bc6 01F4      		brne .L170
 3233               	.LVL329:
 3234               	.L232:
 3235 0bc8 D12C      		mov r13,__zero_reg__
 3236 0bca 00C0      		rjmp .L113
 3237               	.LVL330:
 3238               	.L292:
 918:stk500boot.c  **** 				}
 3239               		.loc 1 918 0
 3240 0bcc F12C      		mov r15,__zero_reg__
 3241 0bce E12C      		mov r14,__zero_reg__
 925:stk500boot.c  **** 						{
 3242               		.loc 1 925 0
 3243 0bd0 9B31      		cpi r25,lo8(27)
 3244 0bd2 01F4      		brne .+2
 3245 0bd4 00C0      		rjmp .L229
 3246               	.LVL331:
 3247               	.L170:
 731:stk500boot.c  **** 	address_t		address			=	0;
 3248               		.loc 1 731 0
 3249 0bd6 50E0      		ldi r21,0
 3250 0bd8 40E0      		ldi r20,0
 3251               	.LVL332:
 3252               	.L217:
 889:stk500boot.c  **** 				{
 3253               		.loc 1 889 0
 3254 0bda 4130      		cpi r20,1
 3255 0bdc 5105      		cpc r21,__zero_reg__
 3256 0bde 01F0      		breq .+2
 3257 0be0 00C0      		rjmp .L74
 3258               	.LVL333:
 3259               	.L295:
 3260               	.LBB287:
 3261               	.LBB224:
 522:stk500boot.c  **** }
 3262               		.loc 1 522 0
 3263 0be2 9091 C600 		lds r25,198
 3264               	.LVL334:
 3265               	.LBE224:
 3266               	.LBE287:
 902:stk500boot.c  **** 
 3267               		.loc 1 902 0
 3268 0be6 C55D      		subi r28,lo8(-299)
 3269 0be8 DE4F      		sbci r29,hi8(-299)
 3270 0bea A881      		ld r26,Y
 3271 0bec B981      		ldd r27,Y+1
 3272 0bee CB52      		subi r28,lo8(299)
 3273 0bf0 D140      		sbci r29,hi8(299)
 3274 0bf2 1196      		adiw r26,1
 3275 0bf4 C55D      		subi r28,lo8(-299)
 3276 0bf6 DE4F      		sbci r29,hi8(-299)
 3277 0bf8 B983      		std Y+1,r27
 3278 0bfa A883      		st Y,r26
 3279 0bfc CB52      		subi r28,lo8(299)
 3280 0bfe D140      		sbci r29,hi8(299)
 3281               	.LVL335:
 904:stk500boot.c  **** 				{
 3282               		.loc 1 904 0
 3283 0c00 9132      		cpi r25,lo8(33)
 3284 0c02 01F4      		brne .L76
 904:stk500boot.c  **** 				{
 3285               		.loc 1 904 0 is_stmt 0 discriminator 1
 3286 0c04 1A97      		sbiw r26,10
 3287 0c06 00F0      		brlo .+2
 3288 0c08 00C0      		rjmp .L220
 906:stk500boot.c  **** 					if (exPointCntr == 3)
 3289               		.loc 1 906 0 is_stmt 1
 3290 0c0a BFEF      		ldi r27,-1
 3291 0c0c EB1A      		sub r14,r27
 3292 0c0e FB0A      		sbc r15,r27
 3293               	.LVL336:
 907:stk500boot.c  **** 					{
 3294               		.loc 1 907 0
 3295 0c10 E3E0      		ldi r30,3
 3296 0c12 EE16      		cp r14,r30
 3297 0c14 F104      		cpc r15,__zero_reg__
 3298 0c16 01F0      		breq .+2
 3299 0c18 00C0      		rjmp .L77
 3300 0c1a E5E0      		ldi r30,lo8(5)
 3301 0c1c EE2E      		mov r14,r30
 3302 0c1e F12C      		mov r15,__zero_reg__
 3303               	.LVL337:
 3304               	.L78:
 731:stk500boot.c  **** 	address_t		address			=	0;
 3305               		.loc 1 731 0
 3306 0c20 09E1      		ldi r16,lo8(25)
 3307 0c22 10E0      		ldi r17,0
 3308               	.LVL338:
 3309               	.L79:
 3310               	.LBB288:
 3311               	.LBB285:
2249:stk500boot.c  **** 		}
 3312               		.loc 1 2249 0
 3313 0c24 81E2      		ldi r24,lo8(33)
 3314 0c26 0E94 0000 		call sendchar
 3315               	.LVL339:
 3316 0c2a 0150      		subi r16,1
 3317 0c2c 1109      		sbc r17,__zero_reg__
 3318               	.LVL340:
2247:stk500boot.c  **** 		{
 3319               		.loc 1 2247 0
 3320 0c2e 01F4      		brne .L79
2251:stk500boot.c  **** 	}
 3321               		.loc 1 2251 0
 3322 0c30 0E94 0000 		call PrintNewLine
 3323               	.LVL341:
 3324 0c34 F1E0      		ldi r31,1
 3325 0c36 EF1A      		sub r14,r31
 3326 0c38 F108      		sbc r15,__zero_reg__
 3327               	.LVL342:
2245:stk500boot.c  **** 	{
 3328               		.loc 1 2245 0
 3329 0c3a 01F4      		brne .L78
2254:stk500boot.c  **** 	gFlashIndex			=	0;
 3330               		.loc 1 2254 0
 3331 0c3c 1092 0000 		sts gRamIndex,__zero_reg__
 3332 0c40 1092 0000 		sts gRamIndex+1,__zero_reg__
 3333 0c44 1092 0000 		sts gRamIndex+2,__zero_reg__
 3334 0c48 1092 0000 		sts gRamIndex+3,__zero_reg__
2255:stk500boot.c  **** 	gEepromIndex		=	0;
 3335               		.loc 1 2255 0
 3336 0c4c 1092 0000 		sts gFlashIndex,__zero_reg__
 3337 0c50 1092 0000 		sts gFlashIndex+1,__zero_reg__
 3338 0c54 1092 0000 		sts gFlashIndex+2,__zero_reg__
 3339 0c58 1092 0000 		sts gFlashIndex+3,__zero_reg__
2256:stk500boot.c  **** 
 3340               		.loc 1 2256 0
 3341 0c5c 1092 0000 		sts gEepromIndex,__zero_reg__
 3342 0c60 1092 0000 		sts gEepromIndex+1,__zero_reg__
 3343 0c64 1092 0000 		sts gEepromIndex+2,__zero_reg__
 3344 0c68 1092 0000 		sts gEepromIndex+3,__zero_reg__
2258:stk500boot.c  **** 
 3345               		.loc 1 2258 0
 3346 0c6c 60E0      		ldi r22,0
 3347 0c6e 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 3348 0c70 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 3349 0c72 0E94 0000 		call PrintFromPROGMEMln
 3350               	.LVL343:
 3351               	.LBB283:
 3352               	.LBB282:
2121:stk500boot.c  **** 				while (!Serial_Available())
 3353               		.loc 1 2121 0
 3354 0c76 0FEF      		ldi r16,lo8(-1)
 3355               	.LVL344:
 3356               	.L81:
 3357               	.LBE282:
 3358               	.LBE283:
2263:stk500boot.c  **** 		theChar	=	recchar();
 3359               		.loc 1 2263 0
 3360 0c78 60E0      		ldi r22,0
 3361 0c7a 80E0      		ldi r24,lo8(gTextMsg_Prompt)
 3362 0c7c 90E0      		ldi r25,hi8(gTextMsg_Prompt)
 3363 0c7e 0E94 0000 		call PrintFromPROGMEM
 3364               	.LVL345:
2264:stk500boot.c  **** 		if (theChar >= 0x60)
 3365               		.loc 1 2264 0
 3366 0c82 0E94 0000 		call recchar
 3367               	.LVL346:
 3368 0c86 182F      		mov r17,r24
 3369               	.LVL347:
2265:stk500boot.c  **** 		{
 3370               		.loc 1 2265 0
 3371 0c88 8036      		cpi r24,lo8(96)
 3372 0c8a 00F0      		brlo .L159
2267:stk500boot.c  **** 		}
 3373               		.loc 1 2267 0
 3374 0c8c 1F75      		andi r17,lo8(95)
 3375               	.LVL348:
 3376               	.L159:
2270:stk500boot.c  **** 		{
 3377               		.loc 1 2270 0
 3378 0c8e 1032      		cpi r17,lo8(32)
 3379 0c90 00F0      		brlo .L82
2272:stk500boot.c  **** 			sendchar(0x20);
 3380               		.loc 1 2272 0
 3381 0c92 812F      		mov r24,r17
 3382 0c94 0E94 0000 		call sendchar
 3383               	.LVL349:
2273:stk500boot.c  **** 		}
 3384               		.loc 1 2273 0
 3385 0c98 80E2      		ldi r24,lo8(32)
 3386 0c9a 0E94 0000 		call sendchar
 3387               	.LVL350:
2276:stk500boot.c  **** 		{
 3388               		.loc 1 2276 0
 3389 0c9e 1634      		cpi r17,lo8(70)
 3390 0ca0 01F4      		brne .+2
 3391 0ca2 00C0      		rjmp .L83
 3392 0ca4 00F0      		brlo .+2
 3393 0ca6 00C0      		rjmp .L84
 3394 0ca8 1034      		cpi r17,lo8(64)
 3395 0caa 01F4      		brne .+2
 3396 0cac 00C0      		rjmp .L85
 3397 0cae 00F0      		brlo .+2
 3398 0cb0 00C0      		rjmp .L86
 3399 0cb2 1033      		cpi r17,lo8(48)
 3400 0cb4 01F4      		brne .+2
 3401 0cb6 00C0      		rjmp .L87
 3402 0cb8 1F33      		cpi r17,lo8(63)
 3403 0cba 01F4      		brne .+2
 3404 0cbc 00C0      		rjmp .L88
 3405               	.L82:
 3406               		.loc 1 2348 0
 3407 0cbe 60E0      		ldi r22,0
 3408 0cc0 80E0      		ldi r24,lo8(gTextMsg_HUH)
 3409 0cc2 90E0      		ldi r25,hi8(gTextMsg_HUH)
 3410 0cc4 00C0      		rjmp .L297
 3411               	.LVL351:
 3412               	.L223:
 3413               	.LBE285:
 3414               	.LBE288:
 918:stk500boot.c  **** 				}
 3415               		.loc 1 918 0
 3416 0cc6 F12C      		mov r15,__zero_reg__
 3417 0cc8 E12C      		mov r14,__zero_reg__
 3418               	.LVL352:
 3419               	.L163:
 936:stk500boot.c  **** 					#else
 3420               		.loc 1 936 0
 3421 0cca C926      		eor r12,r25
 3422               	.LVL353:
 949:stk500boot.c  **** 
 3423               		.loc 1 949 0
 3424 0ccc CC5D      		subi r28,lo8(-292)
 3425 0cce DE4F      		sbci r29,hi8(-292)
 3426 0cd0 9883      		st Y,r25
 3427 0cd2 C452      		subi r28,lo8(292)
 3428 0cd4 D140      		sbci r29,hi8(292)
 935:stk500boot.c  **** 						checksum		^=	c;
 3429               		.loc 1 935 0
 3430 0cd6 82E0      		ldi r24,lo8(2)
 949:stk500boot.c  **** 
 3431               		.loc 1 949 0
 3432 0cd8 00C0      		rjmp .L170
 3433               	.LVL354:
 3434               	.L225:
 918:stk500boot.c  **** 				}
 3435               		.loc 1 918 0
 3436 0cda F12C      		mov r15,__zero_reg__
 3437 0cdc E12C      		mov r14,__zero_reg__
 3438               	.LVL355:
 3439               	.L161:
 958:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 3440               		.loc 1 958 0
 3441 0cde 292B      		or r18,r25
 3442               	.LVL356:
 960:stk500boot.c  **** 						break;
 3443               		.loc 1 960 0
 3444 0ce0 C926      		eor r12,r25
 3445               	.LVL357:
 959:stk500boot.c  **** 						checksum		^=	c;
 3446               		.loc 1 959 0
 3447 0ce2 84E0      		ldi r24,lo8(4)
 961:stk500boot.c  **** 
 3448               		.loc 1 961 0
 3449 0ce4 00C0      		rjmp .L170
 3450               	.LVL358:
 3451               	.L226:
 918:stk500boot.c  **** 				}
 3452               		.loc 1 918 0
 3453 0ce6 F12C      		mov r15,__zero_reg__
 3454 0ce8 E12C      		mov r14,__zero_reg__
 964:stk500boot.c  **** 						{
 3455               		.loc 1 964 0
 3456 0cea 9E30      		cpi r25,lo8(14)
 3457 0cec 01F0      		breq .+2
 3458 0cee 00C0      		rjmp .L230
 3459               	.LVL359:
 967:stk500boot.c  **** 							ii				=	0;
 3460               		.loc 1 967 0
 3461 0cf0 C926      		eor r12,r25
 3462               	.LVL360:
 968:stk500boot.c  **** 						}
 3463               		.loc 1 968 0
 3464 0cf2 C75D      		subi r28,lo8(-297)
 3465 0cf4 DE4F      		sbci r29,hi8(-297)
 3466 0cf6 1982      		std Y+1,__zero_reg__
 3467 0cf8 1882      		st Y,__zero_reg__
 3468 0cfa C952      		subi r28,lo8(297)
 3469 0cfc D140      		sbci r29,hi8(297)
 3470               	.LVL361:
 3471               	.L294:
 979:stk500boot.c  **** 						{
 3472               		.loc 1 979 0
 3473 0cfe 85E0      		ldi r24,lo8(5)
 3474 0d00 00C0      		rjmp .L170
 3475               	.LVL362:
 3476               	.L227:
 918:stk500boot.c  **** 				}
 3477               		.loc 1 918 0
 3478 0d02 F12C      		mov r15,__zero_reg__
 3479 0d04 E12C      		mov r14,__zero_reg__
 3480               	.LVL363:
 3481               	.L166:
 977:stk500boot.c  **** 						checksum		^=	c;
 3482               		.loc 1 977 0
 3483 0d06 C75D      		subi r28,lo8(-297)
 3484 0d08 DE4F      		sbci r29,hi8(-297)
 3485 0d0a 4881      		ld r20,Y
 3486 0d0c 5981      		ldd r21,Y+1
 3487 0d0e C952      		subi r28,lo8(297)
 3488 0d10 D140      		sbci r29,hi8(297)
 3489 0d12 4F5F      		subi r20,-1
 3490 0d14 5F4F      		sbci r21,-1
 3491               	.LVL364:
 3492 0d16 E1E0      		ldi r30,lo8(1)
 3493 0d18 F0E0      		ldi r31,0
 3494 0d1a EC0F      		add r30,r28
 3495 0d1c FD1F      		adc r31,r29
 3496 0d1e C75D      		subi r28,lo8(-297)
 3497 0d20 DE4F      		sbci r29,hi8(-297)
 3498 0d22 6881      		ld r22,Y
 3499 0d24 7981      		ldd r23,Y+1
 3500 0d26 C952      		subi r28,lo8(297)
 3501 0d28 D140      		sbci r29,hi8(297)
 3502 0d2a E60F      		add r30,r22
 3503 0d2c F71F      		adc r31,r23
 3504 0d2e 9083      		st Z,r25
 978:stk500boot.c  **** 						if (ii == msgLength )
 3505               		.loc 1 978 0
 3506 0d30 C926      		eor r12,r25
 3507               	.LVL365:
 979:stk500boot.c  **** 						{
 3508               		.loc 1 979 0
 3509 0d32 4217      		cp r20,r18
 3510 0d34 5307      		cpc r21,r19
 3511 0d36 01F4      		brne .+2
 3512 0d38 00C0      		rjmp .L231
 3513 0d3a C75D      		subi r28,lo8(-297)
 3514 0d3c DE4F      		sbci r29,hi8(-297)
 3515 0d3e 5983      		std Y+1,r21
 3516 0d40 4883      		st Y,r20
 3517 0d42 C952      		subi r28,lo8(297)
 3518 0d44 D140      		sbci r29,hi8(297)
 3519 0d46 00C0      		rjmp .L294
 3520               	.LVL366:
 3521               	.L175:
1002:stk500boot.c  **** 			{
 3522               		.loc 1 1002 0
 3523 0d48 2131      		cpi r18,lo8(17)
 3524 0d4a 01F4      		brne .+2
 3525 0d4c 00C0      		rjmp .L179
 3526 0d4e 00F0      		brlo .+2
 3527 0d50 00C0      		rjmp .L180
 3528 0d52 2031      		cpi r18,lo8(16)
 3529 0d54 01F4      		brne .+2
 3530 0d56 00C0      		rjmp .L305
 3531               	.L171:
 3532               	.LVL367:
1311:stk500boot.c  **** 					break;
 3533               		.loc 1 1311 0
 3534 0d58 80EC      		ldi r24,lo8(-64)
 3535 0d5a 8A83      		std Y+2,r24
 3536 0d5c 00C0      		rjmp .L302
 3537               	.LVL368:
 3538               	.L173:
1002:stk500boot.c  **** 			{
 3539               		.loc 1 1002 0
 3540 0d5e 2831      		cpi r18,lo8(24)
 3541 0d60 01F4      		brne .+2
 3542 0d62 00C0      		rjmp .L181
 3543 0d64 00F4      		brsh .L182
 3544 0d66 2531      		cpi r18,lo8(21)
 3545 0d68 01F4      		brne .+2
 3546 0d6a 00C0      		rjmp .L199
 3547 0d6c 00F0      		brlo .L183
 3548 0d6e 2631      		cpi r18,lo8(22)
 3549 0d70 01F4      		brne .L171
 3550               	.L183:
 3551 0d72 8A81      		ldd r24,Y+2
 3552 0d74 9B81      		ldd r25,Y+3
 3553 0d76 9827      		eor r25,r24
 3554 0d78 8927      		eor r24,r25
 3555 0d7a 9827      		eor r25,r24
 3556               	.LVL369:
 3557               	.LBB289:
1272:stk500boot.c  **** 
 3558               		.loc 1 1272 0
 3559 0d7c 8C01      		movw r16,r24
 3560 0d7e 0D5F      		subi r16,-3
 3561 0d80 1F4F      		sbci r17,-1
 3562               	.LVL370:
1274:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 3563               		.loc 1 1274 0
 3564 0d82 1A82      		std Y+2,__zero_reg__
1275:stk500boot.c  **** 						{
 3565               		.loc 1 1275 0
 3566 0d84 2431      		cpi r18,lo8(20)
 3567 0d86 01F0      		breq .+2
 3568 0d88 00C0      		rjmp .L209
 3569 0d8a DE01      		movw r26,r28
 3570 0d8c 1196      		adiw r26,1
 3571               	.LVL371:
 3572               	.L210:
 3573               	.LBB290:
 3574               	.LBB291:
1283:stk500boot.c  **** 						#else
 3575               		.loc 1 1283 0 discriminator 1
 3576               	/* #APP */
 3577               	 ;  1283 "stk500boot.c" 1
 3578 0d8e 4BBE      		out 59, r4
 3579 0d90 F101      		movw r30, r2
 3580 0d92 2791      		elpm r18, Z+
 3581 0d94 3691      		elpm r19, Z
 3582               		
 3583               	 ;  0 "" 2
 3584               	.LVL372:
 3585               	/* #NOAPP */
 3586               	.LBE291:
1287:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 3587               		.loc 1 1287 0 discriminator 1
 3588 0d96 1296      		adiw r26,2
 3589 0d98 2C93      		st X,r18
 3590 0d9a 1297      		sbiw r26,2
 3591 0d9c FD01      		movw r30,r26
 3592 0d9e 3496      		adiw r30,4
 3593               	.LVL373:
1288:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 3594               		.loc 1 1288 0 discriminator 1
 3595 0da0 1396      		adiw r26,3
 3596 0da2 3C93      		st X,r19
 3597 0da4 1397      		sbiw r26,3
1289:stk500boot.c  **** 								size	-=	2;
 3598               		.loc 1 1289 0 discriminator 1
 3599 0da6 22E0      		ldi r18,2
 3600 0da8 220E      		add r2,r18
 3601 0daa 311C      		adc r3,__zero_reg__
 3602 0dac 411C      		adc r4,__zero_reg__
 3603 0dae 511C      		adc r5,__zero_reg__
 3604               	.LVL374:
1290:stk500boot.c  **** 							}while (size);
 3605               		.loc 1 1290 0 discriminator 1
 3606 0db0 0297      		sbiw r24,2
 3607               	.LVL375:
 3608 0db2 1296      		adiw r26,2
1291:stk500boot.c  **** 						}
 3609               		.loc 1 1291 0 discriminator 1
 3610 0db4 0097      		sbiw r24,0
 3611 0db6 01F4      		brne .L210
 3612               	.LVL376:
 3613               	.L211:
 3614               	.LBE290:
1305:stk500boot.c  **** 					}
 3615               		.loc 1 1305 0
 3616 0db8 1082      		st Z,__zero_reg__
 3617               	.LBE289:
1307:stk500boot.c  **** 
 3618               		.loc 1 1307 0
 3619 0dba 00C0      		rjmp .L191
 3620               	.LVL377:
 3621               	.L182:
1002:stk500boot.c  **** 			{
 3622               		.loc 1 1002 0
 3623 0dbc 2A31      		cpi r18,lo8(26)
 3624 0dbe 01F4      		brne .+2
 3625 0dc0 00C0      		rjmp .L184
 3626 0dc2 00F4      		brsh .+2
 3627 0dc4 00C0      		rjmp .L185
 3628 0dc6 2B31      		cpi r18,lo8(27)
 3629 0dc8 01F4      		brne .+2
 3630 0dca 00C0      		rjmp .L186
 3631 0dcc 2D31      		cpi r18,lo8(29)
 3632 0dce 01F0      		breq .+2
 3633 0dd0 00C0      		rjmp .L171
 3634               	.LVL378:
 3635               	.LBB292:
1010:stk500boot.c  **** 						{
 3636               		.loc 1 1010 0
 3637 0dd2 9D81      		ldd r25,Y+5
 3638 0dd4 9033      		cpi r25,lo8(48)
 3639 0dd6 01F0      		breq .+2
 3640 0dd8 00C0      		rjmp .L188
 3641               	.LBB293:
1012:stk500boot.c  **** 
 3642               		.loc 1 1012 0
 3643 0dda 8F81      		ldd r24,Y+7
 3644               	.LVL379:
1014:stk500boot.c  **** 							{
 3645               		.loc 1 1014 0
 3646 0ddc 8823      		tst r24
 3647 0dde 01F4      		brne .+2
 3648 0de0 00C0      		rjmp .L233
1018:stk500boot.c  **** 							{
 3649               		.loc 1 1018 0
 3650 0de2 8130      		cpi r24,lo8(1)
 3651 0de4 01F0      		breq .+2
 3652 0de6 00C0      		rjmp .L234
1020:stk500boot.c  **** 							}
 3653               		.loc 1 1020 0
 3654 0de8 88E9      		ldi r24,lo8(-104)
 3655               	.LVL380:
 3656               	.L189:
 3657               	.LBE293:
1054:stk500boot.c  **** 							msgBuffer[2]	=	0;
 3658               		.loc 1 1054 0
 3659 0dea 1A82      		std Y+2,__zero_reg__
1055:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 3660               		.loc 1 1055 0
 3661 0dec 1B82      		std Y+3,__zero_reg__
1056:stk500boot.c  **** 							msgBuffer[4]	=	0;
 3662               		.loc 1 1056 0
 3663 0dee 9C83      		std Y+4,r25
1057:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 3664               		.loc 1 1057 0
 3665 0df0 1D82      		std Y+5,__zero_reg__
1058:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 3666               		.loc 1 1058 0
 3667 0df2 8E83      		std Y+6,r24
1059:stk500boot.c  **** 						}
 3668               		.loc 1 1059 0
 3669 0df4 1F82      		std Y+7,__zero_reg__
1053:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 3670               		.loc 1 1053 0
 3671 0df6 07E0      		ldi r16,lo8(7)
 3672 0df8 10E0      		ldi r17,0
 3673               	.LVL381:
 3674               	.L191:
 3675               	.LBE292:
1318:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
 3676               		.loc 1 1318 0
 3677 0dfa 8BE1      		ldi r24,lo8(27)
 3678 0dfc 0E94 0000 		call sendchar
 3679               	.LVL382:
1321:stk500boot.c  **** 			checksum	^=	seqNum;
 3680               		.loc 1 1321 0
 3681 0e00 CC5D      		subi r28,lo8(-292)
 3682 0e02 DE4F      		sbci r29,hi8(-292)
 3683 0e04 8881      		ld r24,Y
 3684 0e06 C452      		subi r28,lo8(292)
 3685 0e08 D140      		sbci r29,hi8(292)
 3686 0e0a 0E94 0000 		call sendchar
 3687               	.LVL383:
1325:stk500boot.c  **** 			checksum	^=	c;
 3688               		.loc 1 1325 0
 3689 0e0e 812F      		mov r24,r17
 3690 0e10 0E94 0000 		call sendchar
 3691               	.LVL384:
1329:stk500boot.c  **** 			checksum ^= c;
 3692               		.loc 1 1329 0
 3693 0e14 802F      		mov r24,r16
 3694 0e16 0E94 0000 		call sendchar
 3695               	.LVL385:
 3696 0e1a 95E1      		ldi r25,lo8(21)
 3697 0e1c C92E      		mov r12,r25
 3698 0e1e CC5D      		subi r28,lo8(-292)
 3699 0e20 DE4F      		sbci r29,hi8(-292)
 3700 0e22 3881      		ld r19,Y
 3701 0e24 C452      		subi r28,lo8(292)
 3702 0e26 D140      		sbci r29,hi8(292)
 3703 0e28 C326      		eor r12,r19
 3704 0e2a C026      		eor r12,r16
 3705               	.LVL386:
1332:stk500boot.c  **** 			checksum ^= TOKEN;
 3706               		.loc 1 1332 0
 3707 0e2c 8EE0      		ldi r24,lo8(14)
 3708 0e2e 0E94 0000 		call sendchar
 3709               	.LVL387:
1333:stk500boot.c  **** 
 3710               		.loc 1 1333 0
 3711 0e32 C126      		eor r12,r17
 3712               	.LVL388:
 3713 0e34 AE01      		movw r20,r28
 3714 0e36 4F5F      		subi r20,-1
 3715 0e38 5F4F      		sbci r21,-1
 3716 0e3a 5A01      		movw r10,r20
 3717 0e3c 040F      		add r16,r20
 3718 0e3e 151F      		adc r17,r21
 3719               	.LVL389:
 3720               	.L213:
1336:stk500boot.c  **** 			{
 3721               		.loc 1 1336 0
 3722 0e40 0A15      		cp r16,r10
 3723 0e42 1B05      		cpc r17,r11
 3724 0e44 01F0      		breq .+2
 3725 0e46 00C0      		rjmp .L214
1343:stk500boot.c  **** 			seqNum++;
 3726               		.loc 1 1343 0
 3727 0e48 8C2D      		mov r24,r12
 3728 0e4a 0E94 0000 		call sendchar
 3729               	.LVL390:
1344:stk500boot.c  **** 	
 3730               		.loc 1 1344 0
 3731 0e4e CC5D      		subi r28,lo8(-292)
 3732 0e50 DE4F      		sbci r29,hi8(-292)
 3733 0e52 B881      		ld r27,Y
 3734 0e54 C452      		subi r28,lo8(292)
 3735 0e56 D140      		sbci r29,hi8(292)
 3736 0e58 BF5F      		subi r27,lo8(-(1))
 3737 0e5a CC5D      		subi r28,lo8(-292)
 3738 0e5c DE4F      		sbci r29,hi8(-292)
 3739 0e5e B883      		st Y,r27
 3740 0e60 C452      		subi r28,lo8(292)
 3741 0e62 D140      		sbci r29,hi8(292)
 3742               	.LVL391:
1348:stk500boot.c  **** 		#endif
 3743               		.loc 1 1348 0
 3744 0e64 85B1      		in r24,0x5
 3745 0e66 8058      		subi r24,lo8(-(-128))
 3746 0e68 85B9      		out 0x5,r24
 3747               	.LVL392:
 881:stk500boot.c  **** 		{
 3748               		.loc 1 881 0
 3749 0e6a DD20      		tst r13
 3750 0e6c 01F4      		brne .+2
 3751 0e6e 00C0      		rjmp .L242
 3752               	.LVL393:
 3753               	.L70:
1383:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 3754               		.loc 1 1383 0
 3755 0e70 2798      		cbi 0x4,7
1384:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
 3756               		.loc 1 1384 0
 3757 0e72 2F98      		cbi 0x5,7
1386:stk500boot.c  **** #endif
 3758               		.loc 1 1386 0
 3759 0e74 84E6      		ldi r24,lo8(100)
 3760 0e76 90E0      		ldi r25,0
 3761 0e78 0E94 0000 		call delay_ms
 3762               	.LVL394:
1390:stk500boot.c  **** 
 3763               		.loc 1 1390 0
 3764               	/* #APP */
 3765               	 ;  1390 "stk500boot.c" 1
 3766 0e7c 0000      		nop
 3767               	 ;  0 "" 2
1396:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 3768               		.loc 1 1396 0
 3769               	/* #NOAPP */
 3770 0e7e 8091 C000 		lds r24,192
 3771 0e82 8D7F      		andi r24,lo8(-3)
 3772 0e84 8093 C000 		sts 192,r24
1397:stk500boot.c  **** 
 3773               		.loc 1 1397 0
 3774 0e88 81E1      		ldi r24,lo8(17)
 3775               	/* #APP */
 3776               	 ;  1397 "stk500boot.c" 1
 3777 0e8a 8093 5700 		sts 87, r24
 3778 0e8e E895      		spm
 3779               		
 3780               	 ;  0 "" 2
1399:stk500boot.c  **** 		user_code();
 3781               		.loc 1 1399 0
 3782               	/* #NOAPP */
 3783 0e90 8091 0000 		lds r24,gInterceptAppJump
 3784 0e94 8823      		tst r24
 3785 0e96 01F4      		brne .+2
 3786 0e98 00C0      		rjmp .L215
1400:stk500boot.c  **** 	}
 3787               		.loc 1 1400 0
 3788 0e9a 0E94 0000 		call user_code
 3789               	.LVL395:
 3790               	.L188:
 3791 0e9e 892F      		mov r24,r25
 3792 0ea0 8075      		andi r24,lo8(80)
 3793               	.LBB297:
1027:stk500boot.c  **** 						{
 3794               		.loc 1 1027 0
 3795 0ea2 01F4      		brne .+2
 3796 0ea4 00C0      		rjmp .L189
 3797               	.LBB294:
1036:stk500boot.c  **** 							}
 3798               		.loc 1 1036 0
 3799 0ea6 89E0      		ldi r24,lo8(9)
 3800 0ea8 F0E0      		ldi r31,0
 3801 0eaa E0E0      		ldi r30,0
 3802               	.LBE294:
1034:stk500boot.c  **** 							{
 3803               		.loc 1 1034 0
 3804 0eac 9035      		cpi r25,lo8(80)
 3805 0eae 01F0      		breq .L299
1049:stk500boot.c  **** 						}
 3806               		.loc 1 1049 0
 3807 0eb0 80E0      		ldi r24,0
1038:stk500boot.c  **** 							{
 3808               		.loc 1 1038 0
 3809 0eb2 9835      		cpi r25,lo8(88)
 3810 0eb4 01F0      		breq .+2
 3811 0eb6 00C0      		rjmp .L189
 3812               	.LBB295:
1040:stk500boot.c  **** 							}
 3813               		.loc 1 1040 0
 3814 0eb8 89E0      		ldi r24,lo8(9)
 3815 0eba E3E0      		ldi r30,lo8(3)
 3816 0ebc F0E0      		ldi r31,0
 3817               	.L299:
 3818               	/* #APP */
 3819               	 ;  1040 "stk500boot.c" 1
 3820 0ebe 8093 5700 		sts 87, r24
 3821 0ec2 8491      		lpm r24, Z
 3822               		
 3823               	 ;  0 "" 2
 3824               	.LVL396:
 3825               	/* #NOAPP */
 3826               	.LBE295:
 3827 0ec4 00C0      		rjmp .L189
 3828               	.LVL397:
 3829               	.L233:
 3830               	.LBB296:
1016:stk500boot.c  **** 							}
 3831               		.loc 1 1016 0
 3832 0ec6 8EE1      		ldi r24,lo8(30)
 3833               	.LVL398:
 3834 0ec8 00C0      		rjmp .L189
 3835               	.LVL399:
 3836               	.L234:
1024:stk500boot.c  **** 							}
 3837               		.loc 1 1024 0
 3838 0eca 81E0      		ldi r24,lo8(1)
 3839               	.LVL400:
 3840 0ecc 00C0      		rjmp .L189
 3841               	.LVL401:
 3842               	.L177:
 3843 0ece EA81      		ldd r30,Y+2
 3844 0ed0 E059      		subi r30,lo8(-(112))
 3845               	.LBE296:
 3846               	.LBE297:
 3847               	.LBB298:
1082:stk500boot.c  **** 						{
 3848               		.loc 1 1082 0
 3849 0ed2 80E0      		ldi r24,0
 3850 0ed4 E330      		cpi r30,lo8(3)
 3851 0ed6 00F4      		brsh .L192
 3852 0ed8 F0E0      		ldi r31,0
 3853 0eda E050      		subi r30,lo8(-(CSWTCH.77))
 3854 0edc F040      		sbci r31,hi8(-(CSWTCH.77))
 3855 0ede 8081      		ld r24,Z
 3856               	.L192:
 3857               	.LVL402:
1104:stk500boot.c  **** 						msgBuffer[2]	=	value;
 3858               		.loc 1 1104 0
 3859 0ee0 1A82      		std Y+2,__zero_reg__
1105:stk500boot.c  **** 					}
 3860               		.loc 1 1105 0
 3861 0ee2 8B83      		std Y+3,r24
 3862               	.LVL403:
 3863               	.L301:
 3864               	.LBE298:
 3865               	.LBB299:
1186:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3866               		.loc 1 1186 0
 3867 0ee4 03E0      		ldi r16,lo8(3)
 3868 0ee6 10E0      		ldi r17,0
 3869               	.LBE299:
1190:stk500boot.c  **** 	#endif
 3870               		.loc 1 1190 0
 3871 0ee8 00C0      		rjmp .L191
 3872               	.LVL404:
 3873               	.L179:
1110:stk500boot.c  **** 					{
 3874               		.loc 1 1110 0
 3875 0eea 8091 0000 		lds r24,gHasFlashed
 3876 0eee 8823      		tst r24
 3877 0ef0 01F0      		breq .L239
 3878               	.LBB301:
1112:stk500boot.c  **** 						if (cnt == 0xFF) cnt = 0;
 3879               		.loc 1 1112 0
 3880 0ef2 84E0      		ldi r24,lo8(4)
 3881 0ef4 90E0      		ldi r25,0
 3882 0ef6 0E94 0000 		call eeprom_read_byte
 3883               	.LVL405:
1113:stk500boot.c  **** 
 3884               		.loc 1 1113 0
 3885 0efa 8F3F      		cpi r24,lo8(-1)
 3886 0efc 01F0      		breq .L238
1115:stk500boot.c  **** 							cnt++;
 3887               		.loc 1 1115 0
 3888 0efe 8530      		cpi r24,lo8(5)
 3889 0f00 00F4      		brsh .L239
 3890               	.LVL406:
 3891               	.L193:
1116:stk500boot.c  **** 							eeprom_write_byte(EEPROM_COUNTER_ADDR, cnt);
 3892               		.loc 1 1116 0
 3893 0f02 61E0      		ldi r22,lo8(1)
 3894 0f04 680F      		add r22,r24
 3895               	.LVL407:
1117:stk500boot.c  **** 						}
 3896               		.loc 1 1117 0
 3897 0f06 84E0      		ldi r24,lo8(4)
 3898 0f08 90E0      		ldi r25,0
 3899 0f0a 0E94 0000 		call eeprom_write_byte
 3900               	.LVL408:
 3901               	.L239:
 3902               	.LBE301:
1120:stk500boot.c  **** 					//*	fall thru
 3903               		.loc 1 1120 0
 3904 0f0e DD24      		clr r13
 3905 0f10 D394      		inc r13
 3906               	.LVL409:
 3907               	.L305:
1206:stk500boot.c  **** 					break;
 3908               		.loc 1 1206 0
 3909 0f12 1A82      		std Y+2,__zero_reg__
 3910               	.LVL410:
 3911               	.L302:
1310:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 3912               		.loc 1 1310 0
 3913 0f14 02E0      		ldi r16,lo8(2)
 3914 0f16 10E0      		ldi r17,0
1312:stk500boot.c  **** 			}
 3915               		.loc 1 1312 0
 3916 0f18 00C0      		rjmp .L191
 3917               	.LVL411:
 3918               	.L238:
 3919               	.LBB302:
1113:stk500boot.c  **** 
 3920               		.loc 1 1113 0
 3921 0f1a 80E0      		ldi r24,0
 3922               	.LVL412:
 3923 0f1c 00C0      		rjmp .L193
 3924               	.L186:
 3925               	.LBE302:
 3926               	.LBB303:
1131:stk500boot.c  **** 						unsigned char signature;
 3927               		.loc 1 1131 0
 3928 0f1e 8D81      		ldd r24,Y+5
 3929               	.LVL413:
1134:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 3930               		.loc 1 1134 0
 3931 0f20 8823      		tst r24
 3932 0f22 01F0      		breq .L240
1136:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 3933               		.loc 1 1136 0
 3934 0f24 8130      		cpi r24,lo8(1)
 3935 0f26 01F4      		brne .L241
1137:stk500boot.c  **** 						else
 3936               		.loc 1 1137 0
 3937 0f28 88E9      		ldi r24,lo8(-104)
 3938               	.LVL414:
 3939               	.L304:
 3940               	.LBE303:
 3941               	.LBB304:
1171:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 3942               		.loc 1 1171 0
 3943 0f2a 1A82      		std Y+2,__zero_reg__
 3944 0f2c 00C0      		rjmp .L303
 3945               	.LVL415:
 3946               	.L240:
 3947               	.LBE304:
 3948               	.LBB309:
1135:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 3949               		.loc 1 1135 0
 3950 0f2e 8EE1      		ldi r24,lo8(30)
 3951               	.LVL416:
 3952 0f30 00C0      		rjmp .L304
 3953               	.LVL417:
 3954               	.L241:
1139:stk500boot.c  **** 
 3955               		.loc 1 1139 0
 3956 0f32 81E0      		ldi r24,lo8(1)
 3957               	.LVL418:
 3958 0f34 00C0      		rjmp .L304
 3959               	.LVL419:
 3960               	.L184:
 3961               	.LBE309:
1150:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 3962               		.loc 1 1150 0
 3963 0f36 1A82      		std Y+2,__zero_reg__
 3964               	.LBB310:
1151:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 3965               		.loc 1 1151 0
 3966 0f38 89E0      		ldi r24,lo8(9)
 3967 0f3a E1E0      		ldi r30,lo8(1)
 3968 0f3c F0E0      		ldi r31,0
 3969               	/* #APP */
 3970               	 ;  1151 "stk500boot.c" 1
 3971 0f3e 8093 5700 		sts 87, r24
 3972 0f42 8491      		lpm r24, Z
 3973               		
 3974               	 ;  0 "" 2
 3975               	/* #NOAPP */
 3976               	.L303:
 3977               	.LVL420:
 3978               	.LBE310:
 3979 0f44 8B83      		std Y+3,r24
1152:stk500boot.c  **** 					break;
 3980               		.loc 1 1152 0
 3981 0f46 1C82      		std Y+4,__zero_reg__
1149:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 3982               		.loc 1 1149 0
 3983 0f48 04E0      		ldi r16,lo8(4)
 3984 0f4a 10E0      		ldi r17,0
1153:stk500boot.c  **** 
 3985               		.loc 1 1153 0
 3986 0f4c 00C0      		rjmp .L191
 3987               	.LVL421:
 3988               	.L181:
 3989               	.LBB311:
1159:stk500boot.c  **** 						{
 3990               		.loc 1 1159 0
 3991 0f4e 8B81      		ldd r24,Y+3
 3992 0f50 8035      		cpi r24,lo8(80)
 3993 0f52 01F4      		brne .L195
1161:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 3994               		.loc 1 1161 0
 3995 0f54 8C81      		ldd r24,Y+4
 3996 0f56 8830      		cpi r24,lo8(8)
 3997 0f58 01F4      		brne .L196
 3998               	.LBB305:
1162:stk500boot.c  **** 							else
 3999               		.loc 1 1162 0
 4000 0f5a 89E0      		ldi r24,lo8(9)
 4001 0f5c E2E0      		ldi r30,lo8(2)
 4002 0f5e F0E0      		ldi r31,0
 4003               	.L300:
 4004               	.LBE305:
 4005               	.LBB306:
1168:stk500boot.c  **** 						}
 4006               		.loc 1 1168 0
 4007               	/* #APP */
 4008               	 ;  1168 "stk500boot.c" 1
 4009 0f60 8093 5700 		sts 87, r24
 4010 0f64 8491      		lpm r24, Z
 4011               		
 4012               	 ;  0 "" 2
 4013               	.LVL422:
 4014               	/* #NOAPP */
 4015 0f66 00C0      		rjmp .L304
 4016               	.LVL423:
 4017               	.L196:
 4018               	.LBE306:
 4019               	.LBB307:
1164:stk500boot.c  **** 						}
 4020               		.loc 1 1164 0
 4021 0f68 89E0      		ldi r24,lo8(9)
 4022 0f6a F0E0      		ldi r31,0
 4023 0f6c E0E0      		ldi r30,0
 4024 0f6e 00C0      		rjmp .L300
 4025               	.L195:
 4026               	.LBE307:
 4027               	.LBB308:
1168:stk500boot.c  **** 						}
 4028               		.loc 1 1168 0
 4029 0f70 89E0      		ldi r24,lo8(9)
 4030 0f72 E3E0      		ldi r30,lo8(3)
 4031 0f74 F0E0      		ldi r31,0
 4032 0f76 00C0      		rjmp .L300
 4033               	.L185:
 4034               	.LVL424:
 4035               	.LBE308:
 4036               	.LBE311:
 4037               	.LBB312:
1182:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 4038               		.loc 1 1182 0
 4039 0f78 8D81      		ldd r24,Y+5
 4040               	.LVL425:
 4041               	.LBB300:
1183:stk500boot.c  **** 						boot_spm_busy_wait();
 4042               		.loc 1 1183 0
 4043 0f7a 836C      		ori r24,lo8(-61)
 4044               	.LVL426:
 4045 0f7c 99E0      		ldi r25,lo8(9)
 4046               	/* #APP */
 4047               	 ;  1183 "stk500boot.c" 1
 4048 0f7e E1E0      		ldi r30, 1
 4049 0f80 F0E0      		ldi r31, 0
 4050 0f82 082E      		mov r0, r24
 4051 0f84 9093 5700 		sts 87, r25
 4052 0f88 E895      		spm
 4053               		
 4054               	 ;  0 "" 2
 4055               	/* #NOAPP */
 4056               	.L198:
 4057               	.LBE300:
1184:stk500boot.c  **** 
 4058               		.loc 1 1184 0 discriminator 1
 4059 0f8a 07B6      		in __tmp_reg__,0x37
 4060 0f8c 00FC      		sbrc __tmp_reg__,0
 4061 0f8e 00C0      		rjmp .L198
 4062               	.LVL427:
1187:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 4063               		.loc 1 1187 0
 4064 0f90 1A82      		std Y+2,__zero_reg__
1188:stk500boot.c  **** 					}
 4065               		.loc 1 1188 0
 4066 0f92 1B82      		std Y+3,__zero_reg__
 4067 0f94 00C0      		rjmp .L301
 4068               	.LVL428:
 4069               	.L180:
 4070               	.LBE312:
1196:stk500boot.c  **** 					break;
 4071               		.loc 1 1196 0
 4072 0f96 80EC      		ldi r24,lo8(-64)
 4073 0f98 8A83      		std Y+2,r24
1194:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 4074               		.loc 1 1194 0
 4075 0f9a 02E0      		ldi r16,lo8(2)
 4076 0f9c 10E0      		ldi r17,0
1193:stk500boot.c  **** 					msgLength		=	2;
 4077               		.loc 1 1193 0
 4078 0f9e CB5D      		subi r28,lo8(-293)
 4079 0fa0 DE4F      		sbci r29,hi8(-293)
 4080 0fa2 1882      		st Y,__zero_reg__
 4081 0fa4 1982      		std Y+1,__zero_reg__
 4082 0fa6 1A82      		std Y+2,__zero_reg__
 4083 0fa8 1B82      		std Y+3,__zero_reg__
 4084 0faa C552      		subi r28,lo8(293)
 4085 0fac D140      		sbci r29,hi8(293)
1197:stk500boot.c  **** 
 4086               		.loc 1 1197 0
 4087 0fae 00C0      		rjmp .L191
 4088               	.LVL429:
 4089               	.L174:
 4090 0fb0 6A81      		ldd r22,Y+2
 4091 0fb2 7B81      		ldd r23,Y+3
 4092 0fb4 8C81      		ldd r24,Y+4
 4093 0fb6 9D81      		ldd r25,Y+5
 4094 0fb8 0E94 0000 		call __bswapsi2
1201:stk500boot.c  **** 	#else
 4095               		.loc 1 1201 0
 4096 0fbc 1B01      		movw r2,r22
 4097 0fbe 2C01      		movw r4,r24
 4098 0fc0 220C      		lsl r2
 4099 0fc2 331C      		rol r3
 4100 0fc4 441C      		rol r4
 4101 0fc6 551C      		rol r5
 4102 0fc8 00C0      		rjmp .L305
 4103               	.L257:
 4104               	.LBB313:
1214:stk500boot.c  ****                         }
 4105               		.loc 1 1214 0
 4106 0fca 81E0      		ldi r24,lo8(1)
 4107 0fcc 8093 0000 		sts gHasFlashed,r24
 4108               	.L199:
 4109 0fd0 0A81      		ldd r16,Y+2
 4110 0fd2 1B81      		ldd r17,Y+3
 4111 0fd4 1027      		eor r17,r16
 4112 0fd6 0127      		eor r16,r17
 4113 0fd8 1027      		eor r17,r16
 4114               	.LVL430:
1224:stk500boot.c  **** 						{
 4115               		.loc 1 1224 0
 4116 0fda 2331      		cpi r18,lo8(19)
 4117 0fdc 01F0      		breq .+2
 4118 0fde 00C0      		rjmp .L200
1227:stk500boot.c  **** 							{
 4119               		.loc 1 1227 0
 4120 0fe0 CB5D      		subi r28,lo8(-293)
 4121 0fe2 DE4F      		sbci r29,hi8(-293)
 4122 0fe4 2881      		ld r18,Y
 4123 0fe6 3981      		ldd r19,Y+1
 4124 0fe8 4A81      		ldd r20,Y+2
 4125 0fea 5B81      		ldd r21,Y+3
 4126 0fec C552      		subi r28,lo8(293)
 4127 0fee D140      		sbci r29,hi8(293)
 4128 0ff0 2115      		cp r18,__zero_reg__
 4129 0ff2 60EC      		ldi r22,-64
 4130 0ff4 3607      		cpc r19,r22
 4131 0ff6 63E0      		ldi r22,3
 4132 0ff8 4607      		cpc r20,r22
 4133 0ffa 5105      		cpc r21,__zero_reg__
 4134 0ffc 00F4      		brsh .L201
1229:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 4135               		.loc 1 1229 0
 4136 0ffe 83E0      		ldi r24,lo8(3)
 4137               	/* #APP */
 4138               	 ;  1229 "stk500boot.c" 1
 4139 1000 F901      		movw r30, r18
 4140 1002 4093 5B00 		sts  91, r20
 4141 1006 8093 5700 		sts 87, r24
 4142 100a E895      		spm
 4143               		
 4144               	 ;  0 "" 2
 4145               	/* #NOAPP */
 4146               	.L202:
1230:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 4147               		.loc 1 1230 0 discriminator 1
 4148 100c 07B6      		in __tmp_reg__,0x37
 4149 100e 00FC      		sbrc __tmp_reg__,0
 4150 1010 00C0      		rjmp .L202
1231:stk500boot.c  **** 							}
 4151               		.loc 1 1231 0
 4152 1012 CB5D      		subi r28,lo8(-293)
 4153 1014 DE4F      		sbci r29,hi8(-293)
 4154 1016 8881      		ld r24,Y
 4155 1018 9981      		ldd r25,Y+1
 4156 101a AA81      		ldd r26,Y+2
 4157 101c BB81      		ldd r27,Y+3
 4158 101e C552      		subi r28,lo8(293)
 4159 1020 D140      		sbci r29,hi8(293)
 4160 1022 9F5F      		subi r25,-1
 4161 1024 AF4F      		sbci r26,-1
 4162 1026 BF4F      		sbci r27,-1
 4163 1028 CB5D      		subi r28,lo8(-293)
 4164 102a DE4F      		sbci r29,hi8(-293)
 4165 102c 8883      		st Y,r24
 4166 102e 9983      		std Y+1,r25
 4167 1030 AA83      		std Y+2,r26
 4168 1032 BB83      		std Y+3,r27
 4169 1034 C552      		subi r28,lo8(293)
 4170 1036 D140      		sbci r29,hi8(293)
 4171               	.LVL431:
 4172               	.L201:
 4173 1038 8B85      		ldd r24,Y+11
 4174 103a DE01      		movw r26,r28
 4175 103c 1196      		adiw r26,1
 4176               	.LBE313:
 4177               	.LBB315:
1139:stk500boot.c  **** 
 4178               		.loc 1 1139 0 discriminator 1
 4179 103e B201      		movw r22,r4
 4180 1040 A101      		movw r20,r2
 4181               	.LBE315:
 4182               	.LBB316:
1240:stk500boot.c  **** 
 4183               		.loc 1 1240 0 discriminator 1
 4184 1042 21E0      		ldi r18,lo8(1)
 4185               	.L204:
 4186               	.LVL432:
1239:stk500boot.c  **** 								boot_page_fill(address,data);
 4187               		.loc 1 1239 0 discriminator 1
 4188 1044 1B96      		adiw r26,11
 4189 1046 9C91      		ld r25,X
 4190 1048 1B97      		sbiw r26,11
1240:stk500boot.c  **** 
 4191               		.loc 1 1240 0 discriminator 1
 4192               	/* #APP */
 4193               	 ;  1240 "stk500boot.c" 1
 4194 104a 0C01      		movw  r0, r24
 4195 104c FA01      		movw r30, r20
 4196 104e 6093 5B00 		sts 91, r22
 4197 1052 2093 5700 		sts 87, r18
 4198 1056 E895      		spm
 4199 1058 1124      		clr  r1
 4200               		
 4201               	 ;  0 "" 2
1242:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 4202               		.loc 1 1242 0 discriminator 1
 4203               	/* #NOAPP */
 4204 105a 4E5F      		subi r20,-2
 4205 105c 5F4F      		sbci r21,-1
 4206 105e 6F4F      		sbci r22,-1
 4207 1060 7F4F      		sbci r23,-1
 4208               	.LVL433:
1243:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 4209               		.loc 1 1243 0 discriminator 1
 4210 1062 0250      		subi r16,2
 4211 1064 1109      		sbc r17,__zero_reg__
 4212               	.LVL434:
 4213 1066 1296      		adiw r26,2
 4214               	.LVL435:
1244:stk500boot.c  **** 
 4215               		.loc 1 1244 0 discriminator 1
 4216 1068 0115      		cp r16,__zero_reg__
 4217 106a 1105      		cpc r17,__zero_reg__
 4218 106c 01F0      		breq .L203
1237:stk500boot.c  **** 
 4219               		.loc 1 1237 0
 4220 106e 1A96      		adiw r26,10
 4221 1070 8C91      		ld r24,X
 4222 1072 1A97      		sbiw r26,10
 4223               	.LVL436:
 4224 1074 00C0      		rjmp .L204
 4225               	.LVL437:
 4226               	.L203:
1246:stk500boot.c  **** 							boot_spm_busy_wait();
 4227               		.loc 1 1246 0
 4228 1076 95E0      		ldi r25,lo8(5)
 4229               	.LVL438:
 4230               	/* #APP */
 4231               	 ;  1246 "stk500boot.c" 1
 4232 1078 F101      		movw r30, r2
 4233 107a 4092 5B00 		sts 91, r4
 4234 107e 9093 5700 		sts 87, r25
 4235 1082 E895      		spm
 4236               		
 4237               	 ;  0 "" 2
 4238               	/* #NOAPP */
 4239               	.L205:
1247:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 4240               		.loc 1 1247 0 discriminator 1
 4241 1084 07B6      		in __tmp_reg__,0x37
 4242 1086 00FC      		sbrc __tmp_reg__,0
 4243 1088 00C0      		rjmp .L205
1248:stk500boot.c  **** 						}
 4244               		.loc 1 1248 0
 4245 108a 81E1      		ldi r24,lo8(17)
 4246               	.LVL439:
 4247               	/* #APP */
 4248               	 ;  1248 "stk500boot.c" 1
 4249 108c 8093 5700 		sts 87, r24
 4250 1090 E895      		spm
 4251               		
 4252               	 ;  0 "" 2
 4253               	.LVL440:
 4254               	/* #NOAPP */
 4255               	.L206:
1263:stk500boot.c  **** 					}
 4256               		.loc 1 1263 0
 4257 1092 1A82      		std Y+2,__zero_reg__
 4258               	.LBE316:
1265:stk500boot.c  **** 
 4259               		.loc 1 1265 0
 4260 1094 1A01      		movw r2,r20
 4261               	.LVL441:
 4262 1096 2B01      		movw r4,r22
 4263 1098 00C0      		rjmp .L302
 4264               	.LVL442:
 4265               	.L200:
 4266               	.LBB317:
 4267               	.LBB314:
1253:stk500boot.c  **** 							/* write EEPROM */
 4268               		.loc 1 1253 0
 4269 109a D201      		movw r26,r4
 4270 109c C101      		movw r24,r2
 4271 109e B695      		lsr r27
 4272 10a0 A795      		ror r26
 4273 10a2 9795      		ror r25
 4274 10a4 8795      		ror r24
 4275               	.LVL443:
 4276 10a6 8824      		clr r8
 4277 10a8 8394      		inc r8
 4278 10aa 912C      		mov r9,__zero_reg__
 4279 10ac 8C0E      		add r8,r28
 4280 10ae 9D1E      		adc r9,r29
 4281 10b0 800E      		add r8,r16
 4282 10b2 911E      		adc r9,r17
1255:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 4283               		.loc 1 1255 0
 4284 10b4 DE01      		movw r26,r28
 4285 10b6 1196      		adiw r26,1
 4286 10b8 3D01      		movw r6,r26
1256:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 4287               		.loc 1 1256 0
 4288 10ba 5C01      		movw r10,r24
 4289 10bc C25E      		subi r28,lo8(-286)
 4290 10be DE4F      		sbci r29,hi8(-286)
 4291 10c0 E881      		ld r30,Y
 4292 10c2 F981      		ldd r31,Y+1
 4293 10c4 CE51      		subi r28,lo8(286)
 4294 10c6 D140      		sbci r29,hi8(286)
 4295 10c8 AE1A      		sub r10,r30
 4296 10ca BF0A      		sbc r11,r31
 4297               	.LVL444:
 4298               	.L207:
1255:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 4299               		.loc 1 1255 0
 4300 10cc 8614      		cp r8,r6
 4301 10ce 9704      		cpc r9,r7
 4302 10d0 01F4      		brne .L208
 4303 10d2 30E0      		ldi r19,0
 4304 10d4 20E0      		ldi r18,0
 4305 10d6 000F      		lsl r16
 4306 10d8 111F      		rol r17
 4307 10da 221F      		rol r18
 4308 10dc 331F      		rol r19
 4309 10de B901      		movw r22,r18
 4310 10e0 A801      		movw r20,r16
 4311 10e2 420D      		add r20,r2
 4312 10e4 531D      		adc r21,r3
 4313 10e6 641D      		adc r22,r4
 4314 10e8 751D      		adc r23,r5
 4315 10ea 00C0      		rjmp .L206
 4316               	.L208:
 4317               	.LVL445:
1256:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 4318               		.loc 1 1256 0
 4319 10ec D301      		movw r26,r6
 4320 10ee 1A96      		adiw r26,10
 4321 10f0 6C91      		ld r22,X
 4322 10f2 C501      		movw r24,r10
 4323 10f4 860D      		add r24,r6
 4324 10f6 971D      		adc r25,r7
 4325 10f8 0E94 0000 		call eeprom_write_byte
 4326               	.LVL446:
 4327 10fc BFEF      		ldi r27,-1
 4328 10fe 6B1A      		sub r6,r27
 4329 1100 7B0A      		sbc r7,r27
 4330               	.LVL447:
 4331 1102 00C0      		rjmp .L207
 4332               	.LVL448:
 4333               	.L209:
 4334 1104 FE01      		movw r30,r28
 4335 1106 3196      		adiw r30,1
 4336 1108 9F01      		movw r18,r30
 4337 110a 280F      		add r18,r24
 4338 110c 391F      		adc r19,r25
 4339               	.LBE314:
 4340               	.LBE317:
 4341               	.LBB318:
1275:stk500boot.c  **** 						{
 4342               		.loc 1 1275 0
 4343 110e B201      		movw r22,r4
 4344 1110 A101      		movw r20,r2
 4345               	.LVL449:
 4346               	.L212:
1297:stk500boot.c  **** 								EEARH	=	((address >> 8));
 4347               		.loc 1 1297 0 discriminator 1
 4348 1112 41BD      		out 0x21,r20
1298:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 4349               		.loc 1 1298 0 discriminator 1
 4350 1114 852E      		mov r8,r21
 4351 1116 962E      		mov r9,r22
 4352 1118 A72E      		mov r10,r23
 4353 111a BB24      		clr r11
 4354 111c 82BC      		out 0x22,r8
1299:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 4355               		.loc 1 1299 0 discriminator 1
 4356 111e 4F5F      		subi r20,-1
 4357 1120 5F4F      		sbci r21,-1
 4358 1122 6F4F      		sbci r22,-1
 4359 1124 7F4F      		sbci r23,-1
 4360               	.LVL450:
1300:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 4361               		.loc 1 1300 0 discriminator 1
 4362 1126 F89A      		sbi 0x1f,0
 4363               	.LVL451:
1301:stk500boot.c  **** 								size--;
 4364               		.loc 1 1301 0 discriminator 1
 4365 1128 A0B5      		in r26,0x20
 4366 112a A283      		std Z+2,r26
 4367 112c 3196      		adiw r30,1
 4368               	.LVL452:
1303:stk500boot.c  **** 						}
 4369               		.loc 1 1303 0 discriminator 1
 4370 112e E217      		cp r30,r18
 4371 1130 F307      		cpc r31,r19
 4372 1132 01F4      		brne .L212
 4373 1134 AC01      		movw r20,r24
 4374               	.LVL453:
 4375 1136 4150      		subi r20,1
 4376 1138 5109      		sbc r21,__zero_reg__
 4377 113a 70E0      		ldi r23,0
 4378 113c 60E0      		ldi r22,0
 4379 113e 4F5F      		subi r20,-1
 4380 1140 5F4F      		sbci r21,-1
 4381 1142 6F4F      		sbci r22,-1
 4382 1144 7F4F      		sbci r23,-1
 4383 1146 240E      		add r2,r20
 4384 1148 351E      		adc r3,r21
 4385 114a 461E      		adc r4,r22
 4386 114c 571E      		adc r5,r23
 4387 114e E3E0      		ldi r30,lo8(3)
 4388 1150 F0E0      		ldi r31,0
 4389               	.LVL454:
 4390 1152 EC0F      		add r30,r28
 4391 1154 FD1F      		adc r31,r29
 4392 1156 E80F      		add r30,r24
 4393 1158 F91F      		adc r31,r25
 4394 115a 00C0      		rjmp .L211
 4395               	.LVL455:
 4396               	.L214:
 4397               	.LBE318:
1338:stk500boot.c  **** 				sendchar(c);
 4398               		.loc 1 1338 0
 4399 115c D501      		movw r26,r10
 4400 115e 9D90      		ld r9,X+
 4401               	.LVL456:
 4402 1160 5D01      		movw r10,r26
 4403               	.LVL457:
1339:stk500boot.c  **** 				checksum ^=c;
 4404               		.loc 1 1339 0
 4405 1162 892D      		mov r24,r9
 4406 1164 0E94 0000 		call sendchar
 4407               	.LVL458:
1340:stk500boot.c  **** 				msgLength--;
 4408               		.loc 1 1340 0
 4409 1168 C924      		eor r12,r9
 4410               	.LVL459:
 4411 116a 00C0      		rjmp .L213
 4412               	.LVL460:
 4413               	.L215:
1403:stk500boot.c  **** 			"clr	r30		\n\t"
 4414               		.loc 1 1403 0
 4415               	/* #APP */
 4416               	 ;  1403 "stk500boot.c" 1
 4417 116c EE27      		clr	r30		
 4418 116e FF27      		clr	r31		
 4419 1170 0994      		ijmp	
 4420               		
 4421               	 ;  0 "" 2
 4422               	/* #NOAPP */
 4423               	.L216:
 4424 1172 00C0      		rjmp .L216
 4425               	.LVL461:
 4426               	.L242:
 4427 1174 50E0      		ldi r21,0
 4428 1176 40E0      		ldi r20,0
 4429 1178 0C94 0000 		jmp .L69
 4430               	.LVL462:
 4431               	.L229:
 928:stk500boot.c  **** 						}
 4432               		.loc 1 928 0
 4433 117c 8BE1      		ldi r24,lo8(27)
 4434 117e C82E      		mov r12,r24
 4435               	.LVL463:
 927:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 4436               		.loc 1 927 0
 4437 1180 81E0      		ldi r24,lo8(1)
 4438 1182 00C0      		rjmp .L170
 4439               	.LVL464:
 4440               	.L231:
 4441 1184 C75D      		subi r28,lo8(-297)
 4442 1186 DE4F      		sbci r29,hi8(-297)
 4443 1188 3983      		std Y+1,r19
 4444 118a 2883      		st Y,r18
 4445 118c C952      		subi r28,lo8(297)
 4446 118e D140      		sbci r29,hi8(297)
 981:stk500boot.c  **** 						}
 4447               		.loc 1 981 0
 4448 1190 86E0      		ldi r24,lo8(6)
 4449               	.LVL465:
 4450 1192 00C0      		rjmp .L170
 4451               	.LVL466:
 4452               	.L220:
 918:stk500boot.c  **** 				}
 4453               		.loc 1 918 0
 4454 1194 F12C      		mov r15,__zero_reg__
 4455 1196 E12C      		mov r14,__zero_reg__
 4456               	.LVL467:
 4457               	.L77:
 922:stk500boot.c  **** 				{
 4458               		.loc 1 922 0
 4459 1198 8330      		cpi r24,lo8(3)
 4460 119a 01F4      		brne .+2
 4461 119c 00C0      		rjmp .L161
 4462 119e 00F4      		brsh .L218
 4463 11a0 8130      		cpi r24,lo8(1)
 4464 11a2 01F4      		brne .+2
 4465 11a4 00C0      		rjmp .L163
 4466 11a6 00F4      		brsh .+2
 4467 11a8 00C0      		rjmp .L170
 4468 11aa 00C0      		rjmp .L164
 4469               	.L218:
 4470 11ac 8530      		cpi r24,lo8(5)
 4471 11ae 01F4      		brne .+2
 4472 11b0 00C0      		rjmp .L166
 4473 11b2 00F0      		brlo .L230
 4474 11b4 8630      		cpi r24,lo8(6)
 4475 11b6 01F0      		breq .+2
 4476 11b8 00C0      		rjmp .L160
 4477               	.LVL468:
 4478               	.L168:
 986:stk500boot.c  **** 						{
 4479               		.loc 1 986 0
 4480 11ba 9C15      		cp r25,r12
 4481 11bc 01F4      		brne .+2
 4482 11be 00C0      		rjmp .L232
 4483               	.L230:
 972:stk500boot.c  **** 						}
 4484               		.loc 1 972 0
 4485 11c0 80E0      		ldi r24,0
 4486               	.LVL469:
 4487 11c2 00C0      		rjmp .L170
 4488               		.cfi_endproc
 4489               	.LFE27:
 4491               		.section	.rodata
 4494               	CSWTCH.77:
 4495 0000 0F        		.byte	15
 4496 0001 02        		.byte	2
 4497 0002 0A        		.byte	10
 4498               		.local	low_cnt.2051
 4499               		.comm	low_cnt.2051,2,1
 4500               		.local	st.2050
 4501               		.comm	st.2050,1,1
 4502               	.global	gTextMsg_END
 4503               		.section	.progmem.data,"a",@progbits
 4506               	gTextMsg_END:
 4507 0000 2A00      		.string	"*"
 4508               	.global	gTextMsg_HELP_MSG_Y
 4511               	gTextMsg_HELP_MSG_Y:
 4512 0002 593D 506F 		.string	"Y=Port blink"
 4512      7274 2062 
 4512      6C69 6E6B 
 4512      00
 4513               	.global	gTextMsg_HELP_MSG_V
 4516               	gTextMsg_HELP_MSG_V:
 4517 000f 563D 7368 		.string	"V=show interrupt Vectors"
 4517      6F77 2069 
 4517      6E74 6572 
 4517      7275 7074 
 4517      2056 6563 
 4518               	.global	gTextMsg_HELP_MSG_R
 4521               	gTextMsg_HELP_MSG_R:
 4522 0028 523D 4475 		.string	"R=Dump RAM"
 4522      6D70 2052 
 4522      414D 00
 4523               	.global	gTextMsg_HELP_MSG_Q
 4526               	gTextMsg_HELP_MSG_Q:
 4527 0033 513D 5175 		.string	"Q=Quit"
 4527      6974 00
 4528               	.global	gTextMsg_HELP_MSG_L
 4531               	gTextMsg_HELP_MSG_L:
 4532 003a 4C3D 4C69 		.string	"L=List I/O Ports"
 4532      7374 2049 
 4532      2F4F 2050 
 4532      6F72 7473 
 4532      00
 4533               	.global	gTextMsg_HELP_MSG_H
 4536               	gTextMsg_HELP_MSG_H:
 4537 004b 483D 4865 		.string	"H=Help"
 4537      6C70 00
 4538               	.global	gTextMsg_HELP_MSG_F
 4541               	gTextMsg_HELP_MSG_F:
 4542 0052 463D 4475 		.string	"F=Dump FLASH"
 4542      6D70 2046 
 4542      4C41 5348 
 4542      00
 4543               	.global	gTextMsg_HELP_MSG_E
 4546               	gTextMsg_HELP_MSG_E:
 4547 005f 453D 4475 		.string	"E=Dump EEPROM"
 4547      6D70 2045 
 4547      4550 524F 
 4547      4D00 
 4548               	.global	gTextMsg_HELP_MSG_B
 4551               	gTextMsg_HELP_MSG_B:
 4552 006d 423D 426C 		.string	"B=Blink LED"
 4552      696E 6B20 
 4552      4C45 4400 
 4553               	.global	gTextMsg_HELP_MSG_AT
 4556               	gTextMsg_HELP_MSG_AT:
 4557 0079 403D 4545 		.string	"@=EEPROM test"
 4557      5052 4F4D 
 4557      2074 6573 
 4557      7400 
 4558               	.global	gTextMsg_HELP_MSG_QM
 4561               	gTextMsg_HELP_MSG_QM:
 4562 0087 3F3D 4350 		.string	"?=CPU stats"
 4562      5520 7374 
 4562      6174 7300 
 4563               	.global	gTextMsg_HELP_MSG_0
 4566               	gTextMsg_HELP_MSG_0:
 4567 0093 303D 5A65 		.string	"0=Zero addr"
 4567      726F 2061 
 4567      6464 7200 
 4568               	.global	gTextMsg_PORT
 4571               	gTextMsg_PORT:
 4572 009f 504F 5254 		.string	"PORT"
 4572      00
 4573               	.global	gTextMsg_EEPROMerrorCnt
 4576               	gTextMsg_EEPROMerrorCnt:
 4577 00a4 4545 2065 		.string	"EE err cnt="
 4577      7272 2063 
 4577      6E74 3D00 
 4578               	.global	gTextMsg_ReadingEEprom
 4581               	gTextMsg_ReadingEEprom:
 4582 00b0 5265 6164 		.string	"Reading EE"
 4582      696E 6720 
 4582      4545 00
 4583               	.global	gTextMsg_WriteToEEprom
 4586               	gTextMsg_WriteToEEprom:
 4587 00bb 5772 6974 		.string	"Writting EE"
 4587      7469 6E67 
 4587      2045 4500 
 4588               	.global	gTextMsg_SPACE
 4591               	gTextMsg_SPACE:
 4592 00c7 2000      		.string	" "
 4593               	.global	gTextMsg_MustBeLetter
 4596               	gTextMsg_MustBeLetter:
 4597 00c9 4D75 7374 		.string	"Must be a letter"
 4597      2062 6520 
 4597      6120 6C65 
 4597      7474 6572 
 4597      00
 4598               	.global	gTextMsg_PortNotSupported
 4601               	gTextMsg_PortNotSupported:
 4602 00da 506F 7274 		.string	"Port not supported"
 4602      206E 6F74 
 4602      2073 7570 
 4602      706F 7274 
 4602      6564 00
 4603               	.global	gTextMsg_WHAT_PORT
 4606               	gTextMsg_WHAT_PORT:
 4607 00ed 5768 6174 		.string	"What port:"
 4607      2070 6F72 
 4607      743A 00
 4608               	.global	gTextMsg_jmp
 4611               	gTextMsg_jmp:
 4612 00f8 6A6D 7020 		.string	"jmp "
 4612      00
 4613               	.global	gTextMsg_rjmp
 4616               	gTextMsg_rjmp:
 4617 00fd 726A 6D70 		.string	"rjmp  "
 4617      2020 00
 4618               	.global	gTextMsg_noVector
 4621               	gTextMsg_noVector:
 4622 0104 6E6F 2076 		.string	"no vector"
 4622      6563 746F 
 4622      7200 
 4623               	.global	gTextMsg_VECTOR_HEADER
 4626               	gTextMsg_VECTOR_HEADER:
 4627 010e 5623 2020 		.string	"V#   ADDR   op code     instruction addr   Interrupt"
 4627      2041 4444 
 4627      5220 2020 
 4627      6F70 2063 
 4627      6F64 6520 
 4628               	.global	gTextMsg_GCC_VERSION_STR
 4631               	gTextMsg_GCC_VERSION_STR:
 4632 0143 372E 332E 		.string	"7.3.0"
 4632      3000 
 4633               	.global	gTextMsg_AVR_LIBC_VER_STR
 4636               	gTextMsg_AVR_LIBC_VER_STR:
 4637 0149 322E 302E 		.string	"2.0.0"
 4637      3000 
 4638               	.global	gTextMsg_GCC_DATE_STR
 4641               	gTextMsg_GCC_DATE_STR:
 4642 014f 4A61 6E20 		.string	"Jan 23 2026"
 4642      3233 2032 
 4642      3032 3600 
 4643               	.global	gTextMsg_FUSE_BYTE_LOCK
 4646               	gTextMsg_FUSE_BYTE_LOCK:
 4647 015b 4C6F 636B 		.string	"Lock fuse   = "
 4647      2066 7573 
 4647      6520 2020 
 4647      3D20 00
 4648               	.global	gTextMsg_FUSE_BYTE_EXT
 4651               	gTextMsg_FUSE_BYTE_EXT:
 4652 016a 4578 7420 		.string	"Ext fuse    = "
 4652      6675 7365 
 4652      2020 2020 
 4652      3D20 00
 4653               	.global	gTextMsg_FUSE_BYTE_HIGH
 4656               	gTextMsg_FUSE_BYTE_HIGH:
 4657 0179 4869 6768 		.string	"High fuse   = "
 4657      2066 7573 
 4657      6520 2020 
 4657      3D20 00
 4658               	.global	gTextMsg_FUSE_BYTE_LOW
 4661               	gTextMsg_FUSE_BYTE_LOW:
 4662 0188 4C6F 7720 		.string	"Low fuse    = "
 4662      6675 7365 
 4662      2020 2020 
 4662      3D20 00
 4663               	.global	gTextMsg_CPU_SIGNATURE
 4666               	gTextMsg_CPU_SIGNATURE:
 4667 0197 4350 5520 		.string	"CPU ID      = "
 4667      4944 2020 
 4667      2020 2020 
 4667      3D20 00
 4668               	.global	gTextMsg_GCC_VERSION
 4671               	gTextMsg_GCC_VERSION:
 4672 01a6 4743 4320 		.string	"GCC Version = "
 4672      5665 7273 
 4672      696F 6E20 
 4672      3D20 00
 4673               	.global	gTextMsg_AVR_LIBC
 4676               	gTextMsg_AVR_LIBC:
 4677 01b5 4156 5220 		.string	"AVR LibC Ver= "
 4677      4C69 6243 
 4677      2056 6572 
 4677      3D20 00
 4678               	.global	gTextMsg_AVR_ARCH
 4681               	gTextMsg_AVR_ARCH:
 4682 01c4 5F5F 4156 		.string	"__AVR_ARCH__= "
 4682      525F 4152 
 4682      4348 5F5F 
 4682      3D20 00
 4683               	.global	gTextMsg_CPU_Type
 4686               	gTextMsg_CPU_Type:
 4687 01d3 4350 5520 		.string	"CPU Type    = "
 4687      5479 7065 
 4687      2020 2020 
 4687      3D20 00
 4688               	.global	gTextMsg_COMPILED_ON
 4691               	gTextMsg_COMPILED_ON:
 4692 01e2 436F 6D70 		.string	"Compiled on = "
 4692      696C 6564 
 4692      206F 6E20 
 4692      3D20 00
 4693               	.global	gTextMsg_HUH
 4696               	gTextMsg_HUH:
 4697 01f1 4875 683F 		.string	"Huh?"
 4697      00
 4698               	.global	gTextMsg_Prompt
 4701               	gTextMsg_Prompt:
 4702 01f6 426F 6F74 		.string	"Bootloader>"
 4702      6C6F 6164 
 4702      6572 3E00 
 4703               	.global	gTextMsg_Explorer
 4706               	gTextMsg_Explorer:
 4707 0202 4172 6475 		.string	"Arduino explorer stk500V2 by MLS"
 4707      696E 6F20 
 4707      6578 706C 
 4707      6F72 6572 
 4707      2073 746B 
 4708               	.global	gTextMsg_CPU_Name
 4711               	gTextMsg_CPU_Name:
 4712 0223 4154 6D65 		.string	"ATmega2560"
 4712      6761 3235 
 4712      3630 00
 4713               		.comm	gEepromIndex,4,1
 4714               		.comm	gFlashIndex,4,1
 4715               		.comm	gRamIndex,4,1
 4716               		.local	current_boot_count
 4717               		.comm	current_boot_count,1,1
 4718               		.local	gInterceptAppJump
 4719               		.comm	gInterceptAppJump,1,1
 4720               		.local	gHasFlashed
 4721               		.comm	gHasFlashed,1,1
 4722               	.global	app_start
 4723               		.section .bss
 4726               	app_start:
 4727 0000 0000      		.zero	2
 4728               		.text
 4729               	.Letext0:
 4730               		.file 3 "/usr/lib/avr/include/stdint.h"
 4731               		.file 4 "/usr/lib/gcc/avr/7.3.0/include/stddef.h"
 4732               		.file 5 "/usr/lib/avr/include/stdlib.h"
 4733               		.file 6 "/usr/lib/avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 stk500boot.c
     /tmp/cc7boqqX.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc7boqqX.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc7boqqX.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc7boqqX.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc7boqqX.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc7boqqX.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc7boqqX.s:12     .text:0000000000000000 sendchar
     /tmp/cc7boqqX.s:43     .text.unlikely:0000000000000000 recchar
     /tmp/cc7boqqX.s:66     .text:0000000000000018 corebeep_init
     /tmp/cc7boqqX.s:85     .text:000000000000001e beep_init
     /tmp/cc7boqqX.s:114    .init9:0000000000000000 __jumpMain
     /tmp/cc7boqqX.s:125    *ABS*:00000000000021ff __stack
     /tmp/cc7boqqX.s:1066   .text.startup:0000000000000000 main
     /tmp/cc7boqqX.s:164    .text:0000000000000034 delay_ms
     /tmp/cc7boqqX.s:216    .text:0000000000000052 user_code
     /tmp/cc7boqqX.s:4499   .bss:0000000000000004 st.2050
                             .bss:0000000000000002 low_cnt.2051
     /tmp/cc7boqqX.s:441    .text:000000000000013c PrintFromPROGMEM
     /tmp/cc7boqqX.s:504    .text:0000000000000164 PrintNewLine
     /tmp/cc7boqqX.s:525    .text.unlikely:000000000000000e PrintAvailablePort
     /tmp/cc7boqqX.s:4571   .progmem.data:000000000000009f gTextMsg_PORT
     /tmp/cc7boqqX.s:563    .text:0000000000000170 PrintFromPROGMEMln
     /tmp/cc7boqqX.s:583    .text:0000000000000178 PrintString
     /tmp/cc7boqqX.s:626    .text:0000000000000190 PrintHexByte
     /tmp/cc7boqqX.s:686    .text.unlikely:0000000000000028 DumpHex.constprop.1
     /tmp/cc7boqqX.s:966    .text:00000000000001be PrintDecInt
     /tmp/cc7boqqX.s:4726   .bss:0000000000000000 app_start
     /tmp/cc7boqqX.s:4501   .bss:0000000000000005 current_boot_count
     /tmp/cc7boqqX.s:4717   .bss:0000000000000006 gInterceptAppJump
     /tmp/cc7boqqX.s:4546   .progmem.data:000000000000005f gTextMsg_HELP_MSG_E
                            *COM*:0000000000000004 gEepromIndex
     /tmp/cc7boqqX.s:4531   .progmem.data:000000000000003a gTextMsg_HELP_MSG_L
     /tmp/cc7boqqX.s:4521   .progmem.data:0000000000000028 gTextMsg_HELP_MSG_R
                            *COM*:0000000000000004 gRamIndex
     /tmp/cc7boqqX.s:4566   .progmem.data:0000000000000093 gTextMsg_HELP_MSG_0
                            *COM*:0000000000000004 gFlashIndex
     /tmp/cc7boqqX.s:4561   .progmem.data:0000000000000087 gTextMsg_HELP_MSG_QM
     /tmp/cc7boqqX.s:4706   .progmem.data:0000000000000202 gTextMsg_Explorer
     /tmp/cc7boqqX.s:4691   .progmem.data:00000000000001e2 gTextMsg_COMPILED_ON
     /tmp/cc7boqqX.s:4641   .progmem.data:000000000000014f gTextMsg_GCC_DATE_STR
     /tmp/cc7boqqX.s:4686   .progmem.data:00000000000001d3 gTextMsg_CPU_Type
     /tmp/cc7boqqX.s:4711   .progmem.data:0000000000000223 gTextMsg_CPU_Name
     /tmp/cc7boqqX.s:4681   .progmem.data:00000000000001c4 gTextMsg_AVR_ARCH
     /tmp/cc7boqqX.s:4671   .progmem.data:00000000000001a6 gTextMsg_GCC_VERSION
     /tmp/cc7boqqX.s:4631   .progmem.data:0000000000000143 gTextMsg_GCC_VERSION_STR
     /tmp/cc7boqqX.s:4676   .progmem.data:00000000000001b5 gTextMsg_AVR_LIBC
     /tmp/cc7boqqX.s:4636   .progmem.data:0000000000000149 gTextMsg_AVR_LIBC_VER_STR
     /tmp/cc7boqqX.s:4666   .progmem.data:0000000000000197 gTextMsg_CPU_SIGNATURE
     /tmp/cc7boqqX.s:4661   .progmem.data:0000000000000188 gTextMsg_FUSE_BYTE_LOW
     /tmp/cc7boqqX.s:4656   .progmem.data:0000000000000179 gTextMsg_FUSE_BYTE_HIGH
     /tmp/cc7boqqX.s:4651   .progmem.data:000000000000016a gTextMsg_FUSE_BYTE_EXT
     /tmp/cc7boqqX.s:4646   .progmem.data:000000000000015b gTextMsg_FUSE_BYTE_LOCK
     /tmp/cc7boqqX.s:4556   .progmem.data:0000000000000079 gTextMsg_HELP_MSG_AT
     /tmp/cc7boqqX.s:4586   .progmem.data:00000000000000bb gTextMsg_WriteToEEprom
     /tmp/cc7boqqX.s:4581   .progmem.data:00000000000000b0 gTextMsg_ReadingEEprom
     /tmp/cc7boqqX.s:4576   .progmem.data:00000000000000a4 gTextMsg_EEPROMerrorCnt
     /tmp/cc7boqqX.s:4591   .progmem.data:00000000000000c7 gTextMsg_SPACE
     /tmp/cc7boqqX.s:4551   .progmem.data:000000000000006d gTextMsg_HELP_MSG_B
     /tmp/cc7boqqX.s:4541   .progmem.data:0000000000000052 gTextMsg_HELP_MSG_F
     /tmp/cc7boqqX.s:4536   .progmem.data:000000000000004b gTextMsg_HELP_MSG_H
     /tmp/cc7boqqX.s:4526   .progmem.data:0000000000000033 gTextMsg_HELP_MSG_Q
     /tmp/cc7boqqX.s:4516   .progmem.data:000000000000000f gTextMsg_HELP_MSG_V
     /tmp/cc7boqqX.s:4511   .progmem.data:0000000000000002 gTextMsg_HELP_MSG_Y
     /tmp/cc7boqqX.s:4626   .progmem.data:000000000000010e gTextMsg_VECTOR_HEADER
     /tmp/cc7boqqX.s:4621   .progmem.data:0000000000000104 gTextMsg_noVector
     /tmp/cc7boqqX.s:4616   .progmem.data:00000000000000fd gTextMsg_rjmp
     /tmp/cc7boqqX.s:4611   .progmem.data:00000000000000f8 gTextMsg_jmp
     /tmp/cc7boqqX.s:4606   .progmem.data:00000000000000ed gTextMsg_WHAT_PORT
     /tmp/cc7boqqX.s:4601   .progmem.data:00000000000000da gTextMsg_PortNotSupported
     /tmp/cc7boqqX.s:4596   .progmem.data:00000000000000c9 gTextMsg_MustBeLetter
     /tmp/cc7boqqX.s:4701   .progmem.data:00000000000001f6 gTextMsg_Prompt
     /tmp/cc7boqqX.s:4696   .progmem.data:00000000000001f1 gTextMsg_HUH
     /tmp/cc7boqqX.s:4494   .rodata:0000000000000000 CSWTCH.77
     /tmp/cc7boqqX.s:4719   .bss:0000000000000007 gHasFlashed
     /tmp/cc7boqqX.s:4506   .progmem.data:0000000000000000 gTextMsg_END

UNDEFINED SYMBOLS
eeprom_write_byte
eeprom_read_byte
__divmodhi4
__udivmodsi4
__bswapsi2
__do_copy_data
__do_clear_bss
